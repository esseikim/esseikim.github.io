---
categories: [정보처리기사, 모의고사 문제 풀이]
---

Q. 여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크에 분산 저장하는 기술을 무엇이라고 하는지 쓰시오.

> RAID(Redundant Array of Independent Disks; 복수 배열 독립 디스크)
> 

- RAID는 여러 개의 하드디스크에 일부 중복된 데이터를 나눠서 저장하는 기술이고 디스크 어레이(Disk Array)라고도 한다.
- 데이터를 나누는 다양한 방법이 존재하며, 이 방법들을 레벨이라 하는데, 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등의 다양한 목적을 만족시킬 수 있다.
- RAID의 레벨은 다음과 같다.
    
    
    | 레벨 | 설명 |
    | --- | --- |
    | RAID 0 | 패리티(오류 검출 기능)가 없는 스트라이핑된 세트(적어도 2개의 디스크) - 하나의 디스크만 손상되어도 전체 데이터 파손 |
    | RAID 1 | 패리티(오류 검출 기능)가 없는 미러링된 세트(적어도 2개의 디스크) - 데이터의 다중화, 중복 저장, 높은 신뢰도 |
    | RAID 2 - 비트 | 비트 레벨의 스트라이핑과 해밍코드 패리티 사용 |
    | RAID 3 - 바이트 | 패러티가 단순 제공되는(Dedicated) 스트라이핑된 세트(적어도 3개의 디스크) |
    | RAID 4 - 워드 | 패러티가 단순 제공되는(Dedicated) 스트라이핀된 세트(적어도 3개의 디스크) |
    | RAID 5 | 패리티가 배분되는(Distributed) 스트라이핑된 세트(적어도 3개의 디스크) |
    | RAID 6 | 패리티가 배분되는(Distributed) 스트라이핑된 세트(적어도 4개의 디스크) |
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(1).png)

    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(2).png)
    

---

Q. 기업 IT 서비스와 관련하여 다음에서 설명하는 용어를 쓰시오.

> ITIL(Information Technology Infrastructure Library; 정보기술 인프라 라이브러리)
> 
- IT 서비스의 운영 및 관리를 돕기 위한 문서들의 집합이다.
- IT 조직이 기존의 기술 중심적인 운영에서 사용자들의 요구에 초점을 맞춘 고객 지향적인 운영방식을 채택함에 따라 각자 개별적인 IT 관리 관행을 만드는 것을 방지하기 위해서 영국 정부가 다양한 IT 서비스들의 관리 방법들(Best Practice)을 모아 만든 표준적인 참고문서이다.

- ITIL은 IT 서비스의 운영 및 관리를 돕기 위한 문서들의 집합이다.
- ITIL은 기업 IT 서비스와 관련하여 영국 정부가 다양한 IT 서비스들의 관리 방법들(Best Practice)을 모아 만든 표준적인 참고 문서이다.

---

Q. 커널의 유형 중 장치 드라이버, 프로토콜 스택, 파일 시스템과 같은 전통적인 OS의 기능들을 사용자 영역에 놓고 하드웨어 추상화를 최소화한 커널로 목적이 분명한 임베디드 시스템이나 성능 최적화가 필요한 영역에서 활용하는 커널은 무엇인가?

> 마이크로 커널(Micro Kernel)
> 

- 커널의 유형에는 마이크로커널과 모놀리식 커널이 있다.
    - 마이크로커널(Micro Kernel)
        - 장치 드라이버, 프로토콜 스택, 파일 시스템과 같은 전통적인 OS의 기능들을 사용자 영역에 놓고 하드웨어 추상화를 최소화한 커널
        - 목적이 분명한 임베디드 시스템이나 성능 최적화가 필요한 영역에서 활용
    - 모놀리식 커널(Monolithic Kernel)
        - 하드웨어 위에 높은 수준의 가상 계층을 제공하는 커널
        - 프로세스 관리, 동시성 관리, 메모리 관리 등을 관리자 모드에서 작동하여 사용자에게 고수준의 플랫폼을 제공하는 커널
        - 다수의 복잡한 애플리케이션을 동적으로 수행할 경우에 활용하기 좋음

---

Q. 다음은 병행 제어 관련 내용이다. () 안에 들어갈 용어를 쓰시오.

> 현황 파악오류(Dirty Read), 갱신 손실(Lost Update)
> 

다수의 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 병행제어(Concurrency Control)가 중요하다. 병행 제어 미보장 시에 나타나는 문제점 중에서 ( ① )은/는 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류이고, ( ② )은/는 먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생하는 오류이다. 이런 현상이 발생되면 데이터베이스에 심각한 문제가 발생하기 때문에 사전에 병행 제어 기법을 활용해야 한다.

- 병행제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 갱신 분실, 비완료 의존성, 모순성, 연쇄 복귀 등의 문제점이 발생함
- 병행 제어 미보장 시 문제점은 다음과 같다.
    - 갱신 손실(Lost Update)
        - 먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생하는 오류
            
            ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(3).png)
            
    - 현황 파악오류(Dirty Read), 비완료 의존성(Uncommitted Dependency)
        - 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류
            
            ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(4).png)
            
    - 모순성(Inconsistency)
        - 두 트랜잭션이 동시에 실행되어 데이터베이스의 일관성이 결여되는 오류
            
            ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(5).png)
            
    - 연쇄복귀(Cascading Rollback)
        - 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류
            
            ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(6).png)
            
        

---

Q. 다음은 [학생] 테이블이다. [쿼리]의 결과로 표시되는 레코드의 개수를 쓰시오.

> 1
> 

[학생]

| 학번 | 이름 | 학년 |
| --- | --- | --- |
| 202101 | 윤봉길 | 1 |
| 202102 | 안중근 | 3 |
| 202103 | 이순신 | 2 |
| 202104 | 홍범도 | 3 |
| 202105 | 김좌진 | 4 |
| 202106 | 유관순 | 3 |
| 202107 | 이봉창 | 2 |

[쿼리]

```sql
SELECT COUNT(*) FROM 학생 WHERE 학년 >= 3;
```

- 학생 테이블에서 3학년 이상(SELECT * FROM 학생 WHERE 학년 >= 3;)인 쿼리 결과는 다음과 같다.
    
    
    | 학번 | 이름 | 학년 |
    | --- | --- | --- |
    | 202102 | 안중근 | 3 |
    | 202104 | 홍범도 | 3 |
    | 202105 | 김좌진 | 4 |
    | 202106 | 유관순 | 3 |

- COUNT(*)을 하면 레코드의 개수가 4이므로 결과는 다음과 같다.
    
    
    | COUNT(*) |
    | --- |
    | 4 |

- COUNT(*)에 의한 결과값은 4라는 값 1행만 나오게 되므로 레코드 수는 1이다.

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> 15
> 

```python
sum=0
lol = [[1, 2, 3], [4, 5]]
for sub in lol:
	for item in sub:
		 sum += item

print(sum)
```

- lol에는 아래와 같은 2차원 구조로 리스트를 선언한다.
    
    
    | 1 | 2 | 3 |
    | --- | --- | --- |
    | 4 | 5 |  |
- for 반복문이 이중으로 반복한다.
- 바깥의 for 문에서는 lol을 [1,  2, 3]과 [4, 5]로 2번 반복 수행한다.
- 안쪽의 for 문에서는 sub 별로 반복 수행한다.
- sum 변수에는 item을 누적합계에 대입한다.
- 화면에는 sum 값을 출력한다.

---

Q. 패스워드로 사용될 수 있는 영문자(대소문자), 숫자, 특수문자 등을 무작위로 대입하여 패스워드를 알아내는 공격 기법은 무엇인가?

> 무차별 대입 공격(Brute Force Attack)
> 

- 패스워드 크래킹의 유형은 다음과 같다.
    
    
    | 유형 | 설명 |
    | --- | --- |
    | 사전 대입 공격(Dictionary Attack) | 시스템 또는 서비스의 ID와 패스워드를 크랙하기 위해서 ID와 패스워드가 될 가능성이 있는 단어를 파일로 만들어 놓고 이 파일의 단어를 대입하여 크랙하는 공격 기법         |
    | 무차별 대입 공격(Brute Force Attack) | 패스워드로 사용할 수 있는 영문자(대소문자), 숫자, 특수문자 등을 무작위로 대입하여 패스워드를 알아내는 공격 기법 |
    | 패스워드 하이브리드 공격(Password Hybrid Attack) | 사전 공격과 무차별 대입 공격을 결합하여 공격하는 기법 |
    | 레인보우 테이블 공격(Rainbow Table Attack) | 패스워드별로 해시값을 미리 생성해서 테이블에 모아 놓고, 크래킹하고자 하는 해시값을 테이블에서 검색해서 역으로 패스워드를 찾는 공격 기법 |

---

Q. 테스트 레벨(Test Level) 중 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법은 무엇인가?

> 통합 테스트(Integration Test)
> 

- 통합 테스트는 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 단계이다.
- 테스트 레벨의 종류 및 개념은 다음과 같다. **[단통시인]**
    
    
    | 종류 | 설명 |
    | --- | --- |
    | 단위 테스트 | 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계 |
    | 통합 테스트 | 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 단계 |
    | 시스템 테스트 | 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 테스트 단계 |
    | 인수 테스트 | 계약상의 요구사항을 만족했는지 확인하기 위한 테스트 단계 |
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(7).png)
    

- **개발 단계**에 따른 애플리케이션 테스트
    - 소프트웨어의 개발 단계에 따라 **단위** 테스트, **통합** 테스트, **시스템** 테스트, **인수** 테스트로 분류됨 이렇게 분류된 것을 테스트 레벨이라고 함
    - **애플리케이션 테스트**와 **소프트웨어 개발 단계**를 **연결**하여 표현한 것을 **V-모델**이라고 함

![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(8).png)

![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(9).png)

- **단위 테스트(Unit Test)**
    - 단위 테스트는 코딩 직후 소프트웨어 설계의 최소 단위인 **모듈**이나 **컴포넌트**에 초점을 맞춰 테스트하는 것
    - **인터페이스**, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사함
    - 사용자의 요구사항을 기반으로 한 **기능성** 테스트를 최우선으로 수행함
    - **구조 기반** 테스트(**화이트박스 테스트, 복잡도 위주**)와 **명세 기반** 테스트(**블랙박스 테스트, 기능 위주**)로 나뉘지만 주로 구조 기반 테스트를 시행함

- **통합 테스트(Integration Test)**
    - 통합 테스트는 단위 테스트가 완료된 **모듈**들을 **결합**하여 **하나의 시스템**으로 완성시키는 과정에서의 테스트를 의미함
    - 통합 테스트는 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법
    - **모듈 간 또는 통합된 컴포넌트 간, 인터페이스 간**의 **상호 작용** **오류**를 검사함
    - **비점진적** 통합 방식
        - 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트하는 방법
        - 빠른 테스트, 오류 파악, 수정 어려움 → 소규모, 프로그램 일부만 테스트 하는 경우
        - 종류 : 빅뱅 통합 테스트 방식(**모든 모듈**이 **미리 결합**되어 있는 **프로그램 전체**를 **테스트**)
    - **점진적** 통합 방식
        - **모듈 단위**로 **단계적으로 통합**하면서 테스트하는 방법
        - 종류 : 하향식 통합 테스트, 상향식 통합 테스트, 혼합식 통합 테스트

- **하향식** 통합 테스트(Top Down Integration Test)
    - 하향식 통합 테스트는 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법
    - 하위 컴포넌트 개발이 완료되지 않은 경우 스텁**(Stub)**을 사용
    - **깊이 우선** 방법 또는  **너비 우선** 방식이 있음
        
        ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(10).png)
        
        ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(11).png)
        
- **하향식** 통합 테스트 절차
    1. **주요 제어 모듈**은 **작성된 프로그램**을 사용하고, 주요 제어 모듈의 **종속 모듈들은 스텁(Stub)**으로 대체함
        - 제어 모듈: 실제 테스트할 모듈, 스텁: 상위 모듈을 테스트 하기 위해 **기능만 가진** 하위 모듈
    2. 깊이 우선 또는 넓이 우선 등의 통합 방식에 따라 하위 모듈인 스텁들이 한 번에 하나씩 실제 모듈로 교체됨
    3. 모듈이 통합될 때마다 테스트를 실시함
    4. 새로운 오류가 발생하지 않음을 보증하기 위해 **회귀 테스트**를 실시함

- **상향식** 통합 테스트(Bottom Up Integration Test)
- 상향식 통합 테스트는 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법
- 하나의 **주요 제어 모듈**과 관련된 **종속 모듈의 그룹**인 **클러스터** 필요
- 상위 모듈 개발이 완료되지 않은 경우 **드라이버(Driver)**를 사용하기도 함
- 상향식 통합 테스트 절차
    1. 하위 모듈들을 **클러스터(Cluster)로 결합**함
        - 클러스터: 제어 모듈, 종속 모듈을 하나로 합침
    2. 상위 모듈에서 **데이터의 입.출력을 확인**하기 위해 **더미 모듈인 드라이버 (Driver)**를 작성함
        - 드라이버: 존재 하지 않는 상위 모델의 인터페이스 역할을 해주는 모듈
    3. 통합된 **클러스터 단위로 테스트** 함
    4. 테스트가 완료되면 **클러스터**는 프로그램 구조의 **상위로 이동**하여 결합하고 **드라이버는 실제 모듈로 대체**됨
    
- **혼합식** 통합 테스트
    - 혼합식 통합 테스트는 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 **최적의 테스트**를 지원하는 방식임
    - **샌드위치(Sandwich)식 통합 테스트 방법**이라고도 함

- **시스템 테스트(System Test)**
    - 시스템 테스트는 **개발된 소프트웨어**가 **해당 컴퓨터 시스템**에서 **완벽하게 수행**되는가를 점검하는 테스트임
    - **기능적 요구사항(기능 위주, 블랙박스)**과 **비기능적 요구사항(논리 위주, 화이트박스)**으로 구분하여 각각을 만족하는지 테스트함

- **인수 테스트(Acceptance Test)**
    - 인수 테스트는 개발한 소프트웨어가 **사용자의 요구사항**을 **충족**하는지에 중점을 두고 테스트하는 방법임
    - 인수 테스트는 개발한 소프트웨어를 **사용자가 직접** 테스트함
- 인수 테스트는 다음과 같이 6가지의 종류로 구분해서 테스트함
    - **사용자** 인수 테스트
        - **사용자가** 시스템 **사용의 적절성** 여부를 확인함
    - **운영상**의 인수 테스트
        - **시스템 관리자**가 **시스템 인수 시** 수행하는 테스트 기법
        - **백업/복원** 시스템, **재난 복구**, **사용자 관리**, **정기 점검** 등을 확인함
    - **계약** 인수 테스트
        - **계약상의 인수/검수 조건**을 준수하는지 여부를 확인함
    - **규정** 인수 테스트
        - 소프트웨어가 **정부 지침, 법규, 규정** 등 규정에 맞게 개발되었는지 확인함
    - **알파** 테스트
        - **개발자의 장소**에서 사용자가 **개발자 앞**에서 행하는 테스트 기법
        - 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 **사용자와 개발자가 함께 확인**하면서 기록함
    - **베타** 테스트
        - **선정된 최종 사용자**가 **여러 명의 사용자 앞**에서 행하는 테스트 기법
        - 실업무를 가지고 사용자가 직접 테스트

---

Q. 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 방식으로 비교적 빠른 응답과 대화식 시분할 시스템에 적합한 프로세스 스케줄링 기법은 무엇인가?

> 선점형 스케줄링(Preemptive Scheduling) 기법
> 

- 프로세스 스케줄링의 유형은 다음과 같다.
    - 선점형 스케줄링(Preemptive Scheduling)
        - 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식
        - 장점: 비교적 빠른 응답, 대화식 시분할 시스템에 적합
        - 단점: 높은 우선순위 프로세스들이 들어오는 경우 오버헤드 초래
        - 알고리즘: 라운드 로빈(Round Robin), SRT(Shortest Remaining Time First), 다단계 큐(Multi-Level Queue), 다단계 피드백 큐(Multi-Level Feedback Queue)
        - 활용: 실시간 응답 환경, Deadline 응답 환경
    - 비선점형 스케줄링(Non Preemptive Scheduling)
        - 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식
        - 장정: 응답시간 예상이 용이, 모든 프로세스에 대한 요구를 공정하게 처리
        - 단점: 짧은 작업을 수행하는 프로세스가 긴 작업 종료시까지 대기
        - 알고리즘: 우선순위(Priority), 기한부(Deadline), FCFS, HRN(High Response Ratio Next), SJF(Shortest Job First)
        - 활용: 처리시간 편차가 적은 특정 프로세스 환경
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(12).png)
    

- 주요 **디스크** 스케줄링
    - 선점 스케줄링 종류 : Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등
    - 비선점 스케줄링 종류 : 우선순위, 기한부, FCFS, HRN, SJF 등
        - 우선순위 : 미리 정의한 알고리즘대로 프로세스의 우선순위를 결정하는 방식
        - 기한부 : 프로세스마다 정해진 시간할당량만큼만 실행되도록 지정하는 방식

- FCFS(First Come First Service) = FIFO (First In First Out)
    - FCFS는 가장 간단한 스케줄링으로, 디스크 대기 큐에 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법
    - FCFS는 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
    - 디스크 대기 큐에 있는 트랙 순서대로 디스크 헤드를 이동시킴
    - 디스크 대기 큐에 들어온 순서대로 서비스하기 때문에 더 높은 우선순위의 요청이 입력되어도 순서가 바뀌지 않아 공평성이 보장됨
    - 디스크 오버헤드가 적을 때 효율적이며, 프로그래밍이 쉽다
    - 헤드 이동 거리가 상당히 길어질 수 있음. ← 끝과 끝의 트랙번호가 나란히 들어올 경우
    - 디스크 오버헤드가 커지면 응답 시간이 길어짐
    - 탐색 시간을 최적화하려는 시도가 없는 기법임
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(13).png)
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(14).png)
    
    ① 실행 시간을 이용하여 다음과 같이 각 프로세스의 대기 시간과 반환 시간을 구함
    
    - 대기 시간 : 프로세스가 대기한 시간으로, 바로 앞 프로세스까지의 진행 시간으로 계산
    - 반환 시간 : 프로세스의 대기 시간과 실행 시간의 합
    
    ② 실행 시간, 대기 시간, 반환 시간의 평균은 '각 프로세스 시간의 합/프로세스의 개수’를 이용
    

- **SSTF(Shortest Seek Time First)**
    - 탐색 거리(Seek Distance)가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법
    - 현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동시킴
    - FCFS보다 처리량이 많고(가까운 트랙 계산), 평균 탐색 시간이 짧다(가까운 거리 먼저 처리)
    - 처리량이 많은 일괄 처리 시스템에 유용함
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(15).png)
    

- **SJF(Shortest Job First**, 단기 작업 우선)
    - SJF는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법
    - 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(16).png)
    

- **HRN**(Hightest Response-ratio Next)
    - HRN은 대기 시간과 서비스(실행) 시간을 이용하는 기법
    - 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것
    - 우선순위를 계산하여 그 숫자가 가장 **높은 것**부터 낮은 순으로 우선순위가 부여됨
    - 우선순위 계산식, 대 서 서, 서비스 시간 = 실행 시간
        
        우선순위 계산식 = (대기 시간 + 서비스 시간) / 서비스 시간
        
                               
        

![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(17).png)

- **RR(Round Robin)**
    - RR은 각 프로세스를 시간 할당량(Time Slice, Quantum) 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주는 기법
    - 시분할 시스템(Time Sharing System)을 위해 고안된 방식으로, 할당되는 시간의 크기가 작으면 작은 프로세스들에게 유리함
        - 처리해야할 여러개의 프로세스, 각 프로세스에 특정 시간 할당, 그 시간만큼 CPU 할당
    - 할당되는 시간이 클 경우 FCFS 기법과 같아지고, 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생되어 요청된 작업을 신속히 처리할 수 없음
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(18).png)
    

![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(19).png)

![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(20).png)

![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(21).png)

- **SRT(Shortest Remaining Time)**
    - SRT는 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법
    - 시분할 시스템에 유용하며, 준비상태 큐에 있는 각 프로세스의 실행 시간을 추적하여 보유하고 있어야 하므로 오버헤드가 증가함
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(22).png)
    

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 6
> 

```java
public class Soojebi {
	public static void main(String args[]) {
		int n = 10;
		n+=2;
		n-=3;
		n*=5;
		n/=7;
		n%=11;
		System.out.println(n);
	}
}
```

| 코드 | n | 설명 |
| --- | --- | --- |
| n=10 | 10 | n에 10을 대입 |
| n+=2 | 12 | n에 2를 더함(n=n+2) |
| n-=3 | 9 | n에 3을 뺌(n=n-3) |
| n*=5 | 45 | n에 5를 곱함(n=n*5) |
| n/=7 | 6 | n에서 7을 나눔(n=n/7) - 정수형과 정수형 연산이므로 결과는 정수형(소수점 버림) |
| n%=11 | 6 | n을 11로 나눴을 때 나머지(n=n%11)이므로 6이 됨 |

---

Q. 다음은 자바언어 코드이다. 출력 결과를 쓰시오.

> 27
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int i, sum = 0;
		for(i=1; i<=110; i++) {
			if(i%4 == 0)
				sum +=1;
		}
		System.out.print(sum);
	}
}
```

- 주어진 코드는 1부터 110까지의 숫자 중에서 4의 배수인 숫자의 개수를 세는 코드이다. 변수 sum은 4의 배수인 숫자의 개수를 저장한다. for 반복문을 통해 1부터 110까지의 숫자를 순회하면서, 숫자를 4로 나누었을 때 나머지가 0인지를 검사한다. 나머지가 0이라면 해당 숫자는 4의 배수이므로, sum 변수에 1을 더한다. 최종적으로 sum 변수에는 1부터 110까지의 숫자 중 4의 배수인 숫자의 개수가 저장되며, 이를 출력한다.
    - for 반복문에서 사용할 정수형 변수 i를 선언한다.
    - 정수형 변수 sum을 선언하고 0으로 초기화한다.
    - for 반복문에서는 i가 1부터 110보다 작거나 같을 때까지 i 값을 1씩 증가시키며 반복을 수행한다. for 반복문 내부에서는 i 값에 4로 나눈 나머지가 0과 같은 경우 sum 값을 1 증가시킨다.
    - for 반복문이 종료되고 sum 변수의 값을 화면에 출력한다.

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 18
> 

```c
#include <stdio.h>
void main() {
	int i, j;
	int sum=0;
	int arr[3][3];
	
	for(i=0; i<3; i++) {
		for(j=0; j<3; j++) {
			arr[i][j] = i+j;
		}
	}
	
	for(i=0; i<3; i++) {
		for(j=0; j<3; j++) { 
			sum += arr[i][j];
		}
	}  
print("%d", sum);
}
```

- for 반복문에서 사용할 정수형 변수 i, j를 선언한다. 정수형 변수 sum을 선언하고 0으로 초기화한다. 값을 지정할 정수형 변수 arr 배열을 3행 3열로 선언한다.
- 상단 2중 for 반복문에서 i와 j를 더한 값을 arr[i][j]에 대입한다. 하단 2중 for 반복문에서 arr[i][j] 값을 sum에 누적 합을 계산한다. 2중 for 반복문이 종료되고 화면에 sum 값을 출력한다.

| i | j | arr[i][j] | sum |
| --- | --- | --- | --- |
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 0 | 2 | 2 | 3 |
| 1 | 0 | 1 | 4 |
| 1 | 1 | 2 | 6 |
| 1 | 2 | 3 | 9 |
| 2 | 0 | 2 | 11 |
| 2 | 1 | 3 | 14 |
| 2 | 2 | 4 | 18 |

---

Q. 화이트박스(Whitebox) 테스트의 개념에 대해 간략히 서술하시오.

> 화이트박스 테스트는 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트 방식이다.
> 

- 화이트박스 테스트는 소스 코드를 보면서 테스트 케이스를 다양하게 만들어 테스트를 수행하는 방식이다.
    
    ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(23).png)
    
- **테스트 기법**에 따른 애플리케이션 테스트
    - 프로그램을 실제로 실행하며 오류를 찾는 테스트 방법(동적 테스트)
- **화이트박스 테스트(White Box Test), 구조 기반 테스트**
    - 화이트박스 테스트는 모듈의 원시 코드를 오픈시킨 상태에서 **원시 코드의 논리적인 모든 경로를 테스트**하여 테스트 케이스를 설계하는 방법임
    - 화이트박스 테스트는 설계된 절차에 초점을 둔 **구조**적 테스트로 프로시저 설계의 **제어 구조**를 사용하여 테스트 케이스를 설계하며, 테스트 과정의 초기에 적용됨
    - 모듈 안의 작동을 **직접 관찰**함
    - 원시 코드(모듈)의 **모든 문장을 한 번 이상 실행**함으로써 수행됨
    - 프로그램의 제어 구조에 따라 **선택, 반복등의 분기점 부분들을 수행**함으로써 **논리적 경로를 제어**함
- 화이트박스 테스트의 종류
    - **기초 경로 검사(Base Path Testing)**
        - **테스트 케이스 설계자**가 **절차적 설계의 논리적 복잡성**을 **측정**할 수 있게 해주는 테스트 기법
        - 대표적인 화이트박스 테스트 기법임
    - **제어 구조** 검사 (**Control Structure** Testing)
        - **조건** 검사**(Condition Testing)** : 프로그램 모듈 내에 있는 **논리적 조건**을 테스트하는 테스트 케이스 설계 기법
        - **루프** 검사**(Loop Testing)** : 프로그램의 **반복(Loop) 구조에 초점**을 맞춰 실시하는 테스트 케이스 설계 기법
        - **데이터 흐름** 검사**(Data Flow Testing)** : 프로그램에서 **변수의 정의**와 변수 **사용의 위치에 초점**을 맞춰 실시하는 테스트 케이스 설계 기법
        
- 화이트박스 테스트의 검증 기준
    - **구문** 커버리지(Statement Coverage), 문장 커버리지
        - 소스 코드의 **모든 구문이 한 번 이상 수행**되도록 테스트 케이스를 설계함
    - **결정** 커버리지(Decision Coverage), **분기** 커버리지 ← 조건 별 True/ False
        - 소스 코드의 **모든 조건문**이 한 번 이상 수행되도록 테스트 케이스를 설계함
        - **전체 조건식**이 **적어도** 한번은 참과 거짓의 결과를 수행하는 커버리지
        - 결정 커버리지는 결정 포인트 내의 전체 조건식이 적어도 한 번은 참과 거짓의 결과를 수행해야 하기 때문에 첫 번째 분기문도 참, 거짓이 와야 하고, 두 번째 분기도 참, 거짓이 한 번씩 와야 한다.
    - **조건** 커버리지(Condition Coverage) ← **전체 조건식 무시, 개별 조건**식 True/False 수행
        - 소스 코드의 모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계함
        - 각 **개별 조건식이 적어도** 한번은 참과 거짓의 결과가 되도록 수행하는 커버리지
    - **조건/결정** 커버리지(Condition Dicison Coverage)
        - 소스 코드의 **모든 조건문**과 각 조건문에 포함된 **개별 조건식의** 결과가 **True인 경우와 False**인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계함
        - 전체 조건식 뿐만 아니라 개별 조건식도 참 한번, 거짓 한번 결과가 되도록 수행하는 커버리지
        
        ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(24).png)
        
        ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(25).png)
        

- **블랙박스 테스트(Black Box Test), 명세 기반 테스트**
    - 블랙박스 테스트는 소프트웨어가 수행할 특정 기능을 알기 위해서 **각 기능이 완전히 작동**되는 것을 **입증**하는 테스트로, **기능 테스트**라고도 함
    - 사용자의 **요구사항 명세를 보면서** 테스트함
    - 주로 **구현된 기능**을 **테스트**함
    - **소프트웨어 인터페이스**를 통해 실시됨

- 블랙박스 테스트의 종류
    - **동치 분할** 검사(**Equivalence Partitioning Testing**, 동치 클래스 분해)
        - 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 **균등**하게 하여 **테스트 케이스를 정**하고, 해당 **입력 자료에 맞는 결과가 출력**되는지 **확인**하는 기법
        - **입력 자료**에 **초점**을 맞춰 **테스트 케이스**를 만들고 검사하는 방법
        - 동등 분할 기법이라고도 함
            
            ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(26).png)
            
    - **경계값 분석**(**Boundary Value Analysis**)
        - 입력 자료에만 치중한 동치 분할 기법을 보완한 기법
        - 입력 조건의 **중간값보다 경계값에서** **오류가 발생될 확률이 높다**는 점을 이용하여 **입력 조건의 경계값을 테스트 케이스로 선정**하여 검사하는 기법
            
            ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(27).png)
            
            ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(28).png)
            
    - **원인-효과** **그래프** 검사(**Cause-Effect Graphing Testing**)
        - **입력 데이터 간의 관계**와 **출력에 영향**을 미치는 영향을 **분석**한 다음 **효용성이 높은 테스트 케이스를** 선정하여 검사하는 기법
    - **오류 예측** 검사(**Error Guessing**), 데이터 확인 검사
        - **과거의 경험**이나 **확인자의 감각**으로 테스트하는 기법
        - 다른 블랙박스 테스트 기법으로는 찾아낼 수 없는 오류를 찾아내는 일련의 보충적 검사 기법
    - **비교** 검사(**Comparison Testing**)
        - **여러 버전**의 프로그램에 **동일한 테스트 자료**를 제공하여 **동일한 결과가 출력**되는지 테스트하는 기법

---

Q. 인터페이스 구현 시 적용할 데이터베이스 암호화 기법에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> API 방식, TDE 방식
> 
- ( ① ): 애플리케이션 레벨에서 암호 모듈을 적용하는 애플리케이션 수정 방식으로 애플리케이션 서버에 암/복호화, 정책 관리, 키 관리 등의 부하가 발생
- ( ② ): DB 서버의 DBMS 커널이 자체적으로 암, 복호화 기능을 수행하는 방식이며, 내장된 암호화 기능을 사용

- 데이터베이스 암호화 기법은 다음과 같다.
    - API 방식
        - 애플리케이션 레벨에서 암호 모듈(API)을 적용하는 애플리케이션 수정 방식
        - 애플리케이션 서버에 암・복호화, 정책 관리, 키 관리 등의 부하 발생
        
        ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(29).png)
        
    - Plug-in 방식
        - 암・복호화 모듈이 DB 서버에 설치된 방식
        - DB 서버에 암・복호화, 정책 관리, 키 관리 등의 부하 발생
        
        ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(30).png)
        
    - TDE 방식
        - DB 서버의 DBMS 커널이 자체적으로 암・복호화 기능을 수행하는 방식
        - 내장되어 있는 암호화 기능(TDE: Transparent Data Encryption)을 이용
        
        ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(31).png)
        
    - Hybrid 방식
        - API 방식과 Plug-in 방식을 결합하는 방식
        - DB 서버와 애플리케이션 서버로 부하 분산
        
        ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(32).png)
        

---

Q. 다음 중 [직원] 테이블에서 부서별로 그룹을 묶었을 때 부서의 급여합계가 500 이상인 부서, 해당 부서의 급여합계를 조회하는 쿼리를 작성하시오.

```sql
SELECT 부서, SUM(급여) AS 급여합계
FROM 직원
GROUP BY 부서
HAVING SUM(급여) >= 500;
```

```sql
SELECT 부서, SUM(급여) AS 급여합계
FROM 직원
GROUP BY 부서
HAVING 급여합계 >= 500;
```

[직원]

| 이름 | 부서 | 급여 |
| --- | --- | --- |
| 선조 | 영업 | 300 |
| 광해군 | 마케팅 | 400 |
| 연산군 | 전산 | 200 |
| 정조 | 전산 | 500 |
| 고종 | 마케팅 | 100 |

[결과]

| 부서 | 급여합계 |
| --- | --- |
| 마케팅 | 500 |
| 전산 | 700 |

- HAVING절은 GROUP BY에 의해 분류한 후 그룹에 대한 조건 지정한다.
- GROUP BY절의 속성값에 해당하는 값들끼리 그룹을 형성하고, SUM(급여)을 통해서 그룹별 합계를 구할 수 있다.
- GROUP BY절과 SUM(급여)을 통해서 그룹별 합계가 계산된 이후에 HAVING절을 통해 그룹별 급여합계(또는 SUM(급여))가 500 이상인 조건을 사용할 수 있다.

---

Q. 다음은 메모리 반입 기법에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 예상 반입 기법, 요구 반입 기법
> 
- ( ① ): 시스템의 요구를 예측하여 미리 메모리에 적재하는 방법으로 요구되는 페이지 이외의 다른 페이지도 함께 적재
- ( ② ): 다음에 실행될 프로세스가 참조 요구가 있을 경우에 적재하는 기법

- 메모리 반입 기법은 다음과 같다.
    - 예상 반입 기법
        - 시스템의 요구를 예측하여 미리 메모리에 적재하는 기법
        - 요구되는 페이지 이외 다른 페이지도 함께 적재
    - 요구 반입 기법
        - 다음에 실행될 프로세스가 참조 요구가 있을 경우에 적재하는 기법

- 기억장치의 관리 전략
    - 기억장치의 관리 전략은 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것
- 종류
    - **반입(Fetch) 전략**
        - 반입 전략은 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략
            - 요구 반입(Demand Fetch)
                - 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
            - 예상 반입(Anticipatory Fetch)
                - 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법
    - **배치(Placement) 전략**
        - 배치 전략은 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치 시킬것인지를 결정하는 전략
            - 최초 적합 (First Fit)
                - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법
            - 최적 적합 (Best Fit)
                - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화(빈 영역)를 가장 작게 남기는 분할 영역에 배치시키는 방법
            - 최악 적합 (Worst Fit)
                - 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법
                
                ![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(33).png)
                
        - **교체(Replacement) 전략**, 한정된 주기억장치
            - 교체 전략은 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략
            - 종류 : FIFO, OPT, LRU, LFU, NUR, SCR 등

---

Q. 다음은 애플리케이션에 대한 DDos 공격이다. () 안에 들어갈 용어를 쓰시오.

> Slowloris(Slow HTTP Header Dos), RUDY(Slow HTTP POST DoS)
> 
- ( ① )은/는 HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열인 \r\n\r\n(Hex: 0d 0a 0d 0a)을 전송하지 않고, \r\n(Hex: 0d 0a)만 전송하여 대상 웹 서버와 연결 상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격이다.
- ( ② )은/는 요청 헤더의 Content-Length를 비정상적으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결 상태를 유지시키는 공격 기법이다.
- 또한, ( ③ )은/는 TCP 윈도 크기와 데이터 처리율을 감소시킨 상태에서 (Zero Window Packet) 다수 HTTP 패킷을 지속적으로 전송하여 대상 웹 서버의 연결 상태가 장시간 지속, 연결 자원을 소진시키는 서비스 거부 공격이다.

- 애플리케이션에 대한 DDos 공격은 다음과 같다.
    - Slowloris(Slow HTTP Header DoS)
        - HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열인 \r\n\r\n(Hex: 0d 0a 0d 0a)을 전송하지 않고, \r\n(Hex: 0d 0a)만 전송하여 대상 웹 서버와 연결 상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격
    - RUDY(Slow HTTP POST DoS)
        - 요청 헤더의 Content-Length를 비정상적으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결 상태를 유지시키는 공격 기법
    - Slow Read Attack
        - TCP 윈도 크기와 데이터 처리율을 감소시킨 상태에서 (Zero Window Packet) 다수 HTTP 패킷을 지속적으로 전송하여 대상 웹 서버의 연결 상태가 장시간 지속, 연결 자원을 소진시키는 서비스 거부 공격

---

Q. 분산 데이터베이스의 한 형태로 분산 노드의 운영자에 의한 임의조작이 불가능하도록 고안되어 지속적으로 성장하는 데이터 기록 리스트인 블록을 연결한 모음으로 비트 코인의 기반 기술을 무엇이라고 하는가?

> 블록 체인(Block Chain)
> 

- 블록체인은 분산 데이터베이스의 한 형태로 분산 노드의 운영자에 의한 임의조작이 불가능하도록 고안되어 지속적으로 성장하는 데이터 기록 리스트인 블록을 연결한 모음으로 비트 코인의 기반 기술이다.

---

Q. 기계학습은 인공지능(AI; Artificial Intelligence)의 분야 중 하나로, 인간의 학습능력과 같은 기능을 컴퓨터에서 실현하고자 하는 기술이다. 유형 중에서 ( ① )은/는 입력 X에 대해 목푯값을 스스로 추론하여 학습하는 방법으로 입력은 주어지나 대응되는 출력이 없으며, 입력 패턴들의 공통적인 특성을 파악하는 것이 학습의 목적이다. 다른 유형인 ( ② )은/는 입력에 대해 학습자가 행동을 선택하고 그 행동에 대해서 교사가 제공하는 보상치에 따라서 학습하는 방법이다. () 안에 들어갈 용어를 쓰시오.

> 비지도(비교사) 학습, 강화학습
> 

- 기계학습의 유형은 다음과 같다.
    - 지도(교사)학습
        - 입력 X에 대한 출력 목푯값을 제시하여 학습
        - 입출력의 쌍으로 구성된 학습 예제들로부터 입력을 출력으로 사상하는 함수를 학습
        - 사례: 신경망, 회귀분석
    - 비지도(비교사)학습
        - 입력 X에 대해 목표값을 스스로 추론하여 학습
        - 입력은 주어지나 대응되는 출력이 없으며, 입력 패턴들의 공통적인 특성을 파악하는 것이 학습의 목적
        - 사례: k-Means 알고리즘, 주성분 분석
    - 강화학습
        - 입력 X에 대해 행위의 포상을 기억하고 학습
        - 입력에 대해 학습자가 행동을 선택하고, 그 행동에 대해서 교사가 제공하는 보상치에 따라서 학습하는 방법
        - 사례: Q-Learning, 몬테카를로 트리 탐색

---

Q. 다음 순수 관계 대수식을 쿼리로 작성하시오.

```sql
SELECT FNAME, LNAME, SALARY
FROM EMP
WHERE DNO = 1005
```

![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(34).png)

![이미지](/assets/img/exam/06/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_06%ED%9A%8C(35).png)

- π는 속성(컬럼)들을 출력하므로 πFNAME, LNAME,SALARY(A)의 경우 릴레이션 A로부터 FNAME, LNAME, SALARY라는 속성들의 값으로만 구성된 튜플을 가지고 오므로 SELECT FNAME, LNAME, SALARY가 된다.
- σDNO=1005(EMP)의 경우 DNO=1005를 만족하는 튜플을 반환하므로 DNO=1005는 WHERE DNO=1005로 EMP의 경우 릴레이션 R에 해당되므로 FROM EMP가 된다.


<br>
**참고 자료**

---

- <https://www.techopedia.com/kr/definition/database-management-systems-dbms>
- <https://www.google.com/search?q=DBMS&oq=DBMS&gs_lcrp=EgZjaHJvbWUyDAgAEEUYORixAxiABDIHCAEQABiABDIHCAIQABiABDIHCAMQABiABDIHCAQQABiABDIHCAUQABiABDIHCAYQABiABDIHCAcQABiABDIHCAgQABiABDIHCAkQABiABNIBCTE1MTRqMGoxNagCCLACAQ&sourceid=chrome&ie=UTF-8#vhid=_NT7Pr__rHIVZM&vssid=l>