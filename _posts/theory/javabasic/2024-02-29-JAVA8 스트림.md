---
categories: [Theory, JavaBasic]
---

### 스트림 API

---

### 스트림 API

- Java SE 8부터 추가된 스트림 API는 앞서 입력과 출력에서 살펴본 스트림과는 전혀 다른 개념이다.
- 자바에서는 많은 양의 데이터를 저장하기 위해서 배열이나 컬렉션을 사용한다. 이렇게 저장된 데이터에 접근하기 위해서는 반복문이나 반복자(iterator)를 사용하여 매번 새로운 코드를 작성해야 한다.
- 하지만 이렇게 작성된 코드는 길이가 너무 길고 가독성도 떨어지며, 코드의 재사용이 거의 불가능하다. 즉, 데이터베이스의 쿼리와 같이 정형화된 처리 패턴을 가지지 못했기에 데이터마다 다른 방법으로 접근해야만 했다.
- 이러한 문제점을 극복하기 위해서 Java SE 8부터 스트림(stream) API를 도입한다. **<mark>스트림 API</mark>**는 **<mark>데이터를 추상화</mark>**하여 다루므로, 다양한 방식으로 저장된 <mark>데이터를 읽고 쓰기 위한 공통된 방법을 제공</mark>한다.
- 따라서 스트림 API를 이용하면 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방법으로 다룰 수 있게 된다.

---

### 스트림 API의 특징

- 스트림 API는 다음과 같은 특징을 가진다.
    
    1. 스트림은 외부 반복을 통해 작업하는 컬렉션과는 달리 **`내부 반복(internal iteration)`**을 통해 작업을 수행한다.
    
    2. 스트림은 재사용이 가능한 컬렉션과는 달리 **`단 한 번만 사용`**할 수 있다.
    
    3. 스트림은 **`원본 데이터를 변경하지 않는다.`**
    
    4. 스트림의 연산은 **`필터-맵(filter-map) 기반의 API`**를 사용하여 **`지연(lazy) 연산을 통해 성능을 최적화`**한다.
    
    5. 스트림은 **`parallelStream() 메소드`**를 통한 손쉬운 **`병렬 처리를 지원`**한다.
    

---

### 스트림 API의 동작 흐름

- 스트림 API는 다음과 같이 세 가지 단계에 걸쳐서 동작한다.
    
    1. 스트림의 생성
    
    2. 스트림의 중개 연산(스트림의 변환)
    
    3. 스트림의 최종 연산(스트림의 사용)
    
- 다음 그림은 자바 스트림 API가 동작하는 흐름을 나타낸다.

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(1).png)


### 스트림의 생성

---

### 스트림의 생성

- 스트림 API는 다음과 같은 다양한 데이터 소스에서 생성할 수 있다.
    
    1. 컬렉션
    
    2. 배열
    
    3. 가변 매개변수
    
    4. 지정된 범위의 연속된 정수
    
    5. 특정 타입의 난수들
    
    6. 람다 표현식
    
    7. 파일
    
    8. 빈 스트림
    

---

### 컬렉션

- 자바에서 제공하는 모든 컬렉션의 최고 상위 조상인 **`Collection 인터페이스에는 stream() 메소드가 정의`**되어 있다. 따라서 Collection 인터페이스를 구현한 모든 **`List와 Set 컬렉션 클래스`**에서도 **`stream() 메소드로 스트림을 생성`**할 수 있다.
- 또한, **`parallelStream() 메소드`**를 사용하면 병렬 처리가 가능한 스트림을 생성할 수 있다.

```java
import java.util.*;
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		ArrayList<Integer> list = new ArrayList<Integer>();
		
		list.add(4);
		list.add(2);
		list.add(3);
		list.add(1);
		
		// 컬렉션에서 스트림 생성
		Stream<Integer> stream = list.stream();
		// forEach() 메소드를 이용한 스트림 요소의 순차 접근
		stream.forEach(System.out::println);		
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(2).png)


- Stream 클래스의 **`forEach() 메소드`**는 해당 스트림의 요소를 **`하나씩 소모`**해가며 **`순차적으로 요소에 접근`**하는 메소드이다. 따라서 같은 스트림으로는 **`forEach() 메소드를 한 번밖에 호출할 수 없다`**.
- 단, 원본 데이터의 요소를 소모하는 것은 아니므로, 같은 데이터에서 **`또 다른 스트림을 생성`**하여 forEach() 메소드를 호출하는 것은 가능하다.

---

### 배열

- 배열에 관한 스트림을 생성하기 위해 **`Arrays 클래스`**에는 다양한 형태의 **`stream() 메소드가 클래스 메소드로 정의`**되어 있다.
- 또한, **`기본 타입인 int, long, double 형을 저장`**할 수 있는 **`배열에 관한 스트림이 별도로 정의`**되어 있다. 이러한 스트림은 **`java.util.stream 패키지`**의 **`IntStream, LongStream, DoubleStream 인터페이스`**로 각각 제공된다.

```java
import java.util.*;
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		String[] arr = new String[]{"넷", "둘", "셋", "하나"};
		
		// 배열에서 스트림 생성
		Stream<String> stream1 = Arrays.stream(arr);
		stream1.forEach(e -> System.out.print(e + " "));
		System.out.println();
		
		// 배열의 특정 부분만을 이용한 스트림 생성
		Stream<String> stream2 = Arrays.stream(arr, 1, 3);
		stream2.forEach(e -> System.out.print(e + " "));
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(3).png)


- Arrays 클래스의 **`stream() 메소드`**는 **`전체 배열뿐만 아니라 배열의 특정 부분만을 이용하여 스트림을 생성`**할 수도 있다.

---

### 가변 매개변수

- Stream 클래스의 **`of() 메소드`**를 사용하면 **`가변 매개변수(variable parameter)를 전달`**받아 스트림을 생성할 수 있다.

```java
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		// 가변 매개변수에서 스트림 생성
		Stream<Double> stream = Stream.of(4.2, 2.5, 3.1, 1.9);
		stream.forEach(System.out::println);
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(4).png)


---

### 지정된 범위의 연속된 정수

- 지정된 범위의 **`연속된 정수를 스트림으로 생성`**하기 위해 **`IntStream나 LongStream 인터페이스에는 range()와 rangeClosed() 메소드가 정의`**되어 있다.
- **`range() 메소드`**는 명시된 시작 정수를 포함하지만, 명시된 마지막 정수는 포함하지 않는 스트림을 생성한다.
- **`rangeClosed() 메소드`**는 명시된 시작 정수뿐만 아니라 명시된 마지막 정수까지도 포함하는 스트림을 생성한다.

```java
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		// 지정된 범위의 연속된 정수에서 스트림 생성
		IntStream stream1 = IntStream.range(1, 4);
		stream1.forEach(e -> System.out.print(e + " "));
		System.out.println();
		
		IntStream stream2 = IntStream.rangeClosed(1, 4);
		stream2.forEach(e -> System.out.print(e + " "));
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(5).png)

---

### 특정 타입의 난수들

- 특정 타입의 난수로 이루어진 스트림을 생성하기 위해 **`Random 클래스에는 ints(), longs(), doubles()`**와 같은 메소드가 정의되어 있다. 이 메소드들은 매개변수로 **`스트림의 크기를 long 타입으로 전달`**받을 수 있다.
- 이 메소드들은 만약 매개변수를 전달받지 않으면 크기가 정해지지 않은 **`무한 스트림(infinite stream)을 반환`**한다. 이때에는 **`limit() 메소드`**를 사용하여 따로 스트림의 크기를 제한해야 한다.

```java
import java.util.Random;
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		// 특정 타입의 난수로 이루어진 스트림 생성
		IntStream stream = new Random().ints(4);
		stream.forEach(System.out::println);
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(6).png)

---

### 람다 표현식

- 람다 표현식을 매개변수로 전달받아 해당 람다 표현식에 의해 반환되는 값을 요소로 하는 무한 스트림을 생성하기 위해 **`Stream 클래스에는 iterate()와 generate() 메소드가 정의`**되어 있다.
- **`iterate() 메소드`**는 시드(seed)로 명시된 값을 람다 표현식에 사용하여 반환된 값을 다시 시드로 사용하는 방식으로 무한 스트림을 생성한다.
- 반면에 **`generate() 메소드`**는 매개변수가 없는 람다 표현식을 사용하여 반환된 값으로 무한 스트림을 생성한다.

```java
// iterate() 메소드를 이용하여 홀수만으로 이루어진 무한 스트림을 생성하는 예제
IntStream stream = Stream.iterate(2, n -> n + 2); // 2, 4, 6, 8, 10, ...
```

---

### 파일

- 파일의 한 행(line)을 요소로 하는 스트림을 생성하기 위해 **`java.io.file.Files 클래스에는 lines() 메소드가 정의`**되어 있다.
- 또한, **`java.io.BufferedReader 클래스의 lines() 메소드`**를 사용하면 파일뿐만 아니라 **`다른 입력으로부터도 데이터를 행(line) 단위로 읽어 올 수 있다`**.

```java
String<String> stream = Files.lines(Path path);
```

---

### 빈 스트림

- 아무 요소도 가지지 않는 **`빈 스트림은 Stream 클래스의 empty() 메소드를 사용하여 생성`**할 수 있다.

```java
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		// 빈 스트림 생성
		Stream<Object> stream = Stream.empty();
		System.out.println(stream.count());	// 스트림의 요소의 총 개수를 출력함
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(7).png)


<br>
### 스트림의 중개 연산 

---

### 스트림의 중개 연산(intermediate operation)

- 스트림 API에 의해 생성된 초기 스트림은 중개 연산을 통해 **<mark>또 다른 스트림으로 변환</mark>**된다. 이러한 중개 연산은 스트림을 전달받아 스트림을 반환하므로, 중개 연산은 연속으로 연결해서 사용할 수 있다.
- 또한, 스트림의 중개 연산은 필터-맵(filter-map) 기반의 API를 사용함으로 **<mark>지연(lazy) 연산</mark>**을 통해 성능을 최적화할 수 있다.
- 스트림 API에서 사용할 수 있는 대표적인 중개 연산과 그에 따른 메소드는 다음과 같다.
    
    1. 스트림 필터링 : filter(), distinct()
    
    2. 스트림 변환 : map(), flatMap()
    
    3. 스트림 제한 : limit(), skip()
    
    4. 스트림 정렬 : sorted()
    
    5. 스트림 연산 결과 확인 : peek()
    

---

### 스트림 필터링

- **`filter() 메소드`**는 해당 스트림에서 주어진 조건(**`predicate`**)에 **`맞는 요소만으로 구성된 새로운 스트림`**을 반환한다.
- 또한, **`distinct() 메소드`**는 해당 스트림에서 중복된 요소가 제거된 새로운 스트림을 반환한다. distinct() 메소드는 **`내부적으로 Object 클래스의 equals() 메소드를 사용`**하여 요소의 **`중복을 비교`**한다.

```java
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		IntStream stream1 = IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6);
		IntStream stream2 = IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6);
		
		// 스트림에서 중복된 요소를 제거함
		stream1.distinct().forEach(e -> System.out.print(e + " "));
		System.out.println();
		
		// 스트림에서 홀수만을 골라냄
		stream2.filter(n -> n % 2 != 0).forEach(e -> System.out.print(e + " "));
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(8).png)


---

### 스트림 변환

- **`map() 메소드`**는 **`해당 스트림의 요소들을 주어진 함수에 인수로 전달`**하여, 그 **`반환값들로 이루어진 새로운 스트림을 반환`**한다.
- 만약 해당 스트림의 요소가 배열이라면, **`flatMap() 메소드`**를 사용하여 각 배열의 각 요소의 반환값을 **`하나로 합친 새로운 스트림`**을 얻을 수 있다.

```java
// 문자열로 이루어진 스트림을 map() 메소드를 이용하여 각 문자열의 길이로 이루어진 스트림으로 변환하는 예제
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		Stream<String> stream = Stream.of("HTML", "CSS", "JAVA", "JAVASCRIPT");
		
		stream.map(s -> s.length()).forEach(System.out::println);
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(9).png)


```java
// 여러 문자열이 저장된 배열을 각 문자열에 포함된 단어로 이루어진 스트림으로 변환하는 예제
import java.util.Arrays;
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		String[] arr = {"I study hard", "You study JAVA", "I am hungry"};
		
		Stream<String> stream = Arrays.stream(arr);
		stream.flatMap(s -> Stream.of(s.split(" +"))).forEach(System.out::println);
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(10).png)


---

### 스트림 제한

- **`limit() 메소드`**는 해당 스트림의 첫 번째 요소부터 **`전달된 개수만큼`**의 요소만으로 이루어진 새로운 스트림을 반환한다.
- **`skip() 메소드`**는 해당 스트림의 첫 번째 요소부터 **`전달된 개수만큼의 요소`**를 **`제외한 나머지 요소`**만으로 이루어진 새로운 스트림을 반환한다.

```java
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		IntStream stream1 = IntStream.range(0, 10);
		IntStream stream2 = IntStream.range(0, 10);
		IntStream stream3 = IntStream.range(0, 10);
		
		stream1.skip(4).forEach(n -> System.out.print(n + " "));
		System.out.println();
		
		stream2.limit(5).forEach(n -> System.out.print(n + " "));
		System.out.println();
		
		stream3.skip(3).limit(5).forEach(n -> System.out.print(n + " "));
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(11).png)


---

### 스트림 정렬

- **`sorted() 메소드`**는 해당 스트림을 주어진 비교자(**`comparator`**)를 이용하여 정렬한다. 이때 비교자를 전달하지 않으면 **`기본적으로 사전 편찬 순(natural order)`**으로 정렬하게 된다.

```java
import java.util.Comparator;
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		Stream<String> stream1 = Stream.of("JAVA", "HTML", "JAVASCRIPT", "CSS");
		Stream<String> stream2 = Stream.of("JAVA", "HTML", "JAVASCRIPT", "CSS");
		
		stream1.sorted().forEach(s -> System.out.print(s + " "));
		System.out.println();
		
		stream2.sorted(Comparator.reverseOrder()).forEach(s -> System.out.print(s + " "));
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(12).png)


---

### 스트림 연산 결과 확인

- **`peek() 메소드`**는 **`결과 스트림으로`**부터 **`요소를 소모`**하여 추가로 명시된 동작을 수행한다.
- 이 메소드는 **`원본 스트림에서 요소를 소모하지 않으므로`**, 주로 연산과 연산 사이에 **`결과를 확인`**하고 싶을 때 사용한다. 따라서 개발자가 디버깅 용도로 많이 사용한다.

```java
import java.util.stream.*;

public class prog {
	public static void main(String[] args){
		IntStream stream = IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6);
		
		stream.peek(s -> System.out.println("원본 스트림 : " + s))
			.skip(2)
			.peek(s -> System.out.println("skip(2) 실행 후 : " + s))
			.limit(5)
			.peek(s -> System.out.println("limit(5) 실행 후 : " + s))
			.sorted()
			.peek(s -> System.out.println("sorted() 실행 후 : " + s))
			.forEach(n -> System.out.println(n));
	}
}
```

![이미지](/assets/img/java_basic/JAVA8_%EC%8A%A4%ED%8A%B8%EB%A6%BC(13).png)


1. **`IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6)`**를 통해 IntStream을 생성한다.
2. **`peek`** 메서드를 사용하여 각 요소를 확인하고, "원본 스트림 : "과 함께 해당 요소를 출력한다.
3. **`skip(2)`** 메서드를 사용하여 처음 2개의 요소를 스킵한다.
4. **`peek`** 메서드를 사용하여 스킵된 요소를 확인하고, "skip(2) 실행 후 : "과 함께 해당 요소를 출력한다.
5. **`limit(5)`** 메서드를 사용하여 다음 5개의 요소를 제한한다.
6. **`peek`** 메서드를 사용하여 제한된 요소를 확인하고, "limit(5) 실행 후 : "과 함께 해당 요소를 출력한다.
7. **`sorted`** 메서드를 사용하여 요소를 정렬한다.
8. **`peek`** 메서드를 사용하여 정렬된 요소를 확인하고, "sorted() 실행 후 : "과 함께 해당 요소를 출력한다.
9. **`forEach`** 메서드를 사용하여 각 요소를 반복하면서 해당 요소를 출력한다.

- 위의 예제에서 첫 번째 요소인 7과 두 번째 요소인 5는 skip() 메소드에 의해 삭제되므로, 원본 스트림에서만 나타난다. 하지만 세 번째 요소인 5는 skip() 메소드와 limit() 메소드가 실행된 후에도 존재하므로, 모두 나타난다.
- 이렇게 peek() 메소드는 스트림의 각 요소가 해당 중개 연산 후에 어떻게 변화하는지를 보여준다.

---

### 대표적인 중개 연산 메소드

- 스트림 API에서 사용할 수 있는 대표적인 중개 연산을 위한 메소드는 다음과 같다.

| 메소드 | 설명 |
| --- | --- |
| Stream<T> filter(Predicate<? super T> predicate) | 해당 스트림에서 주어진 조건(predicate)에 맞는 요소만으로 구성된 새로운 스트림을 반환한다. |
| <R> Stream<R> map(Functoin<? super T, ? extends R> mapper) | 해당 스트림의 요소들을 주어진 함수에 인수로 전달하여, 그 반환값으로 이루어진 새로운 스트림을 반환한다. |
| <R> Stream<R> flatMap(Functoin<? super T, ? extends Stream<? extends R>> mapper) | 해당 스트림의 요소가 배열일 경우, 배열의 각 요소를 주어진 함수에 인수로 전달하여, 그 반환값으로 이루어진 새로운 스트림을 반환한다. |
| Stream<T> distinct() | 해당 스트림에서 중복된 요소가 제거된 새로운 스트림을 반환한다. 내부적으로 Object 클래스의 equals() 메소드를 사용한다. |
| Stream<T> limit(long maxSize) | 해당 스트림에서 전달된 개수만큼의 요소만으로 이루어진 새로운 스트림을 반환한다. |
| Stream<T> peek(Consumer<? super T> action) | 결과 스트림으로부터 각 요소를 소모하여 추가로 명시된 동작(action)을 수행하여 새로운 스트림을 생성하여 반환한다. |
| Stream<T> skip(long n) | 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소를 제외한 나머지 요소만으로 이루어진 새로운 스트림을 반환한다. |
| Stream<T> sorted() | 비교자를 전달하지 않으면 영문사전 순(natural order)으로 정렬한다. |
| Stream<T> sorted(Comparator<? super T> comparator) | 해당 스트림을 주어진 비교자(comparator)를 이용하여 정렬한다. |


<br>

