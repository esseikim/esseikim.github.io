---
title: "[Interview] Network"
categories: [Study, Interview]
---

## **OSI 7계층**

---

- OSI 7계층은 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약이다.
1. **물리 계층 (Physical Layer)**
      - 전송에 필요한 하드웨어적 기능을 제공
      - 예: 통신 케이블, 허브, 리피터
2. **데이터링크 계층 (Data Link Layer)**
      - 물리 계층에서 발생할 수 있는 오류를 검출하고 수정
      - 데이터의 프레이밍, MAC 주소 기반의 통신, 오류 검출 및 수정, 송수신 확인
      - 예: 브릿지, 스위치
3. **네트워크 계층 (Network Layer)**
      - 패킷을 네트워크 간에 전송하고 경로를 결정
      - IP 주소를 이용하여 데이터 전달
      - 예: 라우터
4. **전송 계층 (Transport Layer)**
      - 두 호스트 시스템 간의 데이터 전송을 관리
      - 데이터의 신뢰성과 흐름 제어를 제공
      - 예: TCP, UDP
5. **세션 계층 (Session Layer)**
      - 통신 시스템 사용자 간의 연결을 설정, 유지 및 종료
      - 세션 복구와 동기화를 관리
      - 예: API 호출, 소켓 통신
6. **표현 계층 (Presentation Layer)**
      - 데이터의 형식 변환, 암호화, 압축을 담당
      - 세션 계층 간의 주고받는 인터페이스를 일관성 있게 표현
      - 예: 암호화, 압축, 인코딩
7. **응용 계층 (Application Layer)**
      - 사용자가 네트워크에 접근할 수 있도록 서비스를 제공
      - 네트워크 애플리케이션과 직접 상호작용
      - 예: 웹 브라우저, 이메일 클라이언트, FTP 클라이언트
    

## **TCP/IP 프로토콜 스택 4계층**

---

1. **링크 계층 (Link Layer)**
    - 물리적 네트워크 연결 및 데이터 전송을 담당
    - 네트워크 인터페이스 카드(NIC)와 드라이버는 물리적 전송 매체와의 상호작용을 관리
    - 네트워크 인터페이스 카드(NIC), 드라이버, 이더넷 표준을 포함
    - 예: 이더넷, Wi-Fi
2. **인터넷 계층 (Internet Layer)**
    - 데이터그램의 경로 결정과 전달을 담당
    - IP 주소를 이용한 데이터 전송
    - 경로 선택과 데이터 전송 중 오류 발생 가능
    - 예: IP, ICMP, ARP
3. **전송 계층 (Transport Layer)**
    - 애플리케이션 간의 데이터 전송을 담당
    - TCP는 신뢰성 있는 데이터 전송을, UDP는 빠른 데이터 전송을 제공
    - 예: TCP, UDP
    - TCP: 연결 지향적, 신뢰성 있는 데이터 전송 (순서 보장, 오류 검출 및 수정)
        - TCP는 IP 프로토콜 위에서 작동하며, 데이터의 순서 보장, 오류 검출 및 수정, 재전송 등의 기능을 통해 신뢰성을 제공
    - UDP: 비연결 지향적, 빠른 데이터 전송 (오류 검출 없음, 순서 보장 없음)
4. **애플리케이션 계층 (Application Layer)**
    - 응용 프로그램 간의 데이터 송수신 규약을 정의
    - 다양한 네트워크 서비스와 애플리케이션 프로토콜을 포함
    - 예: HTTP, FTP, SMTP, DNS

## **이더넷**

---

- 이더넷(Ethernet)은 가장 널리 사용되는 유선 로컬 영역 네트워크(LAN) 기술입이다. 이더넷 표준은 IEEE(Institute of Electrical and Electronics Engineers)에서 정의하며, 주요 표준은 IEEE 802.3이다. 이 표준은 물리적 매체, 데이터 링크 계층의 프로토콜, 그리고 프레임 형식을 정의한다.
    - **프레임 형식**: 이더넷 프레임은 데이터, 송신자 및 수신자의 MAC 주소, 그리고 오류 검출을 위한 FCS(Field Check Sequence)를 포함.
    - **CSMA/CD**: 이더넷의 초기 버전은 충돌 탐지 방식(CSMA/CD, Carrier Sense Multiple Access with Collision Detection)을 사용하여 네트워크상의 충돌을 관리.
    - **유연성**: 다양한 케이블 매체와 속도 지원.
    - **확장성**: 스위치와 라우터를 이용해 작은 네트워크부터 큰 네트워크까지 확장 가능.

## 소켓(Socket)

---

- 네트워크를 경유하는 프로세스 간 통신의 접속점으로 클라이언트와 서버 프로그램 사이에 데이터를 송수신할 수 있는 기술
- 소켓은 IP address와 Port 넘버가 합쳐진, 네트워크상에서 서버 프로그램과 클라이언트 프로그램이 통신할 수 있도록 해주는 교환 기술이다.
- 서버와 클라이언트 간 소켓 연결 방식은 다음과 같다.
   
   ![이미지](/assets/img/study/interview/network/(1).png) 
    
    - 서버 소켓과 클라이언트 소켓을 만듦(socket())
    - 서버 소켓은 로컬 IP를 가지고 포트를 열고(bind()), 클라이언트는 연결을 기다림(listen())
    - 클라이언트 소켓은 IP 주소를 이용해 목적지 호스트를 찾아내고 포트를 이용해 통신 접속점을 찾아내서 연결을 만듦(connect())
    - 서버 소켓이 연결을 수락하면(accept()), 포트를 이용해 데이터를 주고받음(send(), recv())

## **TCP란?**

---

- TCP(Transmission Control Protocol)는 서버와 클라이언트 간의 신뢰성 있는 데이터 전송을 제공하는 연결 지향 프로토콜이다. TCP 연결을 설정하고 데이터를 주고받는 과정에서 함수 호출 순서가 중요하다.

### **서버와 클라이언트의 함수 호출 순서**

---

- **서버 측**
    1. **socket()**: 서버 소켓 생성.
    2. **bind()**: 소켓에 로컬 IP와 포트 할당.
    3. **listen()**: 연결 요청을 대기 상태로 만듦.
    4. **accept()**: 연결을 수락. 연결이 이루어질 때까지 블로킹 상태.
    5. **send()/recv()**: 데이터 송수신.
    6. **close()**: 연결 종료.
- **클라이언트 측**
    1. **socket()**: 클라이언트 소켓 생성.
    2. **connect()**: 서버로 연결 요청.
    3. **send()/recv()**: 데이터 송수신.
    4. **close()**: 연결 종료.

### **차이점**

---

- 서버와 클라이언트 소켓을 생성한 후, 연결을 설정하는 과정에서 차이가 있다. 서버는 **listen()** 호출 이후 연결 요청 대기 큐를 만들어 놓고, 클라이언트가 연결 요청을 할 때까지 기다린다. 서버가 **accept()**를 호출하여 연결이 이루어질 때까지 호출된 위치에서 블로킹 상태가 된다.
- 이처럼 연결 지향적인 TCP는 신뢰성 있는 데이터 전송이 가능하며, 흐름 제어와 혼잡 제어를 지원해서 데이터 순서를 보장해준다.

### **TCP의 특징**

---

- TCP는 신뢰성 있는 데이터 전송을 제공하기 위해 다음과 같은 기능을 지원한다.
    - **연결 지향적**: 연결 설정, 데이터 전송, 연결 해제를 포함한 3-Way Handshake 과정을 통해 신뢰성 있는 데이터 전송을 보장.
    - **흐름 제어**: 송신 측과 수신 측의 데이터 처리 속도 차이를 조절해 데이터가 손실되지 않도록 함.
    - **혼잡 제어**: 네트워크 내의 패킷 수가 넘치지 않도록 조절해 네트워크 혼잡을 방지.
- TCP는 정확성과 신뢰성을 보장하기 때문에 속도가 다소 느린 단점이 있으며, 주로 웹 HTTP 통신, 이메일, 파일 전송 등에 사용된다.

### **TCP 연결 및 종료 과정**

---

- TCP 소켓은 연결 설정 과정 중에 총 3번의 대화를 주고받는다. 이 과정을 통해 연결이 확립되며, 이를 3-Way Handshake라고 부른다.
- 여기서 SYN은 연결 요청 플래그를 의미하고, ACK는 응답을 의미한다.
- **연결 설정 (3-Way Handshake)**
    1. **클라이언트 → 서버 (SYN)**:
        - 클라이언트는 서버에 접속 요청하는 **`SYN`** 플래그가 설정된 패킷을 보낸다. 이 패킷에는 시퀀스 번호 **`M`**이 포함되어 있다.
    2. **서버 → 클라이언트 (SYN-ACK)**:
        - 서버는 클라이언트로부터 받은 **`SYN(M)`** 패킷을 확인하고, 요청을 수락한다는 응답으로 **`ACK(M+1)`**과 **`SYN(N)`** 플래그가 설정된 패킷을 클라이언트에게 보낸다. 여기서 **`ACK(M+1)`**은 클라이언트의 시퀀스 번호 **`M`**에 대한 응답이며, **`SYN(N)`**은 서버의 시퀀스 번호 **`N`**이다.
    3. **클라이언트 → 서버 (ACK)**:
        - 클라이언트는 서버로부터 받은 **`SYN(N)`**과 **`ACK(M+1)`** 패킷을 확인하고, **`ACK(N+1)`** 플래그가 설정된 패킷을 서버로 보낸다. 이 패킷을 보내면 연결이 성립된다.
- **연결 종료 (4-Way Handshake)**
    1. **클라이언트 → 서버 (FIN)**:
        - 클라이언트는 연결을 종료하겠다는 **`FIN`** 플래그가 설정된 패킷을 서버로 보낸다.
    2. **서버 → 클라이언트 (ACK)**:
        - 서버는 클라이언트로부터 받은 **`FIN`** 패킷을 확인하고, 요청을 수락한다는 응답으로 **`ACK`** 플래그가 설정된 패킷을 클라이언트에게 보낸다. 이 후 서버는 데이터를 모두 보낼 때까지 대기 상태(**`TIME_WAIT`**)로 들어간다.
    3. **서버 → 클라이언트 (FIN)**:
        - 서버는 데이터를 모두 전송한 후 연결을 종료하겠다는 **`FIN`** 플래그가 설정된 패킷을 클라이언트에게 보낸다.
    4. **클라이언트 → 서버 (ACK)**:
        - 클라이언트는 서버로부터 받은 **`FIN`** 패킷을 확인하고, **`ACK`** 플래그가 설정된 패킷을 서버로 보낸다.
    5. **서버**:
        - 클라이언트의 **`ACK`** 패킷을 받은 서버는 소켓 연결을 종료(**`close`**)한다.
    6. **클라이언트**:
        - 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다 (**`TIME_WAIT`**).
        - 이 과정에서 **`TIME_WAIT`**는 클라이언트가 서버로부터 모든 데이터를 수신했는지 확인하기 위해 일정 시간 동안 기다리는 단계이다. 이 시간을 기다린 후 클라이언트는 소켓 연결을 완전히 종료한다.

### 요약

---

- TCP는 데이터의 순서를 보장하고, 손실된 패킷을 재전송하며, 패킷이 중복되었거나 손상된 경우 이를 검출하고 수정하는 기능을 갖추고 있어 신뢰성 있는 데이터 전송을 보장한다.
    
    1. 3-Way Handshake
    
        - SYN: 클라이언트가 서버에 연결 요청을 보낸다.
        - SYN-ACK: 서버가 연결 요청을 수락하고 응답을 보낸다.
        - ACK: 클라이언트가 서버의 응답을 확인하고 연결을 확립한다.
    
    2. 데이터 전송: 연결이 확립된 후 클라이언트와 서버는 데이터를 주고받는다.
    
    3. 연결 해제: 데이터 전송이 완료되면 양측에서 연결 해제 신호를 보내 연결을 종료한다.
    

- 서버 : socket() 생성 → bind() 소켓 주소할당 → listen() 연결요청 대기상태 → accept() 연결허용 → read/write() 데이터 송수신 → close() 연결종료
- 클라이언트 : socket() 생성 → connect() 연결요청 → read/write() 데이터 송수신 → close() 연결종료

## **UDP란?**

---

- UDP (User Datagram Protocol)는 TCP의 대안으로, 비신뢰성 전송 프로토콜이다. UDP는 IP와 함께 사용되며, IP 위에서 동작하는 전송 계층 프로토콜이다. 이 때문에 UDP/IP(사용자 데이터그램 프로토콜)라고도 불린다.

### **주요 특징**

---

1. **비연결지향 프로토콜**:
    - UDP는 TCP와 달리 연결을 설정하지 않는다. 데이터 전송 전에 송신자와 수신자 간의 연결 설정이 필요 없기 때문에 연결 설정 및 해제에 소요되는 시간이 없다.
2. **패킷 기반 전송**:
    - UDP는 데이터를 패킷 단위로 전송한다. 각 패킷은 독립적으로 전송되며, 패킷이 손실되거나 순서가 바뀌어도 이를 복구하는 기능이 없다. 패킷은 도착 여부나 순서에 관계없이 전송된다.
3. **단순 헤더 구조**:
    - UDP 헤더는 간단하며, 필수적인 정보만 포함한다. 헤더에는 출발지 포트, 목적지 포트, 패킷 길이, 체크섬이 포함된다. 간단한 구조 덕분에 오버헤드가 적다.
4. **빠른 전송 속도**:
    - UDP는 TCP보다 전송 속도가 빠르다. 연결 설정, 확인 응답, 흐름 제어 등의 과정이 없기 때문에 데이터를 빠르게 전송할 수 있다. 이로 인해 실시간 스트리밍, 온라인 게임, VoIP(Voice over IP, 음성 인터넷 프로토콜) 등 실시간 전송이 필요한 애플리케이션에 주로 사용된다.
5. **비신뢰성 전송**:
    - UDP는 신뢰성을 보장하지 않는다. 패킷이 손실되거나 중복되거나 순서가 바뀌어도 이를 처리하지 않는다. 따라서 신뢰성 있는 전송이 필요하지 않은 애플리케이션에 적합하다.

### **동작 원리**

---

1. **메시지 전송**:
    - UDP(User Datagram Protocol, 데이터를 데이터 그램 단위로 처리하는 프로토콜)는 메시지를 패킷(데이터 전송 단위)으로 나눈다. 각 패킷은 독립적으로 전송되며, IP를 통해 목적지까지 전달된다.
    - 패킷은 여러 네트워크를 거쳐 목적지에 도달할 수 있으며, 도착하지 않을 가능성도 존재한다.
    - UDP 패킷을 데이터그램(독립적인 관계를 지니는 패킷)이라고 한다. 패킷을 대상 컴퓨터로 직접 보내는 간단한 방식으로 이 프로세스를 수행한다.
2. **포트 사용**:
    - 송신자는 데이터를 전송할 때 목적지 IP와 포트를 지정한다. 수신자는 지정된 포트를 열어 패킷을 대기한다. 패킷이 도착하면 수신자는 이를 받아들인다.
3. **출발지 정보**:
    - 수신된 패킷에는 출발지 IP와 포트 정보가 포함되어 있다. 이를 통해 수신자는 패킷의 출발지를 알 수 있다.

![이미지](/assets/img/study/interview/network/(2).png)

### **활용 분야**

---

- 비디오 재생 또는 DNS 조회와 같이 시간에 민감한 전송을 위해 인터넷을 통해 사용된다.
- 데이터를 아주 빠르게 전송할 수 있지만, 전송 중에 [패킷](https://www.cloudflare.com/learning/network-layer/what-is-a-packet/)이 손실되어 [DDoS 공격](https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/)의 형태로 악용될 수 있다.
1. **실시간 스트리밍**:
      - UDP는 빠른 전송이 필요하고, 약간의 데이터 손실을 허용할 수 있는 실시간 스트리밍에 사용된다.
2. **온라인 게임**:
      - 게임에서는 빠른 응답 속도가 중요하다. 약간의 데이터 손실이 게임 진행에 큰 영향을 미치지 않기 때문에 UDP가 사용된다.
3. **VoIP**:
      - 음성 통화에서는 실시간 전송이 중요하다. 데이터 유실이 약간 발생해도 통화 품질에 큰 영향을 미치지 않으므로 UDP가 적합하다.
- UDP는 간단하고 빠른 전송을 제공하지만, 신뢰성이 낮다는 단점이 있다. 이 때문에 애플리케이션의 요구사항에 따라 적절한 프로토콜을 선택하는 것이 중요하다.

![이미지](/assets/img/study/interview/network/(3).png)

![이미지](/assets/img/study/interview/network/(4).png)

## **HTTP와 HTTPS의 차이**

---

- HTTP (HyperText Transfer Protocol)와 HTTPS (HyperText Transfer Protocol Secure)는 웹에서 데이터를 전송하는 데 사용되는 프로토콜이다.
- 이 두 프로토콜의 주요 차이는 보안과 관련된 것이다.
    - **HTTP 동작 순서**: TCP → HTTP
    - **HTTPS 동작 순서**: TCP → SSL/TLS → HTTP

![이미지](/assets/img/study/interview/network/(5).png)

### **HTTP (HyperText Transfer Protocol)**

---

- **비보안 프로토콜**: HTTP는 데이터를 암호화하지 않고 평문으로 전송한다. 이로 인해 데이터가 전송 중에 가로채이거나 변조될 위험이 있다.
- **빠른 속도**: 암호화 과정이 없기 때문에 HTTPS에 비해 상대적으로 빠른 전송 속도를 제공한다.
- **일반적인 사용 사례**: HTTP는 보안이 중요하지 않은 웹 페이지(예: 공지사항, 정보성 페이지 등)에 주로 사용된다.

### **HTTPS (HyperText Transfer Protocol Secure)**

---

- **보안 프로토콜**: HTTPS는 SSL(Secure Socket Layer) 또는 최신의 TLS(Transport Layer Security) 프로토콜을 사용하여 데이터를 암호화한다. 이로 인해 데이터 전송 중에 가로채이거나 변조될 가능성이 현저히 줄어든다.
- **암호화 과정**: HTTPS는 공개키 암호화 방식을 사용한다. 클라이언트와 서버는 공개키와 개인키를 사용하여 데이터를 암호화하고 복호화한다. 이로 인해 데이터를 안전하게 주고받을 수 있다.
- **인증서 사용**: HTTPS는 SSL/TLS 인증서를 사용하여 서버의 신원을 확인한다. 이를 통해 사용자는 접속한 웹사이트가 신뢰할 수 있는 사이트임을 확인할 수 있다.
- **속도 저하**: 암호화 및 복호화 과정이 추가되기 때문에, HTTP에 비해 상대적으로 속도가 느리다. 하지만 최근의 하드웨어 성능 향상으로 인해 이 속도 차이는 대부분의 경우 사용자가 느낄 수 없을 정도로 줄어들었다.
- **사용 사례**: HTTPS는 보안이 중요한 웹 페이지(예: 로그인 페이지, 결제 페이지, 개인 정보 입력 페이지 등)에 주로 사용된다.

### **HTTPS의 동작 원리**

---

1. **클라이언트 요청**:
    - 클라이언트가 HTTPS 웹사이트에 접속하려고 하면, 먼저 TCP 연결을 설정한다.
2. **SSL/TLS 핸드셰이크**:
    - 클라이언트와 서버는 SSL/TLS 핸드셰이크를 수행한다. 이 과정에서 서버는 SSL/TLS 인증서를 클라이언트에게 제공한다. 클라이언트는 이 인증서를 검증하여 서버의 신원을 확인한다.
3. **세션 키 생성**:
    - 클라이언트와 서버는 대칭키 암호화를 위한 세션 키를 생성하고 교환한다. 이 세션 키를 사용하여 데이터를 암호화하고 복호화한다.
4. **암호화된 데이터 전송**:
    - SSL/TLS 연결이 설정된 후, 클라이언트와 서버는 암호화된 채널을 통해 데이터를 주고받는다.
    

### **왜 모든 사이트가 HTTPS를 사용하지 않는가?**

---

1. **속도 저하**:
    - 암호화 및 복호화 과정으로 인해 추가적인 CPU 자원이 필요하다. 이는 특히 저사양의 서버나 클라이언트에서 성능 저하를 유발할 수 있다. 그러나 현대의 서버와 네트워크 장비는 성능이 매우 향상되어, 일반적인 사용 환경에서는 큰 문제가 되지 않는다.
2. **비용**:
    - SSL/TLS 인증서를 발급받기 위해 비용이 발생할 수 있다. Let’s Encrypt와 같은 무료 인증서 제공 기관이 있지만, 여전히 일부 고급 기능이나 엔터프라이즈 솔루션에서는 비용이 들 수 있다.
3. **복잡성**:
    - SSL/TLS 인증서를 관리하고 설정하는 과정이 다소 복잡할 수 있다. 특히, 인증서 갱신이나 문제 발생 시 이를 처리하는 과정이 필요하다.
    

**결론**

---

HTTP는 보안이 필요 없는 경우에 사용되며, HTTPS는 보안이 중요한 경우에 사용된다. 오늘날 많은 웹사이트는 보안 강화를 위해 HTTPS를 채택하고 있으며, 브라우저들도 HTTPS 사용을 적극 권장하고 있다. Google과 같은 검색 엔진은 HTTPS를 사용하는 웹사이트에 대해 SEO(Search Engine Optimization) 우선 순위를 높게 주는 정책을 채택하고 있다.

**요약**

---

- **HTTP**: 비보안, 빠른 속도, 공지사항/정보성 페이지에 주로 사용.
- **HTTPS**: 보안, 상대적으로 느린 속도, 로그인/결제/개인 정보 입력 페이지에 주로 사용.
- **동작 원리**: HTTPS는 SSL/TLS를 통해 데이터를 암호화하고 서버의 신원을 인증.
- **모든 사이트가 HTTPS를 사용하지 않는 이유**: 속도 저하, 비용, 설정의 복잡성.

## **GET과 POST의 차이**

---

- GET과 POST는 HTTP 프로토콜을 이용해 서버에 요청을 보낼 때 사용하는 두 가지 방식이다. 두 방식 모두 특정한 작업을 수행하기 위해 서버에 요청을 보내지만, 그 방식과 용도에서 차이가 있다.

### **GET 방식**

---

- **URL을 통해 파라미터 전달**: GET 요청은 모든 파라미터를 URL 쿼리 문자열로 전달한다. 예를 들어, **`http://example.com/page?name=John&age=30`**와 같이 URL에 파라미터가 포함된다.
- **주소창에 전달 값 노출**: 파라미터가 URL에 포함되기 때문에 웹 브라우저의 주소창에 전달 값이 노출된다.
- **데이터 양 제한**: URL의 길이에 제한이 있어 전송할 수 있는 데이터 양이 한정적이다. 보통 2048자 이하로 제한된다.
- **인코딩 필요**: 파라미터 값이 특정 문자 (예: 공백, &, = 등)를 포함할 경우 URL 인코딩이 필요하다.
- **캐싱 가능**: GET 요청은 주로 데이터 조회에 사용되며, 브라우저나 중간 캐시 서버에 의해 캐싱될 수 있다.
- **용도**: 주로 서버에서 데이터를 가져와서 보여주는 용도로 사용된다. 예를 들어, 검색 쿼리나 페이지 네비게이션에 사용된다.

### **POST 방식**

---

- **HTTP BODY에 데이터 포함**: POST 요청은 데이터를 HTTP 요청의 본문(Body)에 포함해서 전달한다. 파라미터가 URL에 노출되지 않는다.
- **눈에 보이지 않는 파라미터**: 웹 브라우저 사용자의 눈에는 파라미터가 직접적으로 노출되지 않는다. 이는 보안적인 측면에서 더 안전하게 보일 수 있다.
- **데이터 양 제한 없음**: POST 요청은 전송 데이터 양에 제한이 거의 없다. 매우 큰 데이터도 전송할 수 있다.
- **다양한 데이터 형식 지원**: POST 요청은 텍스트, 바이너리 데이터, 파일 업로드 등 다양한 데이터 형식을 지원한다.
- **캐싱 안됨**: 기본적으로 POST 요청은 캐싱되지 않는다. 이는 주로 데이터를 변경하거나 서버에 새로운 데이터를 생성할 때 사용되기 때문이다.
- **용도**: 서버의 데이터나 상태를 변경하는 작업에 주로 사용됩니다. 예를 들어, 폼 제출, 파일 업로드, 데이터베이스 업데이트 등에 사용된다.

### **요약**

---

- **GET**: URL을 통해 파라미터를 전달하고, 데이터 조회 및 검색에 사용된다. 데이터 양이 제한되며 캐싱이 가능하다.
- **POST**: HTTP 요청 본문에 데이터를 포함하고, 데이터 전송 및 서버 상태 변경 작업에 사용된다. 데이터 양에 제한이 없고 캐싱되지 않는다.

## **IOCP (I/O Completion Ports)**

---

- IOCP는 비동기 입출력 작업의 효율성을 높이기 위해 설계된 고성능 I/O 모델로, 주로 Windows 운영체제에서 사용된다. IOCP는 특히 네트워크 서버 애플리케이션에서 많은 동시 접속을 처리해야 할 때 유용하다.

### **주요 특징과 개념**

---

1. **비동기 I/O 작업**
    - IOCP는 비동기 I/O 작업을 지원하여, I/O 작업이 완료될 때까지 기다리지 않고도 다른 작업을 수행할 수 있다. 이는 시스템 자원의 효율적인 활용을 가능하게 한다.
2. **큐와 스레드 풀링**
    - IOCP는 큐와 스레드 풀을 사용하여 I/O 요청을 효율적으로 관리한다. I/O 작업이 완료되면 해당 작업은 IOCP 큐에 추가되고, 대기 중인 스레드가 이를 처리한다.
    - 스레드 풀링을 통해 시스템 자원을 절약하며, 과도한 스레드 생성으로 인한 오버헤드를 방지한다.
3. **동기화 객체**
    - IOCP는 동기화 객체인 세마포어의 특성을 활용한다. 이는 여러 스레드가 안전하게 작업을 처리할 수 있도록 도와준다.
4. **블록킹 없는 작업 처리**
    - IOCP는 비동기적으로 I/O 작업을 수행함으로써, 블로킹 없이 작업을 처리할 수 있다. 이는 응용 프로그램의 대기 시간을 줄이고, 시스템의 전체적인 처리 성능을 향상시킨다.
    

### **IOCP의 동작 원리**

---

1. **I/O 요청 제출**
    - 애플리케이션은 비동기 I/O 작업을 IOCP에 제출한다. 이때, 해당 작업은 바로 완료되지 않고 대기 상태에 들어간다.
2. **I/O 작업 완료**
    - I/O 작업이 완료되면, 운영체제는 해당 작업의 완료 상태를 IOCP 큐에 추가한다.
3. **작업 처리**
    - IOCP에 등록된 스레드는 큐에서 작업을 가져와 처리한다. 이 과정에서 스레드 풀을 사용하여 필요한 스레드를 효율적으로 할당한다.
4. **결과 반환**
    - 작업을 처리한 후, 스레드는 작업의 결과를 애플리케이션에 반환하고, 다음 작업을 처리하기 위해 다시 큐를 확인한다.
    

### **장점**

---

- **높은 성능**: 비동기 I/O와 스레드 풀링을 통해 많은 수의 동시 접속을 효율적으로 처리할 수 있다.
- **자원 효율성**: 스레드 풀을 통해 시스템 자원을 절약하고, 스레드 생성과 소멸로 인한 오버헤드를 줄인다.
- **응답성**: 블로킹 없이 I/O 작업을 처리하여 애플리케이션의 응답성을 높인다.

### **단점**

---

- **복잡성**: IOCP 모델을 구현하고 관리하는 것은 상대적으로 복잡할 수 있다. 개발자는 스레드 동기화와 큐 관리에 대한 깊은 이해가 필요하다.
- **플랫폼 종속성**: 주로 Windows 운영체제에서 사용되기 때문에, 다른 플랫폼에서는 동일한 성능을 기대하기 어렵다.

### **요약**

---

- IOCP는 비동기 I/O 작업을 효율적으로 처리하기 위해 설계된 고성능 I/O 모델이다.
- 큐와 스레드 풀링을 통해 시스템 자원을 효율적으로 사용하며, 블로킹 없이 작업을 처리함으로써 응용 프로그램의 대기 시간을 줄이고 전체적인 성능을 향상시킨다. 이를 통해 많은 수의 동시 접속을 효과적으로 처리할 수 있는 모델이다.
- 동기화 Object 세마포어의 특성과 큐를 가진 커널 Object이다. 동기화와 동시에 큐를 통한 데이터 전달 IOCP는, 스레드 풀링을 위한 것이라고 할 수 있다.

## **POOLING이란?**

---

- Pooling은 시스템 자원을 효율적으로 관리하고 성능을 최적화하기 위해 여러 개의 자원을 미리 할당해 놓고 필요할 때마다 재사용하는 기법이다.
- 이는 자원을 반복적으로 생성하고 소멸시키는 오버헤드를 줄이는 데 도움이 된다. 가장 흔히 사용되는 예로는 스레드 풀링(Thread Pooling)과 커넥션 풀링(Connection Pooling)이 있다.

## **IPC (Inter Process Communication)란?**

---

- 공유메모리, 소켓, 세마포어, 메세지 큐 등 프로세스 간 통신하는 기술이다.
- IPC 기법에는 메시지 큐, 공유메모리, 소켓, 세마포어가 있다.
    
    
    | 기법 | 설명 |
    | --- | --- |
    | 메시지 큐 | 메시지(또는 패킷) 단위로 동작하여 프로세스 간 통신함 |
    | 공유 메모리 | 한 프로세스의 일부분을 다른 프로세스와 공유 |
    | 소켓 | 클라이언트와 서버 프로세스 둘 사이에 통신을 가능하게 함 |
    | 세마포어 | 프로세스 사이의 동기를 맞추는 기능을 제공함 |

## **라우터와 스위치의 차이**

---

### **라우터 (Router)**

1. **계층**: 네트워크 계층 (Layer 3)
    - 라우터는 OSI 7계층 모델에서 네트워크 계층에 해당하는 장비이다.
2. **기능**:
    - **패킷 전송 경로 설정**: 라우터는 수신한 패킷의 IP 주소 정보를 분석하여 최적의 경로를 설정하고 패킷을 목적지로 전송한다.
    - **네트워크 연결**: 라우터는 서로 다른 네트워크 간의 데이터를 전송하는 역할을 하며, LAN(Local Area Network)과 WAN(Wide Area Network)을 연결할 수 있다.
    - **라우팅 프로토콜 사용**: 라우터는 다양한 라우팅 프로토콜(예: OSPF, BGP, RIP)을 사용하여 네트워크 경로를 결정하고, 경로 정보를 다른 라우터와 공유한다.
3. **주요 특징**:
    - IP 주소를 기반으로 경로 설정
    - 네트워크 분할 및 트래픽 관리
    - 보안 기능(방화벽 기능 포함)
    

### **스위치 (Switch)**

---

1. **계층**: 데이터 링크 계층 (Layer 2)
    - 스위치는 OSI 7계층 모델에서 데이터 링크 계층에 해당하는 장비이다.
2. **기능**:
    - **프레임 전송**: 스위치는 수신한 프레임의 MAC 주소를 분석하여 해당 프레임을 적절한 포트로 전송한다.
    - **내부 네트워크 연결**: 스위치는 주로 동일한 네트워크 내의 장치들을 연결하며, 네트워크 내에서 데이터 전송을 효율적으로 관리한다.
    - **MAC 주소 테이블**: 스위치는 연결된 장치들의 MAC 주소를 저장하는 MAC 주소 테이블을 유지하며, 이를 기반으로 프레임을 적절한 포트로 전송한다.
3. **주요 특징**:
    - MAC 주소 기반 데이터 전송
    - 낮은 지연 시간과 높은 데이터 전송 속도
    - VLAN(Virtual Local Area Network) 기능을 통해 네트워크 분할 가능
    

### **요약**

---

- **라우터**: 네트워크 계층(Layer 3) 장비로, 수신한 패킷의 IP 주소 정보를 기반으로 최적의 경로를 설정하여 패킷을 전송한다. 주로 네트워크 간의 연결을 관리하고, 라우팅 프로`토콜을 사용하여 경로 정보를 공유한다.
- **스위치**: 데이터 링크 계층(Layer 2) 장비로, 수신한 프레임의 MAC 주소 정보를 기반으로 해당 프레임을 적절한 포트로 전송한다. 주로 내부 네트워크의 장치들을 연결하고, MAC 주소 테이블을 유지하여 데이터 전송을 효율적으로 관리한다.


<br>
**참고 자료**

---

- [https://www.cloudflare.com/ko-kr/learning/ddos/glossary/user-datagram-protocol-udp/ - TCP & UDP](https://www.cloudflare.com/ko-kr/learning/ddos/glossary/user-datagram-protocol-udp/)
- [https://dkwjdi.tistory.com/136 - 데이터그램](https://dkwjdi.tistory.com/136)
- [https://www.ibm.com/docs/ko/aix/7.1?topic=management-transmission-control-protocolinternet-protocol - TCP/IP 여러 호스트 사이의 통신 허용](https://www.ibm.com/docs/ko/aix/7.1?topic=management-transmission-control-protocolinternet-protocol)
- [https://hudi.blog/https/ - HTTP, HTTPS](https://hudi.blog/https/)