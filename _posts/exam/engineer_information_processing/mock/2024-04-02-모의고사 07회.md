---
categories: [Certificate, "[정보처리기사] 모의고사(01~35회)"]
---

Q. 다음 () 안에 공통적으로 들어갈 용어를 쓰시오.

> 오픈스택(OpenStack)
> 
- ()은/는 아파치 라이선스 형태로 배포되고 있는 오픈 소스 소프트웨어 기반의 클라우드 플랫폼 프로젝트이다.
- ()은/는 IaaS 형태를 가지며 주로 리눅스 기반으로 운용과 개발이 이루어지며, 사용자가 데이터 센터의 자원들을 손쉽게 제어할 수 있도록 웹을 통해 다양한 기능을 제공한다.

- 오픈스택(OpenStack)은 아파치 라이선스 형태로 배포되고 있는 오픈 소스 소프트웨어 기반의 클라우드 플랫폼 프로젝트이다.
- 오픈스택은 프로세싱, 저장 공간, 네트워킹의 가용자원을 제어하는 목적의 여러 개의 하위 프로젝트로 이루어져 있다.

---

Q. 소프트웨어 아키텍처 4+1뷰에서 ( ① )은/는 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰로 설계자 및 개발자 관점이라고 할 수 있고, ( ② )은/는 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰로 개발자, 시스템 통합자 관점이라고 할 수 있다. 또한( ③ )은/는 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰로 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보를 정의한다. () 안에 들어갈 뷰의 유형을 쓰시오.

> 논리 뷰(Logical View), 프로세스 뷰(Process View), 구현 뷰(Implementation View)
> 

- 소프트웨어 아키텍처 4+1 뷰는 다음과 같다.
    
    ![이미지](/assets/img/exam/07/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_07%ED%9A%8C(1).png)
    
    - **유스케이스 뷰(Usecase View)**
        - 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰
        - 사용자, 설계자, 개발자, 테스트 관점
    - **논리 뷰(Logical View)**
        - **시스템의 기능적인 요구사항**이 어떻게 제공되는지 설명해주는 뷰
        - 설계자, 개발자 관점
    - **프로세스 뷰(Process View)**
        - 시스템의 **비기능적인 속성**으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
        - 개발자, 시스템 통합자 관점
    - **구현 뷰(Implementation View)**
        - 개발 환경 안에서 정적인 소프트웨어 **모듈의 구성**을 보여주는 뷰
        - **컴포넌트 구조와 의존성**을 보여주고 컴포넌트에 관한 부가적인 정보 정의
    - **배포 뷰(Deployment View)**
        - 컴포넌트가 **물리적인 아키텍처에 어떻게 배치되는가**를 매핑해서 보여주는 뷰

- 유스케이스(Use Case)
    - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능을 표현한 것
    - 사용자의 요구사항을 기능 단위로 표현하는 것

---

Q. 보안 암호화 관련 용어에 대한 설명이다. () 안에 들어갈 올바른 용어를 쓰시오.

> 해시 함수(Hash Function)
> 

()은/는 임의의 길이를 갖는 값을 입력받으면 고정된 길이의 값을 출력하는 함수로, 직접 접근할 수 있는 짧은 길이의 값이나 키가 존재하여 해당 주소에 빠른 접근이 가능하며, 메시지의 오류나 변조를 탐지하는 데 활용된다.

- 보안 관련 용어 중 해시 함수와 SET의 개념은 다음과 같다.
    - 해시 함수(Hash Function)
        - 임의의 길이를 갖는 값을 입력받으면 고정된 길이의 값을 출력하는 함수
        - 직접 접근할 수 있는 짧은 길이의 값이나 키가 존재하여 해당 주소에 빠른 접근이 가능하며, 메시지의 오류나 변조를 탐지하는 데 사용
    - SET(Secure Electronic Transaction)
        - 온라인상의 안전한 거래를 위해 Visa와 Master Card에서 개발한 프로토콜
        - 개인 계좌 정보나 신용 정보 등이 네트워크를 통해 노출되거나 위∙변조되는 것을 막으며, 메시지 암호화 방법과 2중 전자서명 등에 활용되어 기밀성과 무결성을 보장

---

Q. 다음 프로그램에 대하여 100% 문장 커버리지를 만족하는 테스트 케이스를 구하시오. 

> TC1, TC3
> 

![이미지](/assets/img/exam/07/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_07%ED%9A%8C(2).png)

- 구문 커버리지(=문장 커버리지(Statement Coverage))는 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지 테스트이다.
- 구문 커버리지는 조건문 결과와 관계없이 구문 실행 개수로 계산한다.
- 문장 커버리지(%)=테스트 케이스 집합에 의해 실행된 문장의 수/(전체 실행 가능한 프로그램 문장의 수)x100
- TC1: X=5, Y=2, Z=15 → ① 구문 실행(X는 T, Y는 T : T실행) → ② 구문 실행(Z=15/5=3) → ③ 구문 실행(X는 2가 아니라서 F, Z는 3이니깐 1보다 커서 T : T 실행) → ④ 구문 실행(Z=3+5=8) → 종료 → 2개의 전체 구문 실행함
- TC3: X=4, Y=2, Z=8 → ① 구문 실행(X는 T, Y는 T: 실행) → ② 구문 실행(Z=8/4=2) → 구문 실행(X는 2가 아니라서 F, Z는 2이니까 1보다 커서 T : T 실행) → ④ 구문 실행(Z=2+5=7) → 종료 → 2개의 전체 구문을 실행함

---

Q. 다음은 [학생] 테이블이다. 이름이 ‘유’로 시작하는 학번만 출력하는 쿼리를 작성하시오. 그리고 학번을 출력할 때 학년을 기준으로 내림차순이 되어야 한다.

```sql
SELECT 학번 
FROM 학생
WHERE 이름 LIKE '유%'
ORDER BY 학년 DESC;
```

[학생]

| 학번 | 이름 | 학년 |
| --- | --- | --- |
| 202101 | 윤봉길 | 1 |
| 202102 | 안중근 | 3 |
| 202103 | 이순신 | 2 |
| 202104 | 홍범도 | 3 |
| 202105 | 김좌진 | 4 |
| 202106 | 유관순 | 3 |
| 202107 | 이봉창 | 2 |

- WHERE절 조건에서는 비교, 범위, 집합, 패턴, NULL, 복합조건이 있고, 패턴을 찾기 위해서는 LIKE 구문을 사용한다.
- LIKE 문법은 다음과 같다.
    
    ```sql
    컬럼 LIKE 패턴
    ```
    
- 패턴을 사용하기 위한 와일드카드는 다음과 같다.
    
    
    | 와일드카드 | 설명 |
    | --- | --- |
    | % | 0개 이상의 문자열과 일치 |
    | [] | 1개의 문자와 일치 |
    | [^] | 1개의 문자와 불일치 |
    | _ | 특정 위치의 1개의 문자와 일치 |

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

```python
a=[1, 2, 3]
b=[4, 5, 6]
c=[a[i]+b[i] for i in range(len(a))]
sum(c) 
```

- 리스트 a에는 [1, 2, 3], b에는 [4, 5, 6]을 대입한다.
- 리스트 내포(List comprehension)를 이용하여 a와 b의 각각의 값을 더해서 c에 리스트 결과를 대입한다.
- c를 모두 더한 값(5+7+9)을 화면에 출력한다. sum 함수는 배열 내의 모든 원소의 합을 계산한다.

| a | b | c |
| --- | --- | --- |
| a[0]=1 | b[0]=4 | c[0]=5 |
| a[1]=2 | b[1]=5 | c[1]=7 |
| a[2]=3 | b[2]=6 | c[2]=9 |

- **리스트 명 = [표현식 for 변수 in 반복 가능한 대상 if 조건문]**
- **range(A)**
    
    0부터 A-1까지의 정수 범위를 반환
    
- **range(A, B)**
    
    A부터 B-1까지의 정수 범위를 반환
    
- **range(A, B, C)**
    
    A부터 C 숫자만큼의 간격으로 B-1 까지의 정수 범위를 반환
    

---

Q. IP 계층에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용하여 보안 서비스를 제공하는 터널링 프로토콜은 무엇인가?

> IPSec(IP Security)
> 

- 데이터 암호화 전송을 위한 주요 기술은 다음과 같다.
    
    
    | 기술 | 설명 |
    | --- | --- |
    | IPSec | IP 계층에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용하여 양 종단 간(End Point) 구간에 보안 서비스를 제공하는 터널링 프로토콜 |
    | SSL/TLS | 전송 계층과 응용 계층 사이 사이 클라이언트와 서버 간의 웹 데이터 암호화, 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜 |
    | S-HTTP | 웹상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나로서 클라이언트와 서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송하는 프로토콜 |

---

Q. 데이터베이스의 고립화 수준(Isolation Level)을 서술하시오.

> 데이터베이스의 고립화 수준은 다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 정도이다.
> 

- 고립화 수준의 종류는 다음과 같다.
    - Read Uncommitted
        - 한 트랜잭션에서 연산 중인(아직 커밋되지 않은) 데이터를 다른 트랜잭션이 읽는 것을 허용하고 연산(갱신) 중인 데이터에 대한 연산은 불허
        - 각 트랜잭션에서의 변경 내용이 `COMMIT`이나 `ROLLBACK` 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.
        - 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장한다. `Commit`되지 않는 상태지만 `Update`된 값을 다른 트랜잭션에서 읽을 수 있다.(DIRTY READ 현상 발생)
    - Read Committed
        - 한 트랜잭션이 연산을 수행할 때, 연산이 완료될 때까지 데이터에 대한 읽기를 제한하고 연산이 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용
        - RDB에서 대부분 기본적으로 사용되고 있는 격리 수준이다. Dirty Read와 같은 현상은 발생하지 않는다.
        - 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
            - `트랜잭션-1`이 Commit한 이후 아직 끝나지 않는 `트랜잭션-2`가 다시 테이블 값을 읽으면 값이 변경됨을 알 수 있다.
            - 하나의 트랜잭션내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 `REPEATABLE READ`의 정합성에 어긋난다.
            - 이러한 문제는 주로 입금, 출금 처리가 진행되는 금전적인 처리에서 주로 발생한다. 데이터의 정합성은 깨지고, 버그는 찾기 어려워 진다.
    - Repeatable Read
        - 선행 트랜잭션이 특정 데이터를 읽을 때, 트랜잭션 종료 시까지 해당 데이터에 대한 갱신/삭제를 제한
        - MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
        - Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
            - 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제한다.
            - Undo에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.
            - 이러한 변경 방식은 MVCC(Multi Version Concurrency Control)라고 부른다.
        - PHANTOM READ
            - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상
            - 이를 방지하기 위해서는 쓰기 잠금을 걸어야 한다.
    - Serializable Read
        - 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근을 제한
        - 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
        - 성능 측면에서는 동시 처리성능이 가장 낮다.
        - `SERIALIZABLE`에서는 `PHANTOM READ`가 발생하지 않는다.

- 다중버전 동시성 제어(MVCC; Multi Version Concurrency Control)
    - 트랜잭션의 타임 스탬프와 접근하려는 데이터의 타임 스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법
    - MVCC를 통해 트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있다.

---

Q. 다음은 C언어 코드이다. 값을 10개 입력받아 가장 작은 값을 출력하려고 한다. 밑줄 친 곳에 적합한 답을 쓰시오.

> num[i]
> 

```c
#include <stdio.h>
void main() {
	int num[10];
	int min = 9999;
	int i;
	for(i=0; i<10; i++) {
		scanf("%d", &num[i]);
	}	
	for(i=0; i<10; i++) {
		if(min >    ) {
			min = num[i];
		}
	}
	printf("%d", min);
}
```

- 크기가 10인 정수형 배열 변수 num을 선언한다.
- 정수형 변수 min 값은 선언과 동시에 9999로 초기화한다.
- for 반복문에서 사용할 정수형 변수 i를 선언한다.
- for 반복문에서는 0부터 10보다 작을 때까지 1씩 i 값을 증가시키며 반복을 수행한다.
- **scanf 함수에서는 사용자의 입력을 키보드로부터 받은 후 num 배열에 저장한다.**
- 아래 for 반복문에서는 i는 0부터 10보다 작을 때까지 i 값을 1씩 증가시킨다. if 문에서 min 값과 num[i] 값을 비교하여 min 값이 더 크면 num[i] 값을 min 변수에 대입한다.
- for 반복문이 종료되고 가장 작은 수가 저장된 min 값을 화면에 출력한다.
- scanf에서 “1 2 3 4 5 6 7 8 9 10”을 입력하면 아래와 같은 동작을 수행한다.
    
    
    | i | num[i] | min |
    | --- | --- | --- |
    |  |  | 9999 |
    | 0 | 1 | 1 |
    | 1 | 2 | 1 |
    | 2 | 3 | 1 |
    | 3 | 4 | 1 |
    | 4 | 5 | 1 |
    | 5 | 6 | 1 |
    | 6 | 7 | 1 |
    | 7 | 8 | 1 |
    | 8 | 9 | 1 |
    | 9 | 10 | 1 |

---

Q. 다음은 [자격증]과 [응시료] 테이블이다. [자격증]과 [응시료] 테이블을 조인하여 [결과] 테이블처럼 나오도록 쿼리를 작성하시오.

```sql
SELECT A.자격증번호 AS 자격증번호, A.자격증명 AS 자격증명, B.응시료 AS 응시료
FROM 자격증 A
[INNER] JOIN 응시료 B
ON A.자격증번호 = B.자격증번호;
```

[자격증]

| 자격증번호 | 자격증명 |
| --- | --- |
| 1 | 정보처리기사 |
| 2 | 빅데이터분석기사 |
| 11 | 컴퓨터시스템응용기술사 |
| 12 | 정보관리기술사 |

[응시료]

| 자격증번호 | 응시료 |
| --- | --- |
| 1 | 20000 |
| 3 | 19000 |
| 12 | 60000 |
| 13 | 62000 |

[결과]

| 자격증번호 | 자격증명 | 응시료 |
| --- | --- | --- |
| 1 | 정보처리기사 | 20000 |
| 12 | 정보관리기술사 | 60000 |

- **공통 존재 컬럼의 값**이 **같은 경우를 추출**하는 조인을 내부 조인이라고 한다.
- 내부 조인 문법은 다음과 같다.
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2
    FROM 테이블1 A 
    [INNER] JOIN 테이블2 B
    ON 조인조건
    [WHERE 검색조건]; 
    ```
    
- SELECT에 AS를 쓰면 컬럼명이 AS 뒤의 명칭으로 변경된다.

---

Q. 암호 알고리즘에서 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘으로 유형에는 블록 암호화 알고리즘과 스트림 암호화 알고리즘이 있는 암호 방식은?

> 대칭 키 암호 방식
> 
- 대칭 키 암호 방식은 암호화 알고리즘의 한 종류로, 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘이다.
- 대칭 키 암호 방식은 블록 암호화와 스트림 암호화 알고리즘으로 나뉜다.

![이미지](/assets/img/exam/07/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_07%ED%9A%8C(3).png)

- 대칭 키 암호 방식은 다음과 같다.
    - 블록 암호 방식
        - 긴 평문을 암호화하기 위해 **고정 길이의 블록을 암호화**하는 블록 암호 알고리즘을 **반복**하는 방법
        - 예: DES, AES, SEED
    - 스트림 암호 방식
        - 매우 긴 주기의 **난수 열을 발생시켜 평문과 더불어 암호문을 생성**하는 방식
        - 예: RC4

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 86
> 

```java
public class Soojebi {
	public static int getValue(int[] n) {
		int sum=0;
		for(int i : n) {
			sum +=i;
		}
		return sum/n.length;
	}
	public static void main(String[] args) {
		int[] num = {90, 80, 90};
		System.out.print(getValue(num));
	}
}
```

- 정수형 배열 num에 90, 80, 90으로 초기화한다.
- getValue(num)을 호출한다.
- getValue 메서드에서 정수형 변수 sum을 0으로 초기화한다.
- for 반복문에서 배열의 원소의 모든 값을 합하여 sum 변수에 대입한다.
    
    
    | sum | i | n |
    | --- | --- | --- |
    | 0 |  |  |
    | 90 | 90 | 90 |
    | 170 | 80 | 80 |
    | 260 | 90 | 90 |

- for(int i : n)에서 배열의 개수만큼 반복하게 되고, i는 n의 요소가 차례대로 들어간다.
- 첫 번째 반복에서 i 값은 n[0] 값인 90, 두 번째 반복에서 i 값은 n[1] 값인 80, 세 번째 반복에서 i 값은 n[2] 값인 90이 된다.
- sum인 260을 n.length로 나눈 결과는 86.67이지만, 정수형과 정수형의 연산은 정숫값이므로 소수점을 버린 86을 리턴하고, 리턴 값인 86을 화면에 출력한다.

---

Q. 다음은 [행성]에 대한 테이블이다. 특성별로 무게 평균을 계산하는 쿼리를 작성하시오.

```sql
SELECT 특성, AVG(무게) AS 무게평균
FROM 행성
GROUP BY 특성;
```

[행성]

| 행성명 | 특성 | 거리 | 무게 |
| --- | --- | --- | --- |
| 수성 | 지구형 | 0.39 | 0.0553 |
| 금성 | 지구형 | 0.72 | 0.815 |
| 지구 | 지구형 | 1 | 1 |
| 화성 | 지구형 | 1.52 | 0.107 |
| 목성 | 목성형 | 5.20 | 317.83 |
| 토성 | 목성형 | 9.54 | 95.16 |
| 천왕성 | 목성형 | 19.23 | 14.5 |
| 해왕성 | 목성형 | 30.06 | 17.135 |

[결과]

| 특성 | 무게평균 |
| --- | --- |
| 지구형 | 0.494325 |
| 목성형 | 111.15625 |

- 특성에 대해서 그룹을 구성해야 하므로 GROUP BY절에는 ‘특성’이라는 컬럼이 들어가야 한다.
- 집계 함수의 종류는 다음과 같다.
    
    
    | 집계 함수 | 내용 |
    | --- | --- |
    | COUNT | 복수 행의 줄 수 |
    | SUM | 복수 행의 해당 컬럼 간의 합계 |
    | AVG | 복수 행의 해당 컬럼 간의 평균 |
    | MAX | 복수 행의 해당 컬럼 중 최댓값 |
    | MIN | 복수 행의 해당 컬럼 중 최솟값 |
    | STDDEV | 복수 행의 해당 컬럼 간의 표준편차 |
    | VARIANCE | 복수 행의 해당 컬럼 간의 분산 |

---

Q. 다음 () 안에 들어갈 단어를 쓰시오.

> 무결성 또는 데이터 무결성
> 
()은/는 부적절한 자료가 입력됨으로 인해 동일한 내용에 대하여 서로 다른 데이터가 저장되는 것을 허용하지 않는 성질이다. 

- DBMS 특징으로는 다음과 같다.
    
    
    | 특징 | 설명 |
    | --- | --- |
    | 데이터 무결성 | 부적절한 자료가 입력되어 동일한 내용에 대하여 서로 다른 데이터가 저장되는 것을 허용하지 않는 성질 |
    | 데이터 일관성 | 삽입, 삭제, 갱신, 생성 후에도 저장된 데이터가 변함없이 일정 |
    | 데이터 회복성 | 장애가 발생하였을 시 특정 상태로 복구되어야 하는 성질 |
    | 데이터 보안성 | 불법적인 노출, 변경, 손실로부터 보호되어야 하는 성질 |
    | 데이터 효율성 | 응답시간, 저장 공간 활용 등이 최적화되어 사용자, 소프트웨어, 시스템 등의 요구 조건을 만족시켜야 하는 성질 |

---

Q. 다음은 UML 다이어그램에 관한 설명이다. () 안에 들어갈 다이어그램을 쓰시오.

> 배치(Deployment) 다이어그램, 패키지(Package) 다이어그램
> 
- UML 다이어그램은 구조적(정적) 다이어그램, 행위적(동적) 다이어그램으로 구분된다.
- 구조적(정적) 다이어그램 중 ( ① )은/는 컴포넌트 사이의 종속성을 표현하며, 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현하는 다이어그램이고, ( ② )은/는 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한 다이어그램이다.

- UML 다이어그램은 구분에 따라 구조적(정적) 다이어그램은 아래와 같다.
    - 클래스(Class)
        - 클래스 다이어그램은 객체지향 모델링 시 **클래스의 속성 및 연산**과 클래스 간 정적인 관계를 표현한 다이어그램
        - 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램으로 시스템 구성 요소를 문서화하는 데 사용
    - 객체(Object)
        - 객체 다이어그램은 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 **객체와 객체 사이의 관계**로 표현한 다이어그램
        - 연관된 모든 인스턴스를 표현
        - **럼바우(Rambaugh)** 객체지향 분석 기법에서 **객체 모델링**에 이용
    - 컴포넌트(Component)
        - 컴포넌트 다이어그램은 시스템을 구성하는 **물리적인 컴포넌트**와 그들 사이의 **의존 관계**를 나타내는 다이어그램
        - 구현 단계에서 사용
    - 배치(Deployment)
        - 배치 다이어그램은 컴포넌트 사이의 종속성을 표현하고, 결과물, 프로세스, 컴포넌트 등 **물리적 요소들의 위치**를 표현하는 다이어그램
        - 구현 단계에서 사용
    - 복합체 구조(Composite Structure)
        - 복합체 구조 다이어그램은 클래스나 컴포넌트가 **복합 구조**를 갖는 경우 **그 내부 구조를 표현**하는 다이어그램
    - 패키지(Package)
        - 패키지 다이어그램은 **유스케이스나 클래스 등의 모델 요소**들을 **그룹화한 패키지들의 관계**(점선)를 표현한 다이어그램
        - 폴더 모양의 패키지와 점선으로 표시된 의존관계
        - <<import>>라는 스테레오 타입 표기를 통해 패키지 다이어그램 파악

- UML(Unified Modeling Laguage)다이어그램
    - UML 다이어그램은 통합 모델링 언어를 사용하여 시스템 상호작용, 업무흐름, 시스템 구조, 컴포넌트 관계 등을 그린 도면
    - 프로그래밍을 단순화 시켜 표현하여 의사소통하기 좋고, 대규모 프로젝트 구조의 로드맵을 만들거나 개발을 위한 시스템 구축에 기본을 마련

- 스테레오 타입(Stereotype)
    - 스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것이다.
    - 길러멧(Guilemet)이라고 부르는 겹화살괄호(« ») 사이에 표현할 형태를 기술한다.
- 주로 표현되는 형태(의미 중요)
    - «include» : 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우
    - «extend» : 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우
    - «interface» : 인터페이스를 정의하는 경우
    - «exception» : 예외를 정의하는 경우
    - «constructor» : 생성자 역할을 수행하는 경우

---

Q. TCP ( ① ) 기법은 전송 계층에서 데이터 패킷을 전송할 때 수신 한도를 넘는 과잉 패킷의 입력으로 패킷 분실이 일어나지 않도록 패킷의 흐름을 조절하는 기법이다. TCP ( ① ) 기법의 유형 중에서 ( ② ) 기법은 프레임이 손실되었을 때, 손실된 프레임 1개를 전송하고 수신자의 응답을 기다리는 방식으로 한 번에 프레임 1개만 전송할 수 있다. () 안에 들어갈 올바른 용어를 쓰시오. 

> 흐름 제어(Flow Control), 정지-대기(Stop & Wait)
> 

- TCP 흐름 제어 기법과 정지-대기 기법은 아래와 같다.
    - 흐름 제어(Flow Control)
        - 전송 계층에서 데이터 패킷을 전송할 때 수신 한도를 넘는 과잉 패킷의 입력으로 패킷 분실이 일어나지 않도록 패킷의 흐름을 조절하는 기법
    - 정지-대기(Stop-Wait)
        - 프레임이 손실되었을 때, 손실된 프레임 1개를 전송하고 수신자의 응답을 기다리는 방식
        - 한 번에 프레임 1개만 전송할 수 있음

- 트래픽 제어는 네트워크의 보호, 성능 유지, 네트워크 자원의 효율적인 이용을 위해 전송되는 패킷의 흐름 또는 그 양을 조절하는 기능으로 흐름 제어, 폭주(혼합) 제어(티켓), 교착상태 방지 기법(한정된 자원, 무한정 대기상태 방지)이 있음(교통경찰)
- 흐름 제어(Flow Control)
    - 네트워크 내의 원활한 흐름을 위해 **송•수신 측 사이**에 전송되는 **패킷의 양이나 속도를 규제**하는 기능
        - 정지-대기(Stop-and-Wait)
            - 수신 측의 확인 신호(ACK, 긍정 응답)를 받은 후에 다음 패킷을 전송하는 방식
            - 한 번에 하나의 패킷만을 전송할 수 있음
            
            ![이미지](/assets/img/exam/07/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_07%ED%9A%8C(4).png)
            
        - 슬라이딩 윈도우(Sliding Window), 가변적
            - 확인 신호(ACK), 즉 수신 통지를 이용하여 송신 데이터의 양을 조절하는 방식, 미리 패킷을 몇개씩 주고 받자고 약속
            - 수신 측의 확인 신호를 받지 않더라도 미리 정해진 패킷의 수 만큼 연속적으로 전송하는 방식으로, 한 번에 여러 개의 패킷을 전송할 수 있어 전송 효율이 좋음
            - 송신 측은 수신 측으로부터 확인 신호(ACK) 없이도 보낼 수 있는 패킷의 최대치를 미리 약속받는데, 이 패킷의 최대치가 윈도우 크기(Window size)를 의미함
            - 윈도우 크기(Window Size)는 상황에 따라 변함. 즉, 수신측으로부터 이전에 송신한 패킷에 대한 긍정 수신 응답(ACK)이 전달된 경우 윈도우 크기는 증가하고, 수신 측으로부터 이전에 송신한 패킷에 대한 부정 수신 응답 (NAK)이 전달된 경우 윈도우 크기는 감소함

---

Q. 아래는 비선점형 스케줄링 알고리즘의 유형에 대한 설명이다. () 안에 들어갈 유형을 쓰시오.

> SJF(Shortest Job First), HRN(Highest Response Ratio Next)
> 
( ① )은/는 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원을 점유하는 스케줄링 알고리즘으로, CPU 요구 시간이 긴 작업과 짧은 작업 간의 불평등이 심하여 기아 현상이 발생한다. 또한( ② )은/는 ( ① )의 약점인 기아 현상을 보완한 기법으로 긴 작업과 짧은 작업 간의 지나친 불평등을 해소하기 위하여, 대기 중인 프로세스 중 대기시간이 긴 프로세스일 경우 우선순위가 높아지게 하여 우선순위를 결정하는 스케줄링 기법이다.

- 프로세스 스케줄링 알고리즘 유형에는 선점형 스케줄링과 비선점형 스케줄링이 있다.
- 비선점형 스케줄링 알고리즘 유형에는 우선순위(Priority), 기한부(Deadline), FCFS(First Come First Service), SJF(Shortest Job First), HRN(Highest Response Ratio Next)가 있다.

| 용어 | 설명 |
| --- | --- |
| SJF(Shortest Job First) | 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료시까지 자원을 점유하는 스케줄링 알고리즘으로, CPU 요구 시간이 긴 작업과 짧은 작업 간의 불평등이 심하여 기아 현상이 발생 |
| HRN(Highest Response Ratio Next) | SJF의 약점인 기아 현상을 보완한 기법으로 긴 작업과 짧은 작업 간의 지나친 불평등을 해소하기 위하여 대기 중인 프로세스 중 대기시간이 긴 프로세스일 경우 우선순위가 높아지게 하여 우선순위를 결정하는 스케줄링 기법 |
| 우선순위(Priority) | 미리 정의한 알고리즘대로 프로세스의 우선순위를 결정하는 방식 |
| 기한부(Deadline) | 프로세스마다 정해진 시간할당량만큼만 실행되도록 지정하는 방식 |

---

Q. 아래는 응집도 유형에 대한 설명이다. () 안에 들어갈 응집도 유형을 쓰시오.

> 절차적 응집도(Procedural Cohesion), 통신적/교환적 응집도(Communication Cohesion), 순차적 응집도(Sequential Cohesion)
> 
- ( ① ): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 응집도
- ( ② ): 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도
- ( ③ ): 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우의 응집도

- 응집도(Cohesion): 하나의 모듈이 하나의 기능을 수행하는 요소들간의 연관성 척도
- 독립적인 모듈이 되기 위해서는 응집도가 강해야 한다.
- 응집도의 유형은 아래와 같다.
    - **우연적** 응집도(**Coincidental** Cohesion)
        - 서로 간에 **어떠한 의미 있는 연관 관계도 없는** 기능 요소로 구성될 경우의 응집도
        - 서로 다른 상위 모듈에 의해 호출되어 처리상의 **연관성이 없는 서로 다른 기능을 수행**할 경우의 응집도
    - **논리적** 응집도(**Logical** Cohesion)
        - **유사한 성격**을 갖거나 특정 형태로 분류되는 처리요소들이 한 모듈에서 처리되는 경우의 응집도
    - **시간적** 응집도(**Temporal** Cohesion)
        - 연관된 기능이라기보다는 **특정 시간에 처리**되어야 하는 활동들을 한 모듈에서 처리할 경우의 응집도
    - **절차적** 응집도(**Procedural** Cohesion)
        - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 **순차적**으로 수행할 경우의 응집도
        - 모든 수행 요소들이 반드시 **특정 순서대로** 수행
    - **교환적/통신적** 응집도(**Communication** Cohesion)
        - **동일한 입력과 출력**을 사용하여 **다른 기능을 수행**하는 활동들이 모여 있을 경우의 응집도
    - **순차적** 응집도(**Sequential** Cohesion)
        - 모듈 내에서 한 활동으로부터 나온 **출력값을 다른 활동이 사용**할 경우의 응집도
    - **기능적** 응집도(**Functional** Cohesion)
        - 모듈 내부의 **모든 기능이 단일한 목적**을 위해 수행되는 경우의 응집도

![이미지](/assets/img/exam/07/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_07%ED%9A%8C(5).png)

---

Q. 보안 암호화 관련 용어에 대한 설명이다. () 안에 들어갈 올바른 용어를 쓰시오.

> SET(Secure Electronic Transaction)
> 
()은/는 온라인상의 안전한 거래를 위해 Visa와 Master Card에서 개발한 프로토콜로, 개인 계좌 정보나 신용 정보 등이 네트워크를 통해 노출되거나 위∙변조되는 것을 막으며, 메시지 암호화 방법과 2중 전자서명 등에 활용되어 기밀성과 무결성을 보장한다.

- 보안 관련 용어 중 해시 함수와 SET의 개념은 아래와 같다.
    - 해시 함수(Hash Function)
        - 임의의 길이를 갖는 값을 입력받으면 고정된 길이의 값을 출력하는 함수
        - 직접 접근할 수 있는 짧은 길이의 값이나 키가 존재하여 해당 주소에 빠른 접근이 가능하며, 메시지의 오류나 변조를 탐지하는 데 활용
    - SET(Secure Electronic Transaction)
        - 온라인상의 안전한 거래를 위해 Visa와 Master Card에서 개발한 프로토콜
        - 개인 계좌 정보나 신용 정보 등이 네트워크를 통해 노출되거나 위∙변조되는 것을 막으며, 메시지 암호화 방법과 2중 전자서명 등에 활용되어 기밀성과 무결성 보장


<br>
**참고 자료**

---

- [https://peterica.tistory.com/362 - 오픈스택](https://peterica.tistory.com/362)
- [https://ko.wikipedia.org/wiki/오픈스택](https://ko.wikipedia.org/wiki/%EC%98%A4%ED%94%88%EC%8A%A4%ED%83%9D)
- [https://blog.naver.com/jvioonpe/220702954814 - 정보 보안 3요소](https://blog.naver.com/jvioonpe/220702954814)
- [https://m.blog.naver.com/suresofttech/221833396343 - 구조적 커버리지 종류와 정의](https://m.blog.naver.com/suresofttech/221833396343)
- [https://devpouch.tistory.com/76 - 리스트 내포](https://devpouch.tistory.com/76)
- [https://devpouch.tistory.com/70 - range 함수](https://devpouch.tistory.com/70)
- [https://www.techopedia.com/kr/definition/database-management-systems-dbms - DBMS](https://www.techopedia.com/kr/definition/database-management-systems-dbms)
- [https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation - 데이터베이스 고립화 수준](https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation)
- [https://m.blog.naver.com/kji9653/222021554040 - 소프트웨어 아키텍처 4+1 뷰](https://m.blog.naver.com/kji9653/222021554040)