---
categories: [Certificate, "[정보처리기사] 모의고사(01~35회)"]
---

Q. 다음 () 안에 들어갈 가장 올바른 용어를 쓰시오. 

> 데이터 마트(Data Mart), 데이터 웨어하우스(Data Warehouse)
> 
- ( ① )은/는 데이터의 한 부분으로서 **특정 사용자가 관심을 갖는 데이터**들을 담은 비교적 작은 규모의 ( ② )이다.  일반적인 데이터베이스 형태를 갖고 있는 다양한 정보를 사용자의 요구 항목에 따라 체계적으로 분석하여 **기업의 경영 활동**을 돕기 위한 시스템을 말한다. 전체적인 ( ② )에 있는 일부 데이터를 가지고 특정 사용자를 대상으로 한다.
- ( ② )은/는 급증하는 다량의 데이터를 효과적으로 분석하여 정보화하고 이를 여러 계층의 **사용자들이 효율적으로 사용**할 수 있도록 한 데이터베이스이다. **다양한 원본 데이터베이스로부터 정제되어 추출된 데이터**만을 저장, 필요한 인덱스를 생성하고, 데이터의 다차원 분석 도구로 분석하여 효율적인 의사결정에 필요한 자료를 얻는다.

---

Q. 트랜잭션에서 사용하는 로킹(Locking) 기법의 개념에 대해서 서술하시오. 

> 로킹(Locking) 기법이란 트랜잭션이 사용하는 데이터 항목에 대하여 잠금(Lock)을 설정한 **트랜잭션이 해제(Unlock)할 때까지 독점적으로 사용**할 수 있게 **상호배제 기능**을 제공하는 기법이다.
>

- 병행 제어 기법 종류에는 로킹(Locking) 기법, 낙관적 검증(Validation) 기법, 타임 스탬프 순서(Timestamp ordering), 다중버전 동시성 제어(MVCC) 기법이 있다.

---

Q. 다음이 설명하는 IoT 관련 프로토콜은 무엇인지 쓰시오. 

> MQTT(Message Queuing Telemetry Transport)
> 
- IoT 장치, 텔레메트리 장치 등에서 최적화되어 사용할 수 있도록 개발된 프로토콜로, 브로커를 사용한 **Publish/Subscribe 방식**의 라이트 메시징을 전송하는 프로토콜
- 저전력 센서, 스위치, 밸브 등의 기기에 대한 표준적 인터넷환경을 지원하고, 프로토콜 리소스 점유 최소화, 한정된 자원 시스템 지원하는 특징이 있음

- 텔레메트리는 먼 거리나 접근할 수 없는 지점에서 일어나는 데이터를 수집하고 전송하는 통신 방법이다. 텔레메트리는 자동화된 감지, 데이터 측정 및 원격 디바이스의 제어를 가리킨다. 주안점은 디바이스에서 중앙 제어 지점으로의 데이터 전송이다.

---

Q. 다음은 [학생] 테이블 스키마에 대한 명세이다. [학생] 테이블에서 학번이 ‘202101’이고, 성명은 ‘임꺽정’, 과목은 ‘프로그래밍’, 전화번호는 ‘010-1234-5678’인 학생의 정보를 입력하시오.

```sql
INSERT INTO 학생 VALUES ('202101', '임꺽정', '프로그래밍', '010-1234-5678');
```

```sql
INSERT INTO 학생(학번, 성명, 과목명, 전화번호) VALUES ('202101', '임꺽정', '프로그래밍', '010-1234-5678'); 
```

- INSERT는 데이터의 내용을 삽입할 때 사용하는 명령어이다.
    
    ```sql
    INSERT INTO 테이블명(속성명1, ...) VALUES (데이터1, ...);
    ```
    
    - 속성과 데이터 개수, 데이터 타입이 일치해야 함
    - 속성명은 생략 가능
    - 속성의 타입이 숫자인 경우 데이터는 따옴표를 붙이지 않아도 되며, 문자열인 경우 따옴표를 붙여야 함
- DB에서 속성의 타입이 숫자인 경우 데이터는 따옴표를 붙이지 않아도 되며, 문자열인 경우 따옴표를 붙여야 한다. 그리고 테이블명, 인덱스명, 속성명과 같이 객체와 객체와 관련된 요소들은 일반적으로 따옴표를 붙이지 않는다.

---

Q. 다음은 공유 매체에 대한 다중 접근 방식에 대한 설명이다. () 안에 들어갈 용어를 쓰시오. 

> CSMA/CD(Carrier Sense Multiple Access with Collision Detection; 반송파 감지 다중접속 / 충돌 탐지), CSMA/CA(Carrier Sense Multiple Access with Collision Avoidance; 반송파 감지 다중접속 / 충돌 회피)
> 
- ( ① )은/는 IEEE802.**3** **유선** LAN의 반이중방식(Half Duplex)에서, 각 단말이 신호 전송 전에 현재 채널이 사용 중인지 체크하여 **전송하는 매체 액세스 제어(MAC) 방식**이다.
- ( ② )은/는 무선 LAN의 반이중방식(Half Duplex)에서, 사전에 가능한 충돌을 회피(Collision Avoidance)하는 **무선**전송 다원접속 방식이다.(IEEE802.11)

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 2023
> 

```c
#include <stdio.h>
#include <stdlib.h>
void main(){
	char str[8] = "2021";
	int num = atoi(str);
	printf("%d", num + 2);
}
```

- **문자열을 저장**하기 위한 str 변수에 사이즈 8로 선언하고 초깃값으로 2021을 대입한다.
- 정수형 변수 num을 선언하고 atoi 함수를 이용하여 문자열 “2021”을 정수 2021로 변환하고 num에 대입한다.
- num 값에 2를 더한 2023을 화면에 출력한다.
- atoi 함수는 **문자열을 정수로 변환**하는 함수로 **“stdlib.h”** 헤더 파일을 include해야 한다.
    - atoi(): Ascii to Integer
    - atof(): Ascii to Float
    - itoa(): Integer to Ascii

---

Q. 다음이 설명하는 보안 솔루션은 무엇인가?

> **스팸 차단 솔루션(Anti-Spam Solution)**
> 
- 메일 서버 앞단에 위치하여 **프록시(Proxy) 메일 서버**로 동작
- 메일 바이러스 검사, 내부 → 외부 본문 검색 기능 통한 내부 정보 유출 방지

 

- 스팸(Spam)은 이메일이나 휴대폰 등 정보통신 서비스를 이용하는 이용자에게 본인이 원치 않음에도 불구하고 일방적으로 전송되는 영리목적의 광고성 정보를 의미하며, 스팸 차단 솔루션을 통해 사용자를 보호한다.

---

Q. 다음은 비지니스 연속성 계획과 관련한 주요 용어이다. 아래에서 설명하는 용어를 쓰시오. 

> RPO(Recovery Point Objective)
> 
- 업무중단 시점부터 데이터가 복구되어 다시 정상 가동될 때 데이터의 손실 허용 지점
- 재해 시 복구 목표 지점의 선정

- 비지니스의 연속성 계획(**BCP**; Business Continuity Plan)은 각종 재해, 장애, 재난으로부터 위기관리를 기반으로 재해복구, 업무복구 및 재개, 비상계획 등을 통해 **비지니스 연속성을 보장하는 체계**이다.
- 비지니스 연속성 계획 관련 주요 용어는 다음과 같다.
    - BIA(Business Impact Analysis)
        - 장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실평가를 조사하는 BCP를 구축하기 위한 **비지니스 영향 분석**
    - DRP(Disaster Recovery Plan)
        - 재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획
    - DRS(Disaster Recovery System)
        - 재난복구계획의 원할한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적, 물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구시스템
    - RTO(Recovery Time Objective)
        - 업무중단 시점부터 **업무가 복구**되어 **다시 가동될 때까지의 시간**
        - 재해 시 복구 목표 시간의 선정
    - RPO(Recovery Point Objective)
        - 업무중단 시점부터 **데이터가 복구**되어 다시 정상가동될 때 **데이터의 손실 허용 시점**
        - 재해 시 복구 목표 지점의 선정

---

Q. 주어진 ‘도서’ 테이블과 ‘도서가격’ 테이블을 내부 조인(Inner Join)하는 SQL 문을 작성하시오.

```sql
SELECT A.책번호 AS "책번호", A.책명 AS "책명", B.가격 AS "가격"
FROM 도서 A
[INNER] JOIN 도서가격 B
ON A.책번호 = B.책번호;
```

[도서] 테이블

| 책번호 | 책명 |
| --- | --- |
| 100 | Algorithm |
| 200 | 테스트의 이해 |
| 300 | Introduction to Java |
| 400 | C++ Programming |

[도서가격] 테이블

| 책번호 | 가격 |
| --- | --- |
| 100 | 15000 |
| 200 | 18000 |
| 300 | 29000 |
| 400 | 35000 |

[결과] 테이블

| 책번호 | 책명 | 가격 |
| --- | --- | --- |
| 100 | Algorithm | 15000 |
| 200 | 테스트의 이해 | 18000 |
| 300 | Introduction to Java | 29000 |
| 400 | C++ Programming | 35000 |

- 조인은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법이다.
- 조인의 주요 문법은 다음과 같다.
    - 내부 조인
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ...
    FROM 테이블1 A 
    [INNER] JOIN 테이블2 B
    ON 조인조건
    [WHERE 검색조건];
    ```
    
    - 오른쪽 외부 조인
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B,컬럼2, ...
    FROM 테이블1 A
    RIGHT [OUTER] JOIN 테이블2 B
    ON 조인조건
    [WHERE 검색조건];
    ```
    
    - 완전 외부 조인
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B,컬럼2, ...
    FROM 테이블1 A
    FULL [OUTER] JOIN 테이블2 B
    ON 조인조건
    [WHERE 검색조건]; 
    ```
    
    - 교차 조인
    
    ```sql
    SELECT 컬럼1, 컬럼2, ...
    FROM 테이블1
    CROSS JOIN 테이블2
    ```
    
    - 셀프 조인
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ... 
    FROM 테이블1 A
    [INNER] JOIN 테이블1 B
    ON 조인조건
    [WHERE 검색조건];
    ```
    

---

Q. 다음이 설명하는 가장 적합한 라우팅 알고리즘은 무엇인가?

> 거리 벡터 알고리즘(Distance Vector Algorithm)
> 
- 인접 라우터와 정보를 공유하여 목적지까지의 거리와 방향을 결정하는 라우팅 알고리즘
- 벨만-포드(Bellman-Ford) 알고리즘 사용

- 목적지까지의 최적 경로를 산출하기 위한 법칙이 라우팅 알고리즘이다.
- 라우팅 알고리즘의 유형은 다음과 같다.
    - **거리 벡터** 알고리즘(Distance Vector Algorithm)
        - 거리 벡터 알고리즘은 인접 라우터와 정보를 공유하여 목적지까지 거리와 방향을 결정하는 라우팅 프로토콜 알고리즘
        - **벨만-포드(Bellman-Ford) 알고리즘** 사용
        - 각 라우터가 업데이트될 경우마다 전체 라우팅 테이블을 보내라고 요청하지만 수신된 경로 비용 정보는 이웃 라우터에게만 보내짐
    - 링크 상태 알고리즘(Link State Algorithm)
        - 링크 상태 알고리즘은 링크 상태 정보를 모든 라우터에 전달하여 최단 경로 트리를 구성하는 라우팅 프로토콜 알고리즘
        - **다익스트라(Dijkstra) 알고리즘** 사용
        - 링크 상태 알고리즘을 사용하면 네트워크를 일관성 있게 파악할 수 있으나 거리 벡터 알고리즘에 비하여 계산이 더 복잡하고 트래픽을 광범위한 범위까지 전달

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> 27
> 

```python
def soojebi(begin, diff, n):
	cnt = 1
	ret = begin
	while True:
		cnt += 1
		ret *= diff
		if cnt == n:
			return ret

print(soojebi(1, 3, 4))
```

- soojebi라는 함수를 선언하며 파라미터로 begin, diff, n을 전달받는다.
- cnt는 1로 초기화하고 ret는 begin 값으로 초기화한다.
- while문은 True일 때까지 반복을 수행한다. cnt 값을 1 증가시키고 ret와 diff를 곱한 결과를 ret에 대입한다. 만약 cnt가 n과 같으면 ret 값을 리턴한다.
- 사용자 정의함수를 파라미터에 1, 3, 4로 호출한다.

| cnt | ret | begin | diff | n |
| --- | --- | --- | --- | --- |
|  |  | 1 | 3 | 4 |
| 1 | 1 |  |  |  |
| 2 | 3 |  |  |  |
| 3 | 9 |  |  |  |
| 4 | 27 |  |  |  |

---

Q. 디지털 저작권 관리를 위한 요소 중 소비자와 유통업자 사이에 발생하는 거래에 대해 디지털 저작권 라이선싱을 중개하고 라이선스 발급을 수행하는 정산소를 무엇이라 하는가?

> 클리어링 하우스(Clearing House)
> 

- 디지털 저작권 관리(DRM; Digital Rights Management)를 위한 구성요소는 다음과 같다.
    
    
    | 구성요소 | 설명 |
    | --- | --- |
    | 콘텐츠 제공자(Contents Provider) | 콘텐츠를 제공하는 저작권자 |
    | 콘텐츠 분배자(Contents Distributor) | 쇼핑몰 등으로써 암호화된 콘텐츠 제공 |
    | 패키저(Packager) | 콘텐츠를 메타데이터와 함께 배포 가능한 단위로 묶는 기능 |
    | 보안 컨테이너(Security Container) | 원본을 안전하게 유통하기 위한 전자식 보안 장치 |
    | DRM 컨트롤러(DRM Controller) | 배포된 컨텐츠의 이용 권한을 통제 |
    | 클리어링 하우스(Clearing House) | 디지털 라이선싱 중개 및 발급을 수행하는 정산소 |

---

Q. 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL은 무엇인가?

> 트리거(Trigger)
> 

- 절차형 SQL은 프로시저, 사용자 정의함수, 트리거가 있다.
    
    
    | 종류 | 설명 |
    | --- | --- |
    | 프로시저(Procedure) | 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합 |
    | 사용자 정의함수(User-Defined Function) | 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL |
    | 트리거(Trigger) | 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL |

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> P(String) : Soojebi2021
> 

```java
class Parent {
  String name = "Parent";
  public Parent() {
	  System.out.print("P : " + this.name);
	}
	public Parent(String name) {
		this.name = name;
		System.out.print("P(String) : " + this.name);
	}
}
class Child extends Parent {
	int num;
	public Child(String name, int num) {
		super(name);
		this.num = num;
	}
	void info() {
		System.out.print(num); 
	}
}
public class Soojebi {
	public static void main(String[] args) {
		Child c = new Child("Soojebi", 2021);
		c.info();
	}
}
```

- Parent 클래스는 부모 클래스로 2개의 생성자 메서드를 가진다. 파라미터가 없는 생성자와 파라미터가 1개인 생성자이다. 두 생성자 모두 화면에 “P(String)” this.name을 출력한다. 파라미터가 있는 경우 전달받은 name을 출력한다.
- Child 클래스의 Child() 생성자에서 super()를 호출하여 부모 클래스인 Parent 클래스의 생성자를 호출한다. this.num에 파라미터로 전달받은 num을 대입한다. info 메서드는 num 값을 화면에 출력한다.
- 메인 메서드에서 파라미터로 “Soojebi”와 2021을 전달하고 객체를 생성한다.
- 생성자가 호출되어 화면에는 “P(String) : Soojebi”가 출력된다.
- c.info가 호출되고 num 값인 2021을 출력한다.

---

Q. 다음 사원 테이블 스키마를 보고, 사원 테이블에서 성별 값이 ‘M’을 가진 사원의 사번, 이름을 출력하는 ‘사원뷰’라는 이름의 뷰를 생성하는 쿼리를 작성하시오.

```sql
CREATE VIEW 사원뷰 AS SELECT 사번, 이름 FROM 사원 WHERE 성별 = 'M';
```

- **`사원 테이블(사번, 업무, 이름, 생년월일, 성별, 입사일)`**

- 사원 테이블에서 성별 값이 ‘M’을 가진 사원의 사번, 이름을 출력하는 조회 쿼리를 먼저 작성한다.
    
    ```sql
    SELECT 사번, 이름 FROM 사원 WHERE 성별 = 'M';
    ```
    
- 뷰를 생성하는 명령은 다음과 같다.
    
    ```sql
    CREATE VIEW 뷰이름 AS 조회쿼리;
    ```
    
- 조회쿼리 앞에 CREATE VIEW 사원뷰 AS를 붙이면 뷰 생성 쿼리가 생성된다.

---

Q. 다음이 설명하는 객체지향 설계 원칙은 무엇인가?

> 의존성 역전의 원칙(Dependency Inversion Principle)
> 
- 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙

- 객체지향 설계 원칙(SOLID)는 다음과 같다.
    - 단일 책임의 원칙(Single Responsibility Principle)
        - 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
        - 객체지향 프로그래밍의 5원칙 중 나머지 4원칙의 기초 원칙
    - 개방 폐쇄 원칙(Open Close Principle)
        - 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 원칙
    - 리스코프 치환의 원칙(Liskov Substitution Principle)
        - 서브 타입(상속받은 하위 클래스)은어디서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 한다는 원칙
    - 인터페이스 분리의 원칙(Interface Segregation Principle)
        - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
        - 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안 된다는 원칙
    - 의존성 역전의 원칙(Dependency Inversion Principle)
        - 실제 사용 관계는 바뀌지 않으며, **추상을 매개로 메시지를 주고받음**으로써 **관계를 최대한 느슨**하게 만드는 원칙
    

---

Q. 다음은 그래프의 유형에 대한 설명이다. 가장 올바른 그래프의 유형을 쓰시오.

> 방향 그래프(Directed Graph)
> 

- 정점을 연결하는 선에 방향이 있는 그래프
- n개의 정점으로 구성된 방향 그래프의 최대 간선수는 n(n-1)인 그래프

![이미지](/assets/img/exam/03/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_03%ED%9A%8C(1).png)

---

Q. **리누스 토발즈**가 2005년 리눅스 커널의 개발을 위해 만든 시스템으로 중앙 집중형 방식이 아닌 분산형 방식으로 각 PC가 스스로 완전한 저장소가 구성되며, 필요에 따라 중앙 집중형 방식으로도 운영할 수 있는 형상 관리 시스템은 무엇인가?

> Git
> 

- Git의 기능과 장단점은 다음과 같다.
    - 주요 기능
        - Branch, Check-Out, Commit 등 로컬 환경에서의 형상 관리 기능
        - Push, Fetch, Pull 등 원격 환경에서의 변경 전송기능
        - SVN 저장소에 대한 이관(Migration) 기능
    - 장점
        - 저장소(Repository)의 완전한 복사본을 로컬(Local) 저장 가능
        - 로컬 저장을 통해 오프라인(Offline) 작업 가능
        - 일시적인 작업에 대한 이력 관리가 쉬움
    - 단점
        - 대용량 코드 관리에 부적절
        - 한 번에 diff 명령어를 통한 변경사항을 보기 어려움
        - CVS, SVN과 개념이 상이하여 학습시간이 요구

---

Q. 지역성의 유형 중 ()은/는 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상으로 참조된 메모리 근처의 메모리를 참조하는 특성과 사례로는 배열 순회가 있다. () 안에 들어갈 유형을 쓰시오.

> 공간(Spatial) 지역성
> 

- 지역성의 유형에는 시간 지역성, 공간 지역성, 순차 지역성이 있다.
    - 시간(Temporal) 지역성
        - **최근 사용**되었던 기억장소들이 집중적으로 액세스하는 현상
        - 참조했던 메모리는 **빠른 시간에 다시 참조**될 확률이 높은 특성
        - 사례: Loop(반복, 순환), 스택(Stack), 부프로그램(SubRoutine), Counting(1씩 증감), 집계(Totaling)에 사용되는 변수(기억장소)
    - 공간(Spatial) 지역성
        - 프로세스 실행 시 **일정 위치**의 페이지를 집중적으로 액세스하는 현상
        - 참조된 메모리 **근처의 메모리**를 참조하는 특성
        - 사례: **배열** 순회, 프로그래머들이 관련된 변수(데이터 저장 기억장소)들을 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수 참조
    - 순차(Sequential) 지역성
        - 데이터가 순차적으로 액세스 되는 현상
        - 프로그램 내의 명령어가 순차적으로 구성된 특성
        - 공간 지역성에 편입되어 설명되기도 함
        - 사례 : **순차적 코드 실행**

- 지역성: 프로세스가 실행되는 동안 일부 페이지만 집중 참조
- 워킹 셋: 일정시간 동안 자주 참조되는 페이지들의 집합
- 페이지 부재: 필요한 페이지가 주기억 장치에 없는 상황
- 스레싱: 프로세스 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상

---

Q. 다음은 자바 코드이다. 실행 결과를 쓰시오.

> 30
> 

```java
public class Soojebi {
  public static void main(String[] args) {
		int i=0; sum=0;
		while(i<10){
			i++;
			if(i%2 == 1)
				continue;
			sum += i;
		}	 
		System.out.print(sum);
  }
}
```

- 정수형 변수 i와 sum을 선언과 동시에 0으로 초기화한다.
- while 반복문은 i가 10보다 작을 때까지 반복을 수행한다.
- i++에서 i 값을 1 증가시킨다.
- 만약 i 값을 2로 나눈 나머지가 1인 경우 continue를 수행한다.
- sum+=i;에서 sum 값과 i 값을 더한 결과를 sum에 대입한다.
- while 반복문이 종료되고 sum 값을 화면에 출력한다.

| i | i++ | sum | continue |
| --- | --- | --- | --- |
| 0 | 1 | 0 | 실행 |
| 1 | 2 | 2 |  |
| 2 | 3 |  | 실행 |
| 3 | 4 | 6 |  |
| 4 | 5 |  | 실행 |
| 5 | 6 | 12 |  |
| 6 | 7 |  | 실행 |
| 7 | 8 | 20 |  |
| 8 | 9 |  | 실행 |
| 9 | 10 | 30 |  |

