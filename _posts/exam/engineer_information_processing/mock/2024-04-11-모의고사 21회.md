---
categories: [Certificate, "[정보처리기사] 모의고사(01~35회)"]
---

Q. 보안 소켓 계층을 이르는 것으로, 인터넷상에서 데이터를 안전하게 전송하기 위한 인터넷 암호화 통신 프로토콜이며 데이터 보안을 위해서 개발한 통신 레이어를 무엇이라고 하는가?

> SSL(Secure Socket Layer)
> 

- SSL은 Netscape사가 1990년대 초반 웹 보안을 위해서 처음 개발하였고, 보안 기능으로 기밀성, 상호인증, 메시지 무결성 등을 제공한다.
- **VPN(Virtual Private Network**, 가상 사설 통신망), 사설 통신망: 회사 내부의 사람들만 통신망을 사용할 수 있도록 구축
    - VPN은 인터넷 등 통신 사업자(SK)의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션
    - **SSL**(**Secure Sockets Layer**, 보안 소켓 계층) **VPN** : PC에 VPN Client 프로그램을 설치하여 VPN 서버에 접속하는 방식으로, 암호화를 위해 SSL 프로토콜을 사용함
    - **IPSec VPN** : VPN 서버가 설치된 각각의 네트워크를 서로 연결하는 방식으로, 암호화를 위해 IPSec 프로토콜을 사용함
        
        ![이미지](/assets/img/exam/21/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_21%ED%9A%8C(1).png)
        

---

Q. 다음은 무선보안과 관련된 내용이다. () 안에 들어갈 올바른 용어를 쓰시오.

> 랜섬웨어(Ransomeware), 비트코인(Bitcoin)
> 

( ① )은/는 컴퓨터 시스템을 감염시켜 접근을 제한하고 일종의 몸값을 요구하는 악성 소프트웨어의 한 종류다. 컴퓨터로의 접근이 제한되기 때문에 제한을 없애려면 해당 악성 프로그램을 개발한 자에게 지불을 강요받게 된다. 이때 ( ② )을/를 요구하기도 한다. ( ② )은/는 블록체인 기술을 기반으로 만들어진 온라인 암호 화폐이다. 화폐 단위는 BTC로 표시한다. 

- 랜섬웨어는 사용자 디바이스 또는 네트워크 스토리지 디바이스의 파일을 암호화하는 멀웨어의 한 가지 유형이다.
- 암호화된 파일에 대한 접속 권한을 복구하려면 사용자가 일반적으로 추적이 어려운 비트코인과 같은 전자 결제 방식을 통해 몸값을 사이버 범죄자에게 지불해야 한다.
- 멀웨어(Malware): 악의적인 목적을 위해 작성된 실행 가능한 코드로 악성코드 또는 악성프로그램 등으로 불리고, 실행 가능한 코드에는 프로그램 매크로, 스크립트가 아니라 취약점을 이용한 데이터 형태로 표현된다.

---

Q. 다음은 함수형 언어의 기능에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 순수 함수(Pure Function), 익명 함수(Anonymous Function), 고계 함수(Higher Order Function)
> 
- ( ① ): 어느 순간에 호출해도 동일한 값을 반환하고 병렬적인 계산이 가능한 함수
- ( ② ): 이름 없는 함수라고 하고, 람다(Lambda)식이라고도 불림
- ( ③ ): 함수를 또 하나의 값으로 간주하여 함수의 인자 혹은 반환 값으로 사용할 수 있는 함수

- 함수형 언어의 기능은 다음과 같다.
    - 순수 함수(Pure Function)
        - 어느 순간에 호출해도 동일한 값을 반환(부작용이 없는 함수)
        - 스레드 안전하고, 병렬적인 계산이 가능
        - (defun square(x)(* x x))
            
            x값에 대해 x * x를 반환하는 이름이 square 함수
            
    - 익명 함수(Anonymous Function)
        - 이름이 없는 함수
        - 람다(Lambda)식이라고도 불림
        - (lambda(x)(*x x))
            
            x값에 대해 x * x를 반환하는 함수이지만, 함수의 이름이 존재하지 않음
            
    - 고계 함수(Higher Order Function)
        - 함수를 또 하나의 값으로 간주하여 함수의 인자 혹은 반환값으로 사용할 수 있는 함수
        - (defun square(x)(* x x))
            
            (defun cubic(x)(* x square(x)))
            
            square라는 제곱함수에 x를 곱한 cubic이라는 함수 사용
            

---

Q. 교착상태 회피(Avoidance 기법으로 사용자 프로세스는 사전에 자기 작업에 필요한 자원의 수를 제시하고 운영체제가 자원의 상태를 감시, 안정상태일 때만 자원을 할당하는 기법을 무엇이라고 하는가?

> 은행가 알고리즘(Banker’s Algorithm)
> 

- 교착상태 회피(Avoidance) 기법에는 은행가 알고리즘(Banker’s Algorithm)과 Wound-Wait, Wait-Die가 있다.
- 은행가 알고리즘은 사용자 프로세스는 사전에 자기 작업에 필요한 자원의 수를 제시하고 운영체제가 자원의 상태를 감시, 안정상태일 때만 자원을 할당하는 기법이다.

---

Q. 다음은 [학생] 테이블이다. 이름에 ‘John’이라는 문자열이 포함된 쿼리를 작성하시오.

```sql
SELECT 학번, 이름, 학년
FROM 학생
WHERE 이름 LIKE '%John%';
```

[학생]

| 학번 | 이름 | 학년 |
| --- | --- | --- |
| 202101 | Alice | 1 |
| 202102 | John | 3 |
| 202103 | Jordan | 2 |
| 202104 | Johnson | 3 |
| 202105 | Dave | 4 |
| 202106 | Eve | 3 |
| 202107 | M.John | 2 |

[결과]

| 학번 | 이름 | 학년 |
| --- | --- | --- |
| 202102 | John | 3 |
| 202104 | Johnson | 3 |
| 202107 | M.John | 2 |

- WHERE절 조건에서는 비교, 범위, 집합, 패턴, NULL, 복합조건이 있고, 패턴을 찾기 위해서는 LIKE 구문을 사용한다.
- LIKE 문법은 다음과 같다.
    
    ```sql
    컬럼 LIKE 패턴
    ```
    
- 패턴을 사용하기 위한 와일드카드는 다음과 같다.
    
    
    | 와일드카드 | 설명 |
    | --- | --- |
    | % | 0개 이상의 문자열과 일치 |
    | [] | 1개의 문자와 일치 |
    | [^] | 1개의 문자와 불일치 |
    | _ | 특정 위치의 1개의 문자와 일치 |

- 다음 예제에서는 문자 `m`로 시작하는 이름을 반환한다. `[n-z]`는 두 번째 문자가 `n`부터 `z` 사이여야 함을 지정한다. 백분율 와일드카드 `%` 3자로 시작하는 문자를 허용하거나 허용하지 않는다. `model` 및 `msdb` 데이터베이스는 이 조건을 충족한다. `master` 데이터베이스는 기준을 충족하지 않으며 결과 집합에서 제외된다.
    
    ```sql
    SELECT name FROM sys.databases
    WHERE name LIKE 'm[n-z]%';
    ```
    
    결과 집합은 다음과 같다.
    
    ```sql
    name
    -----
    model
    msdb
    ```
    
    ![이미지](/assets/img/exam/21/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_21%ED%9A%8C(2).png)
    

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> 2
> 

```python
stack = [1, 2, 3]
stack.append(4)
top = stack.pop()
top = stack.pop()
top = stack.pop()
print(**top**)
```

- 스택은 마지막에 들어간 자료가 가장 먼저 나오는 LIFO(Last In First Out) 자료구조이다. 스택에 데이터를 넣는 연산을 Push, 스택에서 데이터를 꺼내는 연산을 Pop이라고 한다. 스택은 데이터를 넣는 위치와 꺼내는 위치가 같으므로 다음 그림과 같은 형태 구조로 되어 있다.
    
    ![이미지](/assets/img/exam/21/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_21%ED%9A%8C(3).png)
    
- 스택에 초깃값 [1, 2, 3]을 추가한다. stack.append(4)를 실행하여 4를 스택에 삽입한다. 스택은 [1, 2, 3, 4]가 된다.
- top = stack.pop()를 실행하여 가장 나중에 삽입한 4가 나온다.
- top = stack.pop()를 다시 실행하여 3이 나오고 2가 나온다.
- top을 print 함수를 이용하여 출력하면 2가 화면에 출력된다.
- 파이썬 스택 함수에는 데이터를 스택에 넣는 append 함수와 스택으로부터 값을 빼는 pop 함수가 있다.
    
    
    | 구분 | 함수 |
    | --- | --- |
    | 데이터 삽입 | append |
    | 데이터 삭제 | pop |

---

Q. 정적 테스트 기법 중 정의된 계획 및 명세를 준수하고 있는지에 대한 검토를 수행하는 리뷰 변경 사항이 적절하게 구현되었는지를 평가하고, 여러 대안을 추천하거나 대안을 검토하는 기법은 무엇인가?

> 기술 리뷰(Technical Review)
> 

- 리뷰의 유형은 다음과 같다.
    - 관리 리뷰(Management Review)
        - 프로젝트 진행 상황에 대한 전반적인 검토를 바탕으로 범위, 일정, 인력 등에 대한 통제 및 의사결정을 지원하는 리뷰
    - 기술 리뷰(Technical Review)
        - 정의된 계획 및 명세를 준수하고 있는지에 대한 검토를 수행하는 리뷰
        - 변경사항이 적절하게 구현되었는지를 평가하고, 여러 대안을 추천하거나 대안을 검토
        - 대표 엔지니어가 주재하여 경우에 따라서 관리자도 참여 가능
    - 인스펙션(Inspection)
        - 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 문제를 식별하고 문제에 대한 올바른 해결을 찾아내는 형식적인 검토 기법
    - 워크스루(Walk Throughs)
        - 검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 문제 식별, 대안 조사, 개선 활동, 학습 기회를 제공하는 가장 비형식적인 검토 기법
    - 동료 검토(Peer Review)
        - 2~3명이 진행하는 리뷰의 형태로 요구사항 명세서 작성자가 요구사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행하는 검토 기법

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> arr[1][4]=4
> 

```c
#include <stdio.h>
void main() {
	int i, j;
	int arr[2][5];
	int find_num = 4;
	
	for(i=0; i<2; i++) {
		for(j=0; j<5; j++) {
			arr[i][j] = i * j;
		}
	}
	
	for(i=0; i<2; i++) {
		for(j=0; j<5; j++) {
			if(arr[i][j] == find_num) {
				printf("arr[%d][%d]", i, j);
				printf("=%d\n", arr[i][j]);
			}
		}
	}
}
```

- for 반복문에서 사용할 정수형 변수 i, j를 선언한다. 값을 저장할 정수형 변수 arr 배열을 2행 5열로 선언한다. 배열 내의 값을 검색 값으로 4를 초기값으로 설정한다.
- 상단 2중 for 문에서 i와 j를 곱한 값을 arr 배열에 대입한다.
    
    
    | i | j | arr |
    | --- | --- | --- |
    | 0 | 0 | 0 |
    | 0 | 1 | 0 |
    | 0 | 2 | 0 |
    | 0 | 3 | 0 |
    | 0 | 4 | 0 |
    | 1 | 0 | 0 |
    | 1 | 1 | 1 |
    | 1 | 2 | 2 |
    | 1 | 3 | 3 |
    | 1 | 4 | 4 |
- 하단 2중 for 문에서 arr[i][j]와 find_num 값과 비교 후 값이 같을 경우 화면에 ‘arr[1][4]=4’를 출력한다.

---

Q. White-box Test란 무엇인지 서술하시오.

> 화이트박스 테스트는 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트 방식으로 소스코드를 보면서 테스트 케이스를 다양하게 만들어 테스트를 수행하는 기법이다.
> 

- 공통 모듈 테스트의 종류는 다음과 같다.
    - 화이트박스 테스트
        - 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트 방식으로 소스 코드를 보면서 테스트 케이스를 다양하게 만들어 테스트를 수행
    - 메서드 기반 테스트
        - 공통 모듈의 외부에 공개된 메서드 기반의 테스트
        - 메서드에 서로 다른 파라미터 값을 호출하면서 다양한 테스트를 수행
    - 화면 기반 테스트
        - 사용자용 화면이 있는 경우, 각각의 화면단위로 단위모듈을 개발 후에 화면에 직접 데이터를 입력하여 테스트를 수행
        - 화면기반 테스트는 화면과 연계된 서비스, 비지니스 컴포넌트 및 공통 컴포넌트를 한꺼번에 단위 테스트에 참여
    - 테스트 드라이버(Driver)/ 테스트 스텁(Stub)
        - 기능을 테스트할 수 있는 화면 또는 하위 모듈이 구현되지 않은 경우 테스트 드라이버, 테스트 스텁을 통해 테스트를 수행
            - 테스트 드라이버: 하위 모듈은 있지만, 상위 모듈은 없는 경우 사용하는 기법
            - 테스트 스텁: 상위 모듈은 있지만, 하위 모듈은 없는 경우 사용하는 기법

---

Q. 다음 [점수] 테이블에 대해 SQL을 수행한 결과는 [결과] 테이블처럼 출력된다. [결과] 테이블의 ①, ②에 알맞은 값을 쓰시오.

> 20, 10
> 

[점수]

| 이름 | DB | 프로그래밍 |
| --- | --- | --- |
| 이완용 | 20 | NULL |
| 송병준 | NULL | 30 |
| 민영휘 | NULL | 10 |

[쿼리]

```sql
SELECT MIN(DB), MIN(프로그래밍) FROM 점수; 
```

[결과]

| MIN(DB) | MIN(프로그래밍) |
| --- | --- |
| ( ① ) | ( ② ) |

- 집계 함수는 NUL인 값은 제외하고 계산한다.
- 집계 함수의 종류는 다음과 같다.
    
    
    | 집계 함수 | 내용 |
    | --- | --- |
    | COUNT | 복수 행의 줄 수 |
    | SUM | 복수 행의 해당 컬럼 간의 합계 |
    | AVG | 복수 행의 해당 컬럼 간의 평균 |
    | MAX | 복수 행의 해당 컬럼 중 최댓값 |
    | MIN | 복수 행의 해당 컬럼 중 최솟값 |
    | STDDEV | 복수 행의 해당 컬럼 간의 표준편차 |
    | VARIANCE | 복수 행의 해당 컬럼 간의 분산 |

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 3030
> 

```c
#include <stdio.h>
void main() {
	int a = 10;
	int *p = &a;
	a = 30;
	printf("%d%d\n", a, *p); 
}
```

- 정수형 변수 a를 선언하고 10으로 초기화한다.
- **정수 포인터형 변수 p**를 선언하고, **a의 주솟값**을 대입한다.
- a는 30을 대입한다.
- a 값과 **p가 가리키고 있는 값**을 화면에 출력하면 3030이 출력된다.

---

Q. 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스로 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴은 무엇인가?

> 비지터(Visitor) 패턴
> 

- 디자인 패턴 중 행위 패턴은 다음과 같다.
    - Mediator(중재자)
        - 객체지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체지향에서 가장 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체지향 목표를 달성하게 해주는 디자인 패턴
        - 상호작용의 유연한 변경을 지원
    - Interpreter(인터프리터)
        - 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴
        - 문법 자체를 캡슐화하여 사용
    - Iterator(반복자)
        - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴
        - 내부 구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴
    - Template Method(템플릿 메소드)
        - 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴으로 일반적으로 상위 클래스(추상 클래스)에는 추상 메서드를 통해 기능의 골격을 제공하고, 하위 클래스(구체 클래스)의 메서드에는 세부 처리를 구체화하는 방식으로 사용하며 코드 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 디자인 패턴
        - 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행
    - Observer(옵서버)
        - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대다의 의존성을 가지며 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴
        - 객체의 상태 변화에 따라 다른 객체의() 상태도 연동, 일대다 의존
    - State(상태)
        - 객체의 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시 코드의 수정을 최소화할 수 있고, 유지보수의 편의성도 갖는 디자인 패턴
        - 객체의 상태에 따라 행위 내용을 변경
    - Visitor(방문자)
        - 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴
        - 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위
    - Command(커맨드)
        - 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴으로 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴
        - 요구사항을 객체로 캡슐화
    - Strategy(전략)
        - 알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환
    - Memento(메멘토)
        - 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴으로 Undo 기능을 개발할 때 사용하는 디자인ㅇ 패턴
        - 객체를 이전 상태로 복구시켜야 하는 경우, ‘작업취소(Undo)’ 요청 가능
    - Chain of Responsibility
        - 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴
        - 한 요청을 2개 이상의 객체에서 처리

---

Q. 데이터베이스 이상 현상 3가지를 쓰시오.

> 삽입 이상, 삭제 이상, 갱신 이상
> 

- 이상 현상은 데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적인 현상이다.
- 데이터베이스 이상 현상은 다음과 같다. **[삽삭갱]**
    - 삽입 이상(Insertion Anomaly): 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우
    - 삭제 이상(Deletion Anomaly): 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
    - 갱신 이상(Update Anomaly): 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

- **이상(Anomaly)**
    - 이상이란 테이블에서 **일부 속성들의 종속**으로 인해 **데이터의 중복이 발생**하고, 이 중복(Redundancy)으로 인해 **테이블 조작 시 문제가 발생하는 현상**을 의미함
    - 이상의 종류에는 테이블 조작 중에 발생하는 삽입 이상(Insertion Anomaly), 삭제 이상(Deletion Anomaly), 갱신 이상(Update Anomaly)이 있음

- **삽입 이상(Insertion Anomaly)** : 테이블에 데이터를 삽입할 때 의도와는 상관 없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상
- 예) <수강> 테이블에서 학번이 "600"인 학생의 학년이 "2'라 는 사실만을 삽입하고자 하는 경우, 삽입 이상이 발생함

![이미지](/assets/img/exam/21/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_21%ED%9A%8C(4).png)

- **삭제 이상(Deletion Anomaly)** : 테이블에서 **한 튜플을 삭제할 때 의도와는 상관없는 값**들도 함께 삭제되는, **즉 연쇄 삭제가 발생하는 현상**
- 예) <수강> 테이블에서 학번이 "200“인 학생이 과목번호 “C123”의 등록을 취소하고자 하는 경우 삭제 이상이 발생함
    
    ![이미지](/assets/img/exam/21/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_21%ED%9A%8C(5).png)
    

- **갱신 이상(Update Anomaly)** : 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성(Inconsistency)이 생기는 현상
- 예) <수강> 테이블에서 학번이 "400"인 학생의 학년을 "4"에 서 “3"으로 변경하고자 하는 경우 갱신 이상이 발생할 수 있음

![이미지](/assets/img/exam/21/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_21%ED%9A%8C(6).png)

---

Q. 리팩토링(Refactoring)의 개념에 대해서 서술하시오.

> 리팩토링은 유지보수 생산성 향상을 목적으로 기능을 변경하지 않고, 복잡한 소스 코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법이다.
> 

- 리팩토링은 소프트웨어 모듈의 외부적 기능은 수정하지 않고 내부적으로 구조, 관계 등을 단순화하여 소프트웨어의 유지보수성을 향상시키는 기법이다.
- 리팩토링의 목적은 다음과 같다.
    
    
    | 유형 | 설명 |
    | --- | --- |
    | 유지보수성 향상 | 복잡한 코드의 단순화, 소스의 가독성 향상 |
    | 유연한 시스템 | 소프트웨어 요구사항 변경에 유연한 대응 |
    | 생산성 향상 | 정제 및 최적화된 소스의 재사용 |
    | 품질향상 | 소프트웨어 오류발견이 용이하여 품질향상 |

---

Q. ()은/는 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 정렬되지 않은 부분의 가장 앞의 데이터와 교환해나가는 방식으로 주어진 리스트 중에서 최솟값(또는 최댓값)을 찾고 그 값을 맨 앞에 위치한 값과 교체함으로써 정렬을 완성하는 알고리즘이다. () 안에 들어갈 알고리즘은 무엇인가?

> 선택 정렬(Selection Sort)
> 

- 선택 정렬(Selection Sort)은 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 정렬되지 않은 부분의 가장 앞의 데이터와 교환해나가는 방식으로 주어진 리스트 중에서 최솟값(또는 최댓값)을 찾고 그 값을 맨 앞에 위치한 값과 교체함으로써 정렬을 완성하는 알고리즘이다.

---

Q. 다음은 [상품]과 [가격] 테이블이다. [상품]과 [가격] 테이블을 조인하여 [결과] 테이블처럼 나오도록 쿼리를 작성하시오.

```sql
SELECT **B.**상품코드 AS 상품코드, A.상품명 AS 상품명, B.상품가격 AS 상품가격
FROM 상품 A
RIGHT [OUTER] JOIN 가격 B
**ON** A.상품코드 = B.상품코드;
```

[상품]

| 상품코드 | 상품명 |
| --- | --- |
| 100 | 딸기 |
| 101 | 망고 |
| 102 | 홍시 |
| 103 | 단감 |
| 106 | 망고스틴 |
| 107 | 포도 |

[가격]

| 상품코드 | 상품가격 |
| --- | --- |
| 100 | 7000 |
| 101 | 10000 |
| 103 | 3000 |
| 106 | 15000 |
| 108 | 2000 |

[결과]

| 상품코드 | 상품명 | 상품가격 |
| --- | --- | --- |
| 100 | 딸기 | 7000 |
| 101 | 망고 | 10000 |
| 103 | 단감 | 3000 |
| 106 | 망고스틴 | 15000 |
| 108 | NULL | 2000 |

- 외부 조인의 종류로는 왼쪽 외부 조인, 오른쪽 외부 조인, 완전 외부 조인이 있다.
    
    
    | 종류 | 설명 |
    | --- | --- |
    | 왼쪽 외부 조인(Left Outer Join) | 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출 |
    | 오른쪽 외부 조인(Right Outer Join) | 오른쪽 테이블의 모든 데이터와 왼쪽테이블의 동일 데이터를 추출 |
    | 완전 외부 조인(Full Outer Join) | 양쪽의 모든 데이터를 추출 |

- 오른쪽 테이블인 [가격] 테이블의 ‘상품가격’에 해당하는 값이 왼쪽 테이블인 [상품] 테이블에 있을 경우 값을 조인하고, 그렇지 않으면 NULL 값으로 되어 있는 것을 보면 오른쪽 외부 조인(Right Outer Join)임을 알 수 있다.
- 오른쪽 외부 조인 문법은 다름과 같다.
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ...
    FROM 테이블1 A 
    RIGHT [OUTER] JOIN 테이블2 B
    ON 조인조건
    [WHERE 검색조건];
    ```
    

---

Q. 양자 통신을 위해 비밀키를 분배화여 관리하는 기술로 키 분배를 위해 얽힘 상태 광자 또는 단일 광자를 이용하는 기술을 무엇이라고 하는가?

> 양자 키 분배(QKD; Quantum Key Distribution)
> 

- 양자 키 분배(Quantum Key Distribution)는 양자 통신을 위해 비밀키를 분배하여 관리하는 기술로 키 분배를 위해 얽힘 상태 광자 또는 단일 광자를 이용하는 기술이다.

---

Q. 빅데이터를 저장할 수 있는 DBMS 중에서 ( ① )은/는 전통적인 RDBMS와 다른 DBMS를 지칭하기 위한 용어로 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인(Join) 연산을 사용할 수 없으며, 수평적으로 확장이 가능한 데이터베이스이다. 또한 ( ① ) 유형 중에서 ( ② )은/는 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 데이터베이스이다. () 안에 들어갈 용어를 쓰시오.

> NoSQL(Not Only SQL), 그래프 스토어(Graph Store)
> 

- NoSQL 유형은 다음과 같다.
    - Key-Value Store
        - 키 기반 Get / Put / Delete 제공, 메모리 기반에서 성능 우선 시스템 및 빅데이터 처리 기능 DB
        - Unique한 Key에 하나의 Value를 가지고 있는 형태
        - 예: Redis, DynamoDB
    - Column Family Data Store
        - Key 안에 (Column, Value) 조합으로 된 여러 개의 필드를 갖는 DB
        - 테이블 기반, 조인 미지원, 컬럼 기반으로 구글의 Bigtable 기반으로 구현
        - 예: HBase, Cassandra
    - Document Store
        - Value의 테이터 타입이 Document라는 타입을 사용하는 DB
        - Document 타입은 XML, JSON, YAML과 같이 구조화된 데이터 타입으로, 복잡한 계층 구조를 표현할 수 있음
        - 예: MongoDB, Couchbase
    - Graph Store
        - 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 DB

- 시멘틱 웹(Semantic Web)과 온톨로지(Ontology)는 다음과 같다.

| 기술 | 설명 |
| --- | --- |
| 시맨틱 웹(Semantic Web) | 인터넷과 같은 분산 환경에서 리소스에 대한 정보와 자원 사이의 관계-의미 정보를 기계(컴퓨터)가 처리할 수 있는 온톨로지 형태로 표현하고, 이를 자동화된 기계(컴퓨터)가 처리하도록 하는 지능형 웹 |
| 온톨로지(Ontology) | 실세계에 존재하는 모든 개념과 개념들의 속성, 그리고 개념 간의 관계 정보를 컴퓨터가 이해할 수 있도록 서술해 놓은 개념화 명세서 |

---

Q. 소프트웨어 아키텍처 비용 평가 모델의 종류 중 ( ① )은/는 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가하는 모델이고, ( ② )은/는 ( ① ) 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델이다. 또한 ( ③ )은/는 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델이다. () 안에 들어갈 소프트웨어 아키텍처 비용 평가 모델의 종류를 쓰시오.

> ATAM(Architecture Trade-off Analysis Method), CBAM(Cost Benefit Analysis Method), ADR(Active Design Review)
> 

- 소프트웨어 아키텍처 비용 평가 모델의 종류는 다음과 같다.
    - SAAM(Software Architecture Analysis Method)
        - 변경 용이성과 기능성에 집중, 평가가 용이하여 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
    - ATAM(Architecture Trade-off Analysis Method)
        - 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가하는 모델
    - CBAM(Cost Benefit Analysis Method)
        - ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
    - ADR(Active Design Review)
        - 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
    - ARID(Active Reviews for Intermediate Designs)
        - 전체 아키텍처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 90
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int[] num = {50, 40, 60, 88, 90}
		int m = num[0];
		for(int var : num) {
			if(m < var) {
				m = var;
			}
		}
		System.out.print(m);
	}
}
```

- num은 1차원 정수형 배열로 50, 40, 60, 88, 90을 가진다.
- 정수형 변수 m은 선언하고 num의 가장 앞에 있는 50을 대입한다.
- for 반복문은 배열의 값을 첫 번째부터 마지막까지 반복하면서 m보다 var가 크면 var를 m에 대입한다.
- for 반복문이 종료되고 m을 System.out.print 메서드를 이용하여 화면에 90을 출력한다.


<br>
**참고 자료**

---

- [https://learn.microsoft.com/ko-kr/sql/t-sql/language-elements/wildcard-character-s-to-match-transact-sql?view=sql-server-ver16 - 와일드 카드](https://learn.microsoft.com/ko-kr/sql/t-sql/language-elements/wildcard-character-s-to-match-transact-sql?view=sql-server-ver16) ****
- [https://m.blog.naver.com/hsoojy_/221761702264 - 와일드 카드 예제](https://m.blog.naver.com/hsoojy_/221761702264)