---
categories: [Certificate, "[정보처리기사] 모의고사(01~35회)"]
---

Q. 다음이 설명하는 통신 기술은 무엇인가?

> NFC(Near Field Communication)
> 
- 13.56MHz 주파수를 사용하고, 424bps의 속도로 데이터를 전송하는 RFID의 확장 기술로, 10cm 이내에서 저전력, 비접촉식 무선 통신 기술
- 고주파(HF)를 이용하는 ISO/IEC 18092 표준으로 아주 가까운 거리에서 양방향 통신을 지원

---

Q. ()은/는 기업 간 수주, 발주, 수송, 결제 등 상업 거래를 위한 자료를 데이터 통신 회선을 통해 표준화된 포맷, 규약에 따라 컴퓨터 간에 온라인으로 전달하는 방식을 말한다. () 안에 들어갈 용어를 쓰시오.

> EDI(Electronic Data Interchange) 또는 전자 문서 교환
> 

- 기업 간 수주, 발주, 수송, 결제 등 상업 거래를 위한 자료를 데이터 통신 회선을 통해 표준화된 포맷, 규약에 따라 컴퓨터 간에 온라인으로 전달하는 방식은 EDI이다.

---

Q. 다음은 빅데이터 아키텍처에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 람다 아키텍처(Lamda Architecture), 카파 아키텍처(Kappa Architecture)
> 

( ① )은/는 데이터 분석 요청 시 모든 데이터를 대상으로 기능을 수행할 수 있도록 배치 레이어, 스피드 레이어, 서빙 레이어로 구성된 아키텍처이고, ( ② )은/는 중복 기능을 제공하는 배치 레이어를 제거하고 모든 계산을 스피드 레이어에서 스트림으로 처리하는 아키텍처이다.

- 빅데이터 아키텍처인 람다 아키텍처와 카파 아키텍처의 설명은 다음과 같다.
    
    
    | 용어 | 설명 |
    | --- | --- |
    | 람다 아키텍처(Lamda) | 데이터 분석 요청 시 모든 데이터를 대상으로 기능을 수행할 있도록 배치 레이어, 스피드 레이어, 서빙 레이어로 구성된 아키텍처 |
    | 카파 아키텍처(Kappa) | 중복 기능을 제공하는 배치 레이어를 제거하고 모든 계산을 스피드 레이어에서 스트림으로 처리하는 아키텍처 |

---

Q. 소프트웨어 개발 보안 용어 중 ( ① )은/는 조직이나 기업의 자산에 악영향을 끼칠 수 있는 사건이나 행위를 말하고, ( ② )은/는 ( ① )이/가 취약점을 이용하여 조직의 자산 손실 피해를 가져올 가능성을 말한다. () 안에 들어갈 용어를 쓰시오.

> 위협(Threat), 위험(Risk)
> 

- 소프트웨어 개발 보안 용어는 다음과 같다.
    - 자산(Assets)
        - 조직의 데이터 또는 조직의 소유자가 가치를 부여한 대상
        - 예: 서버의 하드웨어, 기업의 중요 데이터
    - 위협(Threat)
        - 조직이나 기업의 자산에 악영향을 끼칠 수 있는 사건이나 행위
        - 예: 해킹, 삭제, 자산의 불법적인 유출, 위/변조, 파손
    - 취약점(Vulnerability)
        - 위협이 발생하기 위한 사전 조건으로 시스템의 정보 보증을 낮추는데 사용되는 약점
    - 위험(Risk)
        - 위협이 취약점을 이용하여 조직의 자산 손실 피해를 가져올 가능성

---

Q. 다음 중 [정처기] 테이블에서 필기 점수 NULL이 아닌 ‘수험자명’을 출력하는 쿼리를 작성하시오.

```sql
SELECT 수험자명 
FROM 정처기
WHERE 필기 IS NOT NULL;
```

[정처기]

| 수험자명 | 필기 | 실기 |
| --- | --- | --- |
| 엑소 | 80 | NULL |
| BTS | NULL | 100 |
| 세븐틴 | NULL | NULL |
| 비투비 | 80 | 70 |

[결과]

| 수험자명 |
| --- |
| 엑소 |
| 비투비 |

- WHERE절 조건에서는 비교, 범위, 집합, 패턴, NULL, 복합조건이 있고, NULL이 아닌 값을 찾을 때는 IS NOT NULL 문법을 사용한다.
- IS NOT NULL 문법은 다음과 같다.
    
    ```sql
    컬럼 IS NOT NULL
    ```
    

---

Q. **다음은 C언어 코드이다. 출력 결과를 쓰시오.**

> so
> 

```c
#include <stdio.h>
void main() {
	char *p = "soojebi";
	int i;
	
	for(i=0; i<2; i++) {
		printf("%c", *(p+i));
	}
}
```

- char* 형 포인터 변수 p를 선언과 동시에 문자열 “soojebi”로 초기화한다.
- for 문에서 사용하기 위해 정수형 변수 i를 선언한다.
- for 반복문은 i값이 0부터 2보다 작을 때까지 1씩 증가하며 반복한다.
- printf 함수에서 *(p+i) 값을 화면에 출력한다.
    
    
    | *(p+0) | *(p+1) | *(p+2) | *(p+3) | *(p+4) | *(p+5) | *(p+6) |
    | --- | --- | --- | --- | --- | --- | --- |
    | s | o | o | j | e | b | i |
- 포인터 변수를 선언할 때 char* p와 char *p는 아무런 차이가 없다.

---

Q. TCP 프로토콜의 구조적인 문제를 이용한 공격으로 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유함으로써 다른 사용자가 서버를 사용 불가능하게 하는 공격은 무엇인가?

> SYN 플러딩(SYN Flooding)
> 

- SYN 플러딩은 DoS의 유형으로 TCP 프로토콜의 구조적인 문제를 이용한 공격으로, 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유함으로써 다른 사용자가 서버를 사용 불가능하게 하는 공격이다.
- 공격자는 ACK를 발송하지 않고 계속 새로운 연결 요청을 하게 되어 서버는 자원할당을 해지하지 않고 자원만 소비하여 고갈된다.

![이미지](/assets/img/exam/29/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_29%ED%9A%8C(1).png)

---

Q. 테스트 목적에 따른 분류 중 ( ① )은/는 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법이고, ( ② )은/는 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법이다. 또한 ( ③ )은/는 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법이다. () 안에 들어갈 테스트 기법을 쓰시오.

> 회복 테스트(Recovery Testing), 안전 테스트(Security Testing), 회귀 테스트(Regression Testing)
> 

- 테스트 목적에 따른 분류는 다음과 같다.
    
    
    | 분류 | 설명 |
    | --- | --- |
    | 회복 테스트(Recovery Testing) | 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법 |
    | 안전 테스트(Security Testing) | 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법 |
    | 성능 테스트(Performance Testing) | 사용자의 이벤트에 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법 |
    | 구조 테스트(Structure Testing) | 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법 |
    | 회귀 테스트(Regresssion Testing) | 회귀 테스트는 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법 |
    | 병행 테스트(Parallel Testing) | 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법 |

---

Q. 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL은 무엇인가?

> 트리거(Trigger)
> 

- 절차형 SQL은 프로시저, 사용자 정의함수, 트리거가 있다.
    
    
    | 종류 | 설명 |
    | --- | --- |
    | 프로시저(Procedure) | 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합 |
    | 사용자 정의 함수(User-Defined Function) | 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL |
    | 트리거(Trigger) | 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL |

---

Q. 다음은 [사전] 테이블이다. [결과] 테이블처럼 ‘sy’로 시작되고, ‘m’으로 끝나는 문자열을 찾기 위한 쿼리를 작성하시오.

```sql
SELECT 단어, 뜻
FROM 사전
WHERE 단어 LIKE 'sy%m';
```

```sql
SELECT *
FROM 사전
WHERE 단어 LIKE 'sy%m';
```

[사전]

| 단어 | 뜻 |
| --- | --- |
| system | 체계 |
| symbol | 상징 |
| symmetry | 대칭 |

[결과]

| 단어 | 뜻 |
| --- | --- |
| system | 체계 |

- LIKE 문법은 다음과 같다.
    
    ```sql
    컬럼 LIKE 패턴
    ```
    

---

Q. Dos 공격 기법 중 랜드 어택(Land Attack) 공격의 개념에 대하여 서술하시오.

> 랜드 어택은 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보냄으로써 수신자가 자기 자신에게 응답을 보내게 하여 시스템의 가용성을 침해하는 공격 기법이다.
> 

- 랜드 어택은 DoS의 유형으로 출발지 IP와 목적지 IP를 같은 패킷 주소로 전송하여 공격 대상의 루프를 유발하여 가용성을 침해하는 공격이다.

![이미지](/assets/img/exam/29/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_29%ED%9A%8C(2).png)

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> 20
> 

```python
sum=0
i=1
num=4
while(i<=num):
	j=1
	while(j<=i):
		sum+=j
		j+=1
	i+=1

print(sum)
```

- sum은 0, i는 1, num은 4로 초기화 한다.
- 바깥쪽 while 반복문에서 i 값이 num보다 작거나 같을 때까지 반복한다.
- j에 1을 대입한다. 안쪽의 while 문은 j 값이 i보다 작거나 같을 때까지 반복한다. sum 값과 j 값을 더한 값을 sum에 대입한다. j+=1에서 j 값을 1 증가시키고 다음 반복을 수행한다.
- 안쪽 while 문 반복이 종료되고 i+=1에서 i 값을 1 증가시키고 바깥쪽 while 문의 반복을 수행한다.
- i, j, sum 값은 다음과 같이 변화한다.
    
    
    | i | 1 | 2 | 2 | 3 | 3 | 3 | 4 | 4 | 4 | 4 |
    | j | 1 | 1 | 2 | 1 | 2 | 3 | 1 | 2 | 3 | 4 |
    | sum | 1 | 2 | 4 | 5 | 7 | 10 | 11 | 13 | 16 | 20 |

---

Q. XP의 12가지 기본 원리 중 테스트 기반 개발(TDD; Test Driven Development)에 대해서 서술하시오.

> 테스트 기반 개발은 작성해야 하는 프로그램에 대한 테스트를 먼저 수행하고 테스트를 통과할 수 있도록 실제 프로그램의 코드를 작성한다는 원리이다.
> 

- XP의 12가지 기본 원리는 다음과 같다.
    
    
    | 기본 원리 | 설명 |
    | --- | --- |
    | 짝 프로그래밍(Pair Programming) | 개발자 둘이서 짝으로 코딩하는 원리 |
    | 공동 코드 소유(Collective Ownership) | 시스템에 있는 코드는 누구든지 언제나 수정 가능하다는 원리 |
    | 지속적인 통합(CI; Continuous Integration) | 매일 여러 번씩 소프트웨어를 통합하고 빌드해야 한다는 원리 |
    | 계획 세우기(Planning Process) | 고객이 요구하는 비지니스 가치를 정의하고, 개발자가 필요한 것은 무엇이며 어떤 부분에서 지연될 수 있는지를 알려주어야 한다는 원리 |
    | 작은 릴리즈(Small Release) | 작은 시스템을 먼저 만들고, 짧은 단위로 업데이트한다는 원리 |
    | 메타포어(Metaphor) | 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자 간의 의사소통을 원활하게 한다는 원리 |
    | 간단한 디자인(Simple Design) | 현재의 요구사항에 적합한 가장 단순한 시스템을 설계한다는 원리 |
    | 테스트 기반 개발(TDD; Test Driven Development) | 작성해야 하는 프로그램에 대한 테스트를 먼저 수행하고 이 테스트를 통과할 수 있도록 실제 프로그램의 코드를 작성한다는 원리 |
    | 리팩토링(Refactoring) | 프로그램의 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 시스템을 재구성한다는 원리 |
    | 40시간 작업(40-Hour Work) | 개발자가 피곤으로 인해 실수하지 않도록 일주일에 40시간 이상을 일하지 말아야 한다는 원리 |
    | 고객 상주(On Site Customer) | 개발자들의 질문에 즉각 대답해 줄 수 있는 고객을 프로젝트에 풀타임으로 상주시켜야 한다는 원리 |
    | 코드 표준(Coding Standard) | 효과적인 공동 작업을 위해서는 모든 코드에 대한 코딩 표준을 정의해야 한다는 원리 |
    

---

Q. 샘플링 오라클(Sampling Oracle)이 무엇인지 서술하시오.

> 샘플링 오라클은 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클이다.
> 

- 테스트 오라클의 종류는 다음과 같다. **[참샘휴일]**
    
    
    | 유형 | 설명 |
    | --- | --- |
    | 참(True) 오라클  | 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수 있는 오라클 |
    | 샘플링(Sampling) 오라클 | 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클 |
    | 휴리스틱(Heuristic) 오라클 | 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클 |
    | 일관성 검사(Consistent) 오라클 | 애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인하는 오라클 |

---

Q. 다음 중 [기숙사점수] 테이블이 [결과] 테이블과 같도록 쿼리를 작성하시오. (학점에 대해 내림차순으로 정렬하고, 학점이 같은 경우 벌점에 대해 오름차순으로 정렬하시오.)

```sql
SELECT *
FROM 기숙사점수
ORDER BY 학점 DESC, 벌점 ASC;
```

[기숙사점수]

| 학번 | 학점 | 벌점 |
| --- | --- | --- |
| 202101 | 3.7 | 20 |
| 202102 | 3.7 | 40 |
| 202103 | 4.0 | 10 |
| 202104 | 4.0 | 50 |

[결과]

| 학번 | 학점 | 벌점 |
| --- | --- | --- |
| 202103 | 4.0 | 10 |
| 202104 | 4.0 | 50 |
| 202101 | 3.7 | 20 |
| 202102 | 3.7 | 50 |

- ORDER BY절은 속성값을 정렬하고자 할 때 사용한다.
- 속성값을 정렬하고자 할 때(ASC; 오름차순, DESC; 내림차순, ASC, DESC 키워드 생략 시 오름차순 정렬)

---

Q. 고립화 수준의 종류 중에서 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근을 제한하는 수준은 무엇인가?

> Serializable Read
> 

- 고립화 수준의 종류는 다음과 같다.
    - Read Uncommitted
        - 한 트랜잭션에서 연산(갱신) 중인(아직 커밋되지 않은) 데이터를 다른 트랜잭션이 읽는 것을 허용하는 수준
        - 연산(갱신) 중인 데이터에 대한 연산은 불허
    - Read Committed
        - 한 트랜잭션에서 연산(갱신)을 수행할 때, 연산이 완료될 때까지 연산 대상 데이터에 대한 읽기를 제한하는 수준
        - 연산이 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용
    - Repeatable Read
        - 선행 트랜잭션이 특정 데이터를 읽을때, 트랜잭션 종료 시까지 해당 데이터에 대한 갱신∙삭제를 제한하는 수준
    - Serializable Read
        - 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근을 제한하는 수준

---

맥케이브 회전 복잡도(Macabe Cyclomatic Complexity)란 무엇인지 서술하시오.

맥케이브 회전 복잡도는 소프트웨어의 제어 흐름을 그래프로 표현하고 소스코드의 복잡도를 노드 수와 간선 수의 계산을 통해 정량적으로 나타내는 지표이다.

- 맥케이브 회전 복잡도 측정 방식은 제어 흐름에 의한 그래프를 통하여 원시 코드의 회전수를 구하여 복잡도를 계산한다.
- 맥케이브 회전 복잡도 계산식은 다음과 같다.
    
    
    | V(G) = E - N + 2 | 복잡도 V(G)는 노드(N) 수와 간선(E) 수로 계산 |
    | V(G) = P + 1 | 복잡도 V(G)는 조건 분기문(P)의 수로 계산 |

---

Q. 다음은 콘텐츠 보안과 관련된 내용이다. () 안에 들어갈 올바른 용어를 쓰시오.

> DRM(Digital Right Management)
> 

()은/는 디지털 콘텐츠에 대한 권리정보를 지정하고 암호화 기술을 이용하여 허가된 사용자의 허가된 권한 범위 내에서 콘텐츠의 이용이 가능하도록 통제하는 기술 및 시스템이다.

- 콘텐츠 보안 관련 기술 및 시스템은 다음과 같다.
    
    
    | 기술 | 설명 |
    | --- | --- |
    | DLP(Data Loss Prevention) | 조직 내부의 중요 자료가 외부로 빠져나가는 것을 탐지하고 차단하는 시스템으로 정보 유출 방지를 위해 정보의 흐름에 대한 모니터링과 실시간 차단 기능을 제공 |
    | DRM(Digital Right Management) | 디지털 콘텐츠에 대한 권리정보를 저장하고 암호화 기술을 이용하여 허가된 사용자의 허가된 권한 범위 내에서 콘텐츠의 이용이 가능하도록 통제하는 기술 및 시스템 |

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> hel
> 

```c
#include <stdio.h>
void main() {
	char *p = "hello";
	int i;
	
	for(i=0; i<3; i++) {
		printf("%c", *p++);
	}
}
```

- char* 형 포인터 변수 p를 선언과 동시에 문자열 “hello”로 초기화한다.
- for 문에서 사용하기 위해 정수형 변수 i를 선언한다.
- ***p에서 값을 출력하고 ++ 연산자가 실행**되어 다음 문자를 출력한다.

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 0
> 

```java
class Parent {
	int compute(int num) {
		if(num <= 1) {
			return num;
		}
		return compute(num-1);
	}
}
class Child extends Parent {
	int compute(int num) {
		if(num <= 1) {
			return num;
		}
		return compute(num-2);
	}
}
public class Soojebi {
	public static void main(String[] args) {
		Parent obj = new Child();
		System.out.print(obj.compute(4));
	}
}
```

- Parent obj = new Child(); 문장에서 Child 클래스의 생성자를 호출하고 객체 obj를 생성한다.
- System.out.print(obj.compute(4)); 문장에서 obj.compute(4)를 호출한다.
- obj.compute(4)는 Child 클래스의 멤버 메서드인 compute(int num)를 호출한다. 파라미터 num을 이용하여 정수 4를 전달하여 num 값이 1보다 작거나 같으면 num 값을 리턴한다.
- compute(num-2); 문장에서 num 값에서 2를 뺀 값을 파라미터로 전달하여 **compute 멤버 메서드를 재귀호출**한다. 파라미터로 4를 전달하였기 때문에 2를 뺀 comput(2); 가 호출된다. compute(2)에서 2는 1보다 크므로 다시 2를 뺀 compute(0)을 호출한다.
- compute(0)은 1보다 작거나 같으므로 if문이 참이 되어 실행되어 **num 값인 0을 리턴하고, 그 값인 0을 출력**하게 된다.