---
categories: [Certificate, "[정보처리기사] 기출문제(20~23년)"]
---

Q. 다음은 관계 데이터 모델과 관련된 설명이다. () 안에 공통적으로 들어갈 용어를 쓰시오.

> 관계 해석
> 
- ()은/는 관계 데이터베이스에 대한 비절차적 언어이며, 수학의 Predicate Calculus에 기반을 두고 있다.
- Codd 박사에 의하여 제시되었으며, 튜플(), 도메인()이/가 있다.

---

Q. 다음은 블록 암호화 알고리즘에 대한 설명이다. () 안에 들어갈 암호화 알고리즘을 쓰시오.

> ① IDEA ② Skipjack
> 
- Xuejia Lai와 James Messey가 초기에 제시한 블록 암호화 알고리즘으로 PES, IPES를 거쳐  ( ① )로 명명되었다. ( ② )은/는 128bit의 키를 사용하여 64bit의 평문을 8라운드에 거쳐 64bit의 암호문을 만든다.
- ( ② )은/는 미 안보국(NSA, National Security Agency)에서 개발한 Cliper 칩에 내장된 블록 알고리즘으로, 소프트웨어로 구현되는는 것을 막고자 Fortezza Card에 칩 형태로 구현되었으며 전화기와 같이 음성을 암호화하는 데 주로 사용된다. 64비트의 입출력, 80비트의 키, 총 32라운드를 가진다.

- IDEA(International Data Encryption Algorithm)
    - IDEA는 스위스에서 1990년 Xuejia Lai와 James Messey가 만든 PES(Proposed Encryption Standard), IPES(Improved Proposed Encryption Standard)를 개량하여, 1991년 제작된 블록 암호 알고리즘
    - IDEA는 128bit의 키를 사용하여 64bit의 평문을 8라운드에 거쳐 64bit의 암호문을 만든다.
- Skipjack
    - 미 안보국(NSA, National Security Agency)에서 개발한 Cliper 칩에 내장된 블록 알고리즘으로, 소프트웨어로 구현되는는 것을 막고자 Fortezza Card에 칩 형태로 구현됨
    - 전화기와 같이 음성을 암호화하는 데 주로 사용되고 64비트의 입출력, 80비트의 키, 총 32라운드를 가진다.

---

Q. **다음 복수의 행을 출력하는 SQL 문을 사용하여 제품 테이블에서 H라는 제조사의 모든 제품의 단가보다 비싼 단가의 상품명, 단가, 제조사를 출력하는 SQL 구문이다. ()에 들어갈 내용은?**

ALL

```sql
SELECT 상품명, 단가, 제조사
FROM 제품
WHERE 단가 > ( ) (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
```

- **다중 행 연산자**로 **IN, ANY, SOME, ALL, EXISTS**를 사용한다.
- 다중 행 비교 연산자는 단일 행 비교 연산자(`<`, `>`, `=`, `<>`)와 결합하여 사용할 수 있다.
- 서브 쿼리로 도출된 모든 값이 조건을 만족해야 하므로 ALL 연산자를 사용한다.

| 연산자 | 설명 |
| --- | --- |
| IN | 리턴되는 값 중에서 조건에 해당하는 값이 있으면 참 |
| ANY | 서브쿼리에 의해 리턴되는 각각의 값과 조건을 비교하여 하나 이상을 만족하면 참 |
| ALL | 값을 서브쿼리에 의해 리턴되는 모든 값과 조건값을 비교하여 모든 값을 만족해야만 참 |
| EXISTS | 메인 쿼리의 비교 조건이 서브 쿼리의 결과 중에서 만족하는 값이 하나라도 존재하면 참 |

---

Q. **다음 TB 테이블에 대하여 다음 SQL을 실행하였을 때 [결과]에 출력되는 값은 무엇인가?**

> 4
> 

[TB] 테이블

| SQL | COL1 | COL2 |
| --- | --- | --- |
| 1 | 2 | NULL |
| 2 | 3 | 6 |
| 3 | NULL | 5 |
| 4 | 5 | 3 |
| 5 | 6 | 3 |

[SQL]

```sql
SELECT COUNT(COL2)
FROM TB
WHERE COL1 IN(2,3) OR COL2 IN(3,5);
```

| COUNT(COL2) |
| --- |
|  |

- COUNT는 복수 행의 줄 수를 구하는 집계함수이다.
    
    
    | COUNT(컬럼명) | NULL 값은 제외하고 COUNT |
    | COUNT(*) | NULL도 포함하여 전부 COUNT |
- COL1 IN(2, 3)의 결과를 통해 SEQ 1, 2가 선택되며, COL2 IN(3, 5)의 결과를 통해 SEQ 3, 4, 5가 선택되어 OR 연산으로 모든 행을 선택하는 결과가 된다.
- 이중 COUNT(COL2)를 통해 NULL을 제외한 COUNT인 4가 출력된다.

---

Q. () 안에 공통으로 들어간 용어를 쓰시오.

> VPN(Virtual Private Network)
> 
- 여러 공중 인터넷망을 하나의 사설망처럼 사용할 수 있는 기술로 공중망과 사설망의 중간단계이고 방식으로는 SSL과 IPSec 방식이 있다.
- SSL ()은/는 4계층에서 소프트웨어적으로 동작하므로 별도의 장치가 필요 없으며 가격이 저렴하다.
- IPSEC ()은/는 3계층에서 동작하므로 IP 헤더를 조작해야 하므로 별도의 하드웨어 장치가 필요하나 보안성이 뛰어나다.

- VPN은 인터넷과 같은 공중망에 인증, 암호화, 터널링 기술을 활용하여 마치 전용망을 사용하는 효과를 가지는 보안 솔루션이다.
- VPN은 여러 공중 인터넷망을 하나의 사설망처럼 이용할 수 있는 기술로 공중망과 사설망의 중간단계이고 방식으로는 SSL과 IPSec 방식이 있다.
    
    
    | SSL VPN | 4계층에서 소프트웨어적으로 동작하므로 별도의 장치가 필요 없으며 가격이 저렴하다. |
    | IPSec VPN | 3계층에서 동작하므로 IP 헤더를 조작해야 하므로 별도의 하드웨어 장치가 필요하나 보안성이 뛰어나다. |

---

Q. 다음은 객체지향 설계 원칙 중 다음에서 설명하는 원칙을 쓰시오.

> ISP
> 
- 객체 설계 시 특정 기능에 대한 인터페이스는 그 기능과 상관없는 부분이 변해도 영향을 받지 않아야 한다는 원칙이다.
- 예를 들어, 복합기에 대한 객체가 있고 프린터, 복사기, 스캐닝 기능을 사용하는 사용자가 각각 있다고 하면 프린터 기능 인터페이스는 복사기나 스캐닝 기능이 변하여도 프린터 기능을 사용하는 데에는 문제가 업어야 한다.

- 객체지향 설계 원칙(SOLID)는 다음과 같다.
    - 단일 책임의 원칙(SRP; Single Response Principle)
        - 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
        - 객체지향 프로그래밍의 5원칙 중 나머지 4원칙의 기초 원칙
    - 개방 폐쇄 원칙(OCP; Open Close Principle)
        - 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 원칙
    - 리스코프 치환의 원칙(LSP; Liskov Substitution Principle)
        - 서브 타입(상속받는 하위 클래스)은 어디서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 한다는 원칙
    - 인터페이스 분리의 원칙(ISP; Interface Segregation Principle)
        - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
        - 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안 된다는 원칙
    - 의존성 역전의 원칙(DIP; Dependency Inversion Principle)
        - 실제 사용관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙

---

Q. 다음 JAVA 코드의 실행 결과를 쓰시오.

> -8
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int i = 3;
		int k = 1;
		
		switch(i) {
			case 1: k += 1;
			case 2: k++;
			case 3: k = 0;
			case 4: k += 3;
			case 5: k -= 10;
			default: k--;
		}
		System.out.printf("%d", k);
	}
}
```

- 정수형 변수 i 선언 및 3 대입
- 정수형 변수 k 선언 및 1 대입
- i 값이 3이므로 case 3: 실행
- k에 0을 대입하고 break가 없으므로 default까지 실행
- k 값 -8을 출력

---

Q. **다음은 C언어 코드이다. 실행 결과를 쓰시오.**

> 2
> 

```c
#include <stdio.h>
struct student {
	int n, g;
};

int main() {
	struct student st[2];
	int i = 0;
	for(i; i<2; i++) {
		st[i].n = i;
		st[i].g = i+1;
	}
	printf("%d", st[0].n + st[1].g);
	return 0;
}
```

- 구조체 선언
- 멤버 변수 n, g 선언
- 구조체 struct의 배열 변수 st를 사이즈 2만큼 선언
- 정수형 변수 i를 0으로 초기화
- i 값을 0부터 1씩 증가하며 2까지 반복
- i 값을 st[i].n에 대입
- i+1 값을 st[i].g에 대입
- st[0].n은 0이고 st[1].g은 2이므로 0+2한 결과인 2를 화면에 출력

---

Q. 호스트 주소가 223.13.234.132이고, 서브넷 마스크는 255.255.255.192일 때, () 안에 들어가는 값을 쓰시오.

> 128, 62
> 
- 이 호스트의 네트워크 주소는 223.13.234.( ① )이다.
- 이 네트워크 주소에서 사용 가능한 호스트 주소의 개수는 네트워크 주소와 브로드캐스트 주소를 뺀 ( ② )개이다.

- IP 주소를 2진수로 바꾸면 다음과 같다.
    
    
    | 10진수 | 223.13.234.132 |
    | 2진수 | 11011111.00001101.11101010.10000100 |
- 서브넷 마스크를 2진수로 바꾸면 다음과 같다.
    
    
    | 10진수 | 255.255.255.192 |
    | 2진수 | 11111111.11111111.11111111.11000000 |
- 네트워크 주소와 서브넷 마스크를 AND 연산한 결과가 네트워크 주소이다.

![이미지](/assets/img/exam/previous/2022(2)_1.png)

- 서브넷 마스크 255.255.255.192에서 Host ID 부분인 192를 2진수로 표현하면 11000000이다.
    - Host ID에서 1인 부분
        - 상위 1개의 bit가 서브넷 ID
        - 2^2=4개의 서브넷으로 나눠짐
    - HostID에서 0인 부분
        - 하위 6개의 bit가 호스트 ID
        - 서브넷마다 사용할 수 있는 호스트 범위는 2^6=64개가 됨
        - 64개의 호스트 범위에서 모두 0이 채워진 값은 네트워크 주소라 사용할 수 없고, 모두 1이 채워진 값은 브로드캐스트 주소라 사용할 수 없음

---

Q. 다음은 테스팅에 대한 설명이다. () 안에 들어갈 올바른 답을 한 단어로 쓰시오.

> 베타, 알파
> 
- ( ① ) 테스트는 사용자의 환경에서 개발자 없이 수행하는 테스트 방법으로, 사용자 오류정보를 수집하여 개발자에게 보내면 개발자가 취합하여 오류를 수정하는 방식이다.
- ( ② ) 테스트는 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 방법으로 사용자가 프로그램을 수행하는 것을 개발자가 모니터링하여 오류를 수정한다.

- 인수 테스트 중 알파 테스트와 베타 테스트는 다음과 같다.
    - 알파 테스트
        - 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 방법으로 사용자가 프로그램을 수행하는 것을 개발자가 모니터링하여 오류를 수정한다.
    - 베타 테스트
        - 사용자의 환경에서 개발자 없이 수행하는 테스트 방법으로, 사용자 오류정보를 수집하여 개발자에게 보내면 개발자가 취합하여 오류를 수정하는 테스트

---

Q. 다음은 테스팅에 대한 설명이다. 맞는 답을 보기에서 골라서 쓰시오.

> Regression
> 
- () 테스트는 소프트웨어의 변경 사항이 발생하면 수행하는 테스트로, 주로 유지보수 단계에서 수행한다.
- 소프트웨어 수정 시 다른 오류가 흘러들어오므로 이를 확인하기 위하여 소프트웨어 변경 사항이 발생할 때마다 () 테스트를 반복적으로 수행한다.

[보기]

White Box, Boundary, Partition, Black Box, Regression, Exhaust, Iterating

- 회귀 테스트(Regression Testing)은 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법이다.
- 회귀 테스트는 소프트웨어의 변경 사항이 발생하면 수행하는 테스트로, 주로 유지보수 단계에서 수행한다.
- 소프트웨어 수정 시 다른 오류가 흘러들어오므로 이를 확인하기 위해 소프트웨어에 변경 사항이 발생할 때마다 회귀 테스트를 반복적으로 수행한다.

---

Q. 다음은 라우팅 프로토콜에 대한 설명이다. ()에 들어갈 말을 보기에서 골라 쓰시오.

> IGP, EGP, OSPF, BGP
> 
- 라우팅 프로토콜은 범위에 따라 ( ① ), ( ② )이/가 있다.
- 라우팅 프로토콜의 범위는 AS에 따라 나뉘는데 AS(Autonomous System; 자치 시스템)는 하나의 도메인에 속하는 라우터들의 집합을 말한다.
- ( ① )은/는 동일한 AS 내의 라우팅 프로토콜이며, 대표적으로 RIP와 ( ③ )이/가 있다.
- ( ③ )은/는 항상 상태를 주고받는 RIP와 다르게 변화가 있을 때만 상태를 주고받는 Linked State의 프로토콜이며 자치 시스템을 지역(Area)으로 나누어 라우팅을 효과적으로 관리할 수 있다.
- ( ② )은/는 서로 다른 AS 간 라우팅 프로토콜이며, 대표적으로 ( ④ )이/가 있으며 초기에 라우터들이 연결될 때 전체 라우팅 테이블을 교환하고, 그 이후에는 변화된 정보만을 교환하는 방식이다.

- 라우팅 프로토콜은 다음과 같다.
    - 내부 라우팅 프로토콜(IGP; Interior Gateway Protocol)
        - 동일한 AS 내의 라우팅에 사용되는 프로토콜
            - RIP(Routing Information Protocol)
                - 거리 벡터 라우팅 기반 메트릭(Metric) 정보를 인접 라우터와 주기적으로 교환하여 라우팅 테이블을 갱신하고 라우팅 테이블을 구성/계산하는 데 Bellman-Ford 알고리즘을 사용하는 내부 라우팅 프로토콜
                - 최대 홉 수(Hop Count)를 15개로 제한하고 30초마다 전체 카운팅 정보를 브로드캐스팅하는 특징이 있음
            - OSPF(Open Shortest Path First)
                - 규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선하기 위해 자신을 기준으로 링크 상태 알고리즘을 적용하여 최단 경로를 찾는 라우팅 프로토콜
                - 링크 상태 라우팅 기반 메트릭(Metric) 저옵를 한 지역(Area) 내 모든 라우터에 변경이 발생했을 때만 보내(Flooding)고 라우팅 테이블을 구성/계산하는 데 다익스트라(Dijkstra) 알고리즘을 사용하는 내부 라우팅 프로토콜
                - 홉 카운트에 제한이 없고 AS를 지역(Area)으로 나누어 라우팅을 효과적으로 관리
    - EGP(Exterior Gateway Protocol)
        - 서로 다른 AS 간 라우팅 프로토콜로 게이트웨이 간의 라우팅에 사용되는 프로토콜
            - BGP(Border Gateway Protocol)
                - AS 상호 간에 정보를 교환하기 위한 라우팅 프로토콜로 초기에 라우터들이 연결될 때 전체 라우팅 테이블을 교환하고, 그 이후에는 변화된 정보만을 교환하는 방식
    

---

Q. 다음 [EMPLOY] 테이블에 대하여 πTTL(EMPLOYEE) 연산을 수행하면 나타나는 결과를 채워 넣으시오.

> TTL, 부장, 대리, 과장, 차장
> 

[EMPLOYEE]

| EMPNO | NAME | DEPT | TTL | JOIN_DATE |
| --- | --- | --- | --- | --- |
| 1001 | 홍길동 | 총무 | 부장 | 2001.03.01 |
| 1002 | 강감찬 | 총무 | 대리 | 2017.09.01 |
| 1003 | 을지문덕 | 회계 | 과장 | 2012.03.01 |
| 1004 | 이순신 | 기획 | 차장 | 2004.03.09 |

[결과]

| ① |
| --- |
| ② |
| ③ |
| ④ |
| ⑤ |

- 프로젝트(π) 연산자는 릴레이션 R에서 주어진 속성들의 값으로만 구성된 튜플을 반환할 때 사용한다.
- π속성리스트(R)이므로, EMPLOYEE 테이블에서 TTL 속성값으로만 구성된 튜플을 반환한다.

---

Q. 다음 Python 코드의 실행 결과를 쓰시오.

> REMEMBER AND STR
> 

```python
a = "REMEMBER NOVEMBER"
b = a[:3] + a[12:16]
c = "R AND %s"%"STR"
print(b + c)
```

- a[:3]은 REM, a[12:16]는 EMBE가 되고 “REMEMBE”가 b에 대입
- %s에는 “STR”이 전달되어 “R AND STR”을 c에 대입
- b + c를 출력하여 REMEMBE와 R AND STR를 합친 REMEMBER AND STR 출력

---

Q. **다음은 C언어 코드이다. 실행 결과를 쓰시오.**

> 10
> 

```c
#include <stdio.h>
int len(char* p)
int main() {
	char *p1 = "2022";
	char *p2 = "202207";
	printf("%d", len(p1) + len(p2));
	return 0;
}
int len(char* p) {
	int r = 0;
	while(*p != '\0') {
		p++;
		r++;
	}
	return r;
}
```

- 문자열 “2022”과 ”202207”의 길이를 구하고 더한 결과를 화면에 출력하는 코드이다.
- char pointer 형 변수 p1을 선언 및 “2022” 문자열 대입
- char pointer 형 변수 p2을 선언 및 “202207” 문자열 대입
- len(a)와 len(b)를 더한 결과를 화면에 출력

- len함수 선언
- 정수형 변수 r 선언 및 0으로 초기화
- while 문을 ‘\0’이 아닐 때까지 반복
- p값 증가
- r값 증가
- r값 리턴

---

Q. 다음은 C언어 코드이다. 실행 결과를 쓰시오.

> 22
> 

```c
#include <stdio.h>
void main() {
	int a[4] = {0, 2, 4, 8};
	int b[3];
	int* pl;
	int i, j;
	int sum = 0;
	for(i=1; i<4; i++) {
		pl = a +i;
		b[i-1] = *pl - a[i-1];
		sum = sum + a[i] + b[i-1];
	}
	print("%d", sum);
}
```

- i 값을 1부터 4보다 작을 때까지 1씩 증가하며 반복 수행
- a와 i값을 더한 값을 p1에 대입
- p1이 가리키는 값과 a[i-1] 값을 뺀 값을 b[i-1]에 대입
- 오른쪽 sum과 a[i]와 b[i-1] 값을 더한 값을 왼쪽 sum에 대입
- sum 값을 화면에 출력
    
    a: [0, 2, 4, 8], b: [2, 2, 4]
    
    2+2+4+2+8+4=22
    

---

Q. **다음 JAVA 코드의 실행 결과를 쓰시오.**

> 61
> 

```java
public class Soojebi {
	int a;
	public Soojebi(int a) {
		this.a = a;
	}
	int func() {
		int b = 1;
		for(int i=1; i<a; i++) {
			b = a*i +b;
		}
		return a + b;
	}
	public static void main(String[] args) {
		Soojebi obj = new Soojebi(3);
		obj.a = 5;
		int b = obj.func();
		System.out.print(obj.a + b);
	}
}
```

- 정수형 변수 a 선언
- 매개변수 a의 값을 this.a에 대입
- 정수형 변수 b는 1 대입
- 정수형 변수 i는 1부터 a보다 작을 때까지 1씩 증가하며 반복
- a와 i를 곱하고 오른쪽 b를 더한 값을 왼쪽 b에 대입
- a와 b를 더한 값을 리턴
- Soojebi 클래스의 객체 obj를 선언 및 생성자 Soojebi(int a)에 3을 전달하여 객체 생성
- obj.a에 5를 대입
- obj.func 메소드를 호출한 결과를 b에 대입
- obj.a와 b를 더한 값을 화면에 출력

---

Q. 다음 설명 중 () 안에 들어갈 단어를 보기에서 찾아 쓰시오.

> Full, Partial, Transitive
> 
- 관계 데이터베이스에서 X 속성에 의해 Y 속성이 유일하게 결정되면 Functional Dependency가 성립한다고 하며 X → Y라고 표현한다.
    
    {학번, 과목번호} → 성적
    
    학번 → 학년
    
- 성적은 {학번, 과목번호}에 의해 ( ① ) Functional Dependency가 성립하지만, 학년은 ( ② ) Functional Dependency가 성립한다.
- 속성 X, Y, Z에 대하여 X → Y이고 Y → Z이면, X와 Z는 ( ③ ) Functional Dependency가 성립한다.

[보기]

㉠ Determinant

㉡ Constraint

㉢ Transitive

㉣ Full

㉤ Dependent

㉥ Partial

㉦ Consistency

- 함수 종속(FD; Functional Dependency)은 어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 경우, 애트리뷰트 X의 값 각각에 대해 시간과 관계없이 항상 애트리뷰트 Y의 값이 오직 하나만 연관되어 있는 관계이다.
- Full Functional Dependency(완전 함수 종속)
    - 종속자가 기본키에만 종속되는 경우이거나 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우
- Partial Functional Dependency(부분 함수 종속)
    - 릴레이션에서 기본키가 복합키일 경우 기본키를 구성하는 속성 중 일부에게 종속된 경우
- Transitive Functional Dependency(이행 함수 종속)
    - 릴레이션에서 기본키가 복합키일 경우 기본키를 구성하는 속성 중 일부에게 종속된 경우

---

Q. 다음 설명에 해당하는 것을 보기에서 골라서 쓰시오.

> HTTP, HyperText, HTML
> 
- ( ① )은/는 인터넷에서 요청과 응답에 의해 처리하는 프로토콜로 GET, POST, PUT 등의 방식을 사용한다.
- ( ② )은/는 문장이나 단어 등이 링크를 통해 서로 연결된 네트워크처럼 구성된 문서로 이미지 등을 누르면 다른 사이트로 옮겨갈 수 있도록 하이퍼링크(hyperlink)가 걸려있다.
- ( ③ )은/는 운영체제에 관계없이 브라우저에서 실행되는 웹 문서를 표준하는 표준화된 마크업 언어로 웹 콘텐츠의 의미와 구조를 정의할 때 사용

[보기]

ICMP, HTTP, Hypertext, XML, HTML 등

- HTTP(HyperText Transfer Protocol)
    - 월드 와이드 웹(WWW)에서 HTML 문서를 송수신하기 위한 규칙들을 정의해 놓은 표준 프로토콜
    - 인터넷에서 요청과 응답에 의해 처리하는 프로토콜로 GET, POST, PUT 등의 방식을 사용
- Hypertext
    - 문장이나 단어 등이 링크를 통해 서로 연결된 네트워크처럼 구성된 문서로 이미지 등을 누르면 다른 사이트로 옮겨갈 수 있도록 하이퍼링크(hyperlink)가 걸려 있음
- HTML(HyperText Markup Language)
    - 웹을 이루는 가장 기초적인 구성요소로, 웹 콘텐츠의 의미와 구조를 정의할 때 사용
    - 인터넷 웹(WWW) 문서를 표현하는 표준화된 마크업 언어

---

Q. 다음 프로세스 구조에서 모듈 F의 Fan-In과 Fan-Out을 구하시오.

> 3, 2
> 

![이미지](/assets/img/exam/previous/2022(2)_2.png)

- 소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해서 팬인(Fan-In), 팬아웃(Fan-Out)을 활용한다.
- 팬인과 팬아웃 분석을 통하여 시스템 복잡도를 측정할 수 있다.
    - 팬인(Fan-In)
        - 어떤 모듈을 제어(호출)하는 모듈의 수
        - 모듈 숫자 계산: 모듈 자신을 기준으로 모듈에 들어오면 팬인(in)
    - 팬아웃(Fan-Out)
        - 어떤 모듈에 의해 제어(호출)되는 모듈의 수
        - 모듈 숫자 계산: 모듈 자신을 기준으로 나가면 팬아웃(out)