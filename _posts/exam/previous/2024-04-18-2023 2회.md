---
categories: [정보처리깃, 기출문제]
---

Q. **다음 프로그램에서 43215로 출력되도록 밑줄 친 곳에 들어갈 코드를 보기에서 골라 작성하시오.**

> n[(i+1)% 5]
> 

```c
#include <stdio.h>
int main() {
	int n[5] = {5, 4, 3, 2, 1};
	int i;
	for(i=0; i<5; i++) {
		printf("%d",     );
	}
	return 0;
}
```

[보기]

```
n i + % 1 5 [ ] ( )
```

[실행결과]

```c
43215
```

- i=0일 때 n[1], i=1일 때 n[2], i=2일 때 n[3], i=3일 때 n[4], i=4일 때 n[0]을 출력해야 하므로 (i+1)을 5로 나눴을 때 나머지 값의 번지인 (i+1)%5 번지의 값을 출력한다.

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> BCD
> 

```c
#include <stdio.h>

int main(){
	int n[3] = {73, 95, 82};
	int i, sum = 0;
	
	for(i=0; i<3; i++) {
		sum += n[i];
	}
	
	switch(sum/30) {
	case 10:
	case 9: printf("A");
	case 8: printf("B");
	case 7:
	case 6: printf("C");
	default: printf("D");
	}
	return 0;
}
```

- n이라는 이름의 정수형 3개를 저장하는 배열을 선언과 동시에 초기화
- i, sum이라는 이름의 int(정수)형 변수를 선언하고, sum은 0으로 초기화
- for 반복문에서 sum은 250이 됨
- sum/30을 하면 250/30이므로 8.333이지만 정수%정수의 결과는 정수가 되므로 소수점을 버린 8이 됨
- case(8)이므로 case 8로 이동
- B를 출력, break가 없으므로 switch~case 문을 탈출하지 않고 C, D를 출력
- switch~case 문이 끝났으므로 switch ~ case 문을 탈출
- 메인 함수의 return 0을 만나 프로그램 종료

---

Q. 다음 C 프로그램의 출력 결과를 쓰시오.

> 213465
> 

```c
#include <stdio.h>
#define MAX_SIZE 10

int isWhat[MAX_SIZE];
int point = -1;

int isEmpty() {
	if(point == -1) return 1;
	return 0;
}

int isFull() {
	if(point == 10) return 1;
	return 0;
}

void into(int num) {
	if(point >= 10) printf("Full");
	isWhat[++point] = num;
}
int take() {
	if(isEmpty() == 1) printf("Empty");
	return isWhat[point--];
}

int main() {
	into(5);
	into(2);
	while(!isEmpty()) {
		printf("%d", take());
		into(4);
		into(1);
		printf("%d", take());
		into(3);
		printf("%d", take());
		printf("%d", take());
		into(6);
		printf("%d", take());
		printf("%d", take());
		return 0;
	}
}
```

- 스택 문제

---

Q. [학생] 테이블의 스키마 이용해 [처리 조건]에 맞는 쿼리문을 작성하시오.

```sql
INSERT INTO 학생(학번, 이름, 학년, 과목, 연락처) VALUES (9830287, '한국산', 3, '경영학개론', '050-1234-1234');
```

```sql
INSERT INTO 학생 VALUES (9830287, '한국산', 3, '경영학개론', '050-1234-1234');
```

[학생] 테이블

| 속성명 | 데이터 타입 | 비고 |
| --- | --- | --- |
| 학번 | INT | PRIMARY KEY |
| 이름 | VARCHAR(20) |  |
| 학년 | INT |  |
| 과목 | VARCHAR(20) |  |
| 연락처 | VARCHAR(20) |  |

[처리 조건]

- 학생 테이블에 학번이 9830287, 이름이 ‘한국산’, 학년이 3, 과목이 ‘경영학개론’, 연락처가 ‘050-1234-1234’인 학생의 정보를 입력하시오.
- 명령문 마지막의 세미콜론(;)은 생략이 가능하다.
- 인용 부호가 필요한 경우 작은 따옴표(’)를 사용한다.

- INSERT는 데이터의 내용을 삽입할 때 사용하는 명령어이다.
    
    ```sql
    INSERT INTO 테이블명(속성명1, ...) VALUES(데이터1, ...);
    ```
    
    - 속성과 데이터 개수, 데이터 타입이 일치해야 함
    - 속성명은 생략 가능
    - 속성의 타입이 숫자인 경우 데이터는 따옴표를 붙이지 않아도 되며, 문자열인 경우 따옴표를 붙여야 함

---

Q. **다음 C 프로그램에 홍길동, 김철수, 박영희 순서로 입력하였다. 프로그램의 출력 결과를 쓰시오.**

![이미지](/assets/img/exam/previous/2023(2)_1.png)

```c
#include <stdio.h>
char n[30];
char *soojebi() {
	gets(n);
	return n;
}

int main() {
	char *p1 = soojebi();
	char *p2 = soojebi();
	char *p3 = soojebi();
	printf("%s\n", p1);
	printf("%s\n", p2);
	printf("%s\n", p3);
	return 0;
}
```

[입력]

```
홍길동
김철수
박영희
```

- n이라는 이름의 문자형 배열 선언
- 메인 함수부터 시작
- soojebi 함수를 호출
- soojebi 함수 실행(반환하는 타입이 문자형 포인터 char*)
- gets 함수를 통해 n 배열에 키보드로부터 입력받은 문자열을 저장(한글을 문자형 2개 변수에 1글자 저장)
    
    
    | n[0] | n[1] | n[2] | n[3] | n[4] | n[5] | n[6] | … |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |  | 홍 |  | 길 |  | 동 | \0 |  |
- **n 배열의 시작주소(&n[0])**를 **반환**
- **p1 변수**에 soojebi() 함수의 반환값인 **n[0]의 주소값을 저장**
- soojebi 함수를 호출
- soojebi 함수 실행(반환하는 타입이 문자형 포인터 char*)
- gets 함수를 통해 n 배열에 키보드부터 입력받은 문자열을 저장(한글을 문자형 2개 변수에 1글자 저장)
    
    
    | n[0] | n[1] | n[2] | n[3] | n[4] | n[5] | n[6] | … |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |  | 김 |  | 철 |  | 수 | \0 |  |
- n 배열의 시작주소(&n[0])를 반환
- p2 변수에 soojebi() 함수의 반환값인 n[0]의 주소값을 저장
- soojebi 함수를 호출
- soojebi 함수 실행(반환하는 타입이 문자형 포인터 char*)
- gets 함수를 통해 n 배열에 키보드부터 입력받은 문자열을 저장(한글을 문자형 2개 변수에 1글자 저장)
    
    
    | n[0] | n[1] | n[2] | n[3] | n[4] | n[5] | n[6] | … |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |  | 박 |  | 영 |  | 희 | \0 |  |
- n 배열의 시작주소(&n[0])를 반환
- p3 변수에 soojebi() 함수의 반환값인 n[0]의 주소값을 저장
- p1, p2, p3 변수에는 n[0]의 주소값이 저장되어 있고, printf에서 문자열(%s)로 출력하라고 했으므로 n[0]부터 NULL 전까지의 문자열을 출력

| n[0] | n[1] | n[2] | n[3] | n[4] | n[5] | n[6] | … |
| --- | --- | --- | --- | --- | --- | --- | --- |
|  | 박 |  | 영 |  | 희 | \0 |  |

- n[6]에는 NULL이 있고, n[0]~n[5]는 박영희가 저장되어 있으므로 박영희를 출력

---

Q. 전체 조건식의 영향은 고려하지 않고, 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 테스트 커버리지는 무엇인가?

> 조건 커버리지
> 

- **전체 조건식의 영향은 고려하지 않고**, 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 테스트 커버리지는 조건 커버리지이다.
- 화이트 박스 테스트 유형은 다음과 같다.
    - 구문 커버리지 = 문장 커버리지(Statement Coverage)
        - 구문 커버리지는 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지
    - 결정 커버리지 = 선택 커버리지(Decision Coverage) = 분기 커버리지(Branch Coverage)
        - 결정 커버리지는 (각 분기의) 결정 포인트 내의 전체 조건식이 적어도 한 번은 참(T)와 거짓(F)의 결과를 수행하는 테스트 커버리지
    - 조건 커버리지(Condition Coverage)
        - 조건 커버리지는 (각 분기의) 결정 포인트 내의 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 커버리지
    - 조건/결정 커버리지(Condition/Decision Coverage)
        - 조건/결정 커버리지는 전체 조건식뿐만 아니라 개별 조건식도 참 한번, 거짓 한 번 결과가 되도록 수행하는 테스트 커버리지
    - 변경 조건/결정 커버리지(Modified Condition/Decision Coverage)
        - 변경 조건/결정 커버리지는 **개별 조건식이** 다른 개별 조건식에 영향을 받지 않고 **전체 조건식에 독립적**으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지
    - 다중 조건 커버리지(Multiple Condition Coverage)
        - 다중 조건 커버리지는 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지
    - 기본 경로 커버리지 = 경로 커버리지(Base Path Coverage)
        - 기본 경로 커버리지는 수행 가능한 모든 경로를 테스트하는 기법
    - 제어 흐름 테스트(Control Flow Testing)
        - 제어 흐름 테스트는 프로그램 제어 구조를 그래프 형태로 나타내여 내부 로직을 테스트하는 기법
    - 데이터 흐름 테스트(Data Flow Testing)
        - 데이터 흐름 테스트는 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트하는 방법
    - 루프 테스트(Loop Testing)
        - 프로그램 반복(Loop) 구조에 초점을 맞춰 실시하는 테스트 기법

---

Q. 다음은 잔돈의 개수를 구하는 프로그램이다. a는 1000원의 개수, b는 500원의 개수, c는 100원의 개수, d는 10원의 개수이다. 밑줄 ①, ②, ③, ④에 들어갈 코드를 순서대로 작성하시오.(코드의 길이를 최소화해서 구현해야 한다.)

> m/1000, (m%1000)/500, (m%500)/100, (m%100)/10
> 

```c
#include<stdio.h>
int main() {
	int m = 4620;
	int a, b, c, d;
	a =   ①  ;
  b =   ②  ;
  c =   ③  ;
  d =   ④  ;
  printf("1000원 : %d개\n", a);
  printf("500원 : %d개\n", b);
  printf("100원 : %d개\n", c);
  printf("10원 : %d개\n", d);
  return 0;
}
```

[조건]

```c
m i d % / 0 ~ 9 ( )
```

[출력 결과]

```
1000원 : 4개
500원 : 1개
100원 : 1개
10원 : 2개
```

- 메인 함수부터 시작
- m이라는 이름의 int(정수) 형 변수를 선언하고, 4620으로 초기화
- a, b, c, d라는 이름의 int(정수) 형 변수를 선언
- 1000원짜리 개수를 계산해야 하므로 m 값을 1000으로 나누어줌
- 정수와 정수를 나누면 소수점을 버린 정수값이 되므로 m/1000이면 4620/1000인 4가 a 변수에 저장됨
- 4620원에서 1000원짜리 4장을 거슬러주어 620원이 남게 된 상태에서 500원짜리 개수를 세어야 함
- (m % 1000)을 통해 1000원짜리를 거슬러준 상태를 만들고, 거기에 500을 나눠주면 500원짜리 개수가 됨
- 4620원에서 1000원짜리, 500원짜리로 거슬러주어 120원이 남게 된 상태에서 100원짜리 개수를 세어야 하므로 (m%500)을 통해 500원짜리를 거슬러준 상태로 만들고, 거기에 100을 나눠주면 100원짜리 개수가 됨
- ((m%1000)%500)으로 구현하면 코드의 길이가 최소화되지 않으므로 (m%500)이 되어야 함
- 4620원에서 1000원짜리, 500원짜리, 100원짜리로 거슬러주어 20원이 남게 된 상태에서 10원짜리 개수를 세어야 하므로 (m%100)을 통해 100원짜리를 거슬러준 상태로 만들고, 거기에 10을 나눠주면 10원짜리 개수가 됨
- (((m%1000)%500)%100)으로 구현하면 코드의 길이가 최소화되지 않으므로 (m%100)이 되어야 함
- 1000원짜리 개수부터 10원짜리 개수까지 출력

---

Q. 다음에서 설명하는 용어를 쓰시오.

> 템퍼프루핑(Tamper-Proofing)
> 
- 소프트웨어, 시스템을 외부에서 악의적인 조작으로부터 보호하는 보안기술로 위∙변조와 같은 이상 조작을 검출하고, 이상 감지 시 프로그램을 오작동하도록 만드는 기술이다.
- 구성 기술로는 해시 함수(Hash Function), 핑거 프린트(Fingerprint), 워터마크(Watermark), 소프트웨어 원본 비교, 프로그램 체킹, 실행코드 난독화 등이 있다.

- 템퍼 프루핑(Tamper-Proofing)은 소프트웨어, 시스템을 외부에서의 악의적인 조작으로부터 보호하는 보안 기술이다.
- 위∙변조와 같은 이상 조작을 검출하고, 이상 감지 시 프로그램을 오작동하도록 만드는 기술이다.
- 템퍼 프루핑의 주요 기술은 다음과 같다.
    - 템퍼 프루핑 생성 기술
        - 해시 함수(Hash Function)
            - 일정한 크기의 문자열을 생성하여 무결성을 검증할 수 있는 함수
        - 워터마크(Watermark)
            - 멀티미디어 콘텐츠에 저작권 정보와 구매한 사용자 정보를 상비하여 콘텐츠 불법 배포자에 대한 위치 추적이 가능한 기술
        - 핑거 프린트(Fingerprint) - 추적
            - 디지털 콘텐츠에 저작권자 정보를 삽입하여, 불법 복제 시 워터마크를 추출, 원소유자를 증명할 수 있는 콘텐츠 보호 기술
            - 쿠키를 이용하지 않고, 사용자의 웹브라우저 데이터를 이용하여 식별하는 기술
    - 외부 공격에 대한 방어 기술
        - 소프트웨어 원본 비교
            - 소프트웨어의 원본에 대한 메시지 다이제스트 알고리즘을 비교하여 변조를 찾아내는 기술
        - 프로그램 체킹
            - 프로그램 체킹을 수행하면서 중간의 산출물 검증을 통해 변조를 방지하는 기술
        - 실행코드 난독화
            - Obfuscation
                - 실행 코드를 알아보기 힘든 형태로 난독화하여 처리하는 기술

---

Q. 다음은 선택정렬 코드이다. 밑줄에 알맞은 코드를 쓰시오.

> <
> 

```c
#include <stdio.h>
int main() {
	int arr[] = {65, 25, 12, 22, 11};
	int n = sizeof(arr)/sizeof(arr[0]);
	int i = 0, j, tmp;
	do {
		j = i + 1;
		do {
			if(arr[i]       arr[j]) {
				tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
			}
			j++;
		} while(j < n);
		i++;
	}while(i < n-1);
	for(i=0; i<=4; i++) {
		printf("%d ", arr[i]);
	return 0;
	}
}
```

[실행결과]

```c
11 12 22 25 64
```

- 출력값은 arr[0]부터 차례로 커지므로 밑줄에 arr[i]가 arr[j]보다 크면 둘의 위치를 교환해서 작은 값이 0번지에 가까워지도록 해준다.
- 메인 함수부터 시작
- arr 배열 생성하고, 배열의 초기값은 {64, 25, 12, 22, 11};
- sizeof(arr)은 arr 배열의 전체 크기인 20바이트이고, sizeof(arr[0])은 arr[0]의 크기인 4바이트이므로 n은 5가 됨
- i, j, tmp라는 이름의 int(정수) 형 변수를 선언하고, i 변수는 0으로 초기화
- do~while 문은 무조건 1번은 실행함
- 선택 정렬

---

Q. Database 구축 프로세스를 순서대로 나열하시오.

> ㉢ 요구사항 분석 → ㉣ 개념적 설계 → ㉠ 논리적 설계 → ㉤ 물리적 설계 → ㉡ 구현
> 

㉠ 논리적 설계

㉡ 구현

㉢ 요구사항 분석

㉣ 개념적 설계

㉤ 물리적 설계

- Database 구축은 요구사항 분석, 개념적 설계, 논리적 설계, 물리적 설계, 구현 순서대로 진행한다.
    - 요구사항 분석
        - 사용자에게서 데이터베이스를 사용하는 용도로 파악함
        - 다양한 요구사항을 수집하는 단계로 요구사항 명세서를 작성함
    - 개념적 설계
        - 요구사항 명세서를 기반으로 개념적 데이터 모델을 표현하여 E-R 다이어그램을 표현할 수 있음
    - 논리적 설계
        - 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행함
    - 물리적 설계
        - 특정 DBMS의 특성 및 성능을 고려하여 데이터 베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있음
    - 구현
        - SQL문을 실행하여 데이터베이스를 실제로 생성함

---

Q. 다음은 디자인 패턴에 대한 설명이다. 괄호 () 안에 들어가는 디자인 패턴의 종류를 보기에서 고르시오.

> Singleton, Visitor
> 
- ( ① ) 패턴은 전역변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체는 어디에서든지 참조할 수 있도록 하는 디자인 패턴이다.
- ( ② ) 패턴은 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴이다. ( ② ) 패턴은 객체의 구조는 변경하지 않으면서 새로운 기능(연산)만 따로 추가하거나 확장할 때 사용하는 디자인 패턴이다.

---

Q. 다음은 오류 제어 방식에 대한 설명이다. 괄호() 안에 들어갈 용어를 보기에서 찾아서 쓰시오.

> FEC, BEC, Hamming, Parity, CRC
> 
- 오류 제어 방식에는 크기 ( ① ) 방식과 ( ② ) 방식이 있다.
- ( ① ) 방식은 데이터 전송 과정에서 발생한 오류를 검출하여 검출된 오류를 재전송 요구 없이 스스로 수정하는 방식이다. 대표적인 유형인 ( ③ ) 코드 방식은 수신측에서 오류가 발생한 비트를 찾아 재전송을 요구하지 않고 자신이 직접 오류를 수정하는 방식으로 1비트의 오류 수정이 가능하다.
- ( ② ) 방식은 데이터 전송 과정에서 오류가 발생하면 송신 측에 재전송을 요구하는 방식이다. 대표적인 유형에는 ( ④ ) 검사, (  ⑤ ) 등이 있다.
- ( ④ ) 검사는 7~8개 비트로 구성되는 전송 문자에 패리티 비트를 추가하여 오류를 검출하는 방식이다.
- (  ⑤ )은/는 다항식을 통해 산출된 값을 토대로 오류를 검사하는 방식으로 집단 오류를 해결하기 위한 방식이다.

[보기]

NAK, BEC, Hamming, MD5, Parity, BCD, CRC, FEC

- 오류 제어 방식에는 FEC 방식과 BEC 방식이 있다.
    - 전진(순방향) 오류 수정(FEC; Forward Error Correction)
        - 데이터 전송 과정에서 발생한 오류를 검출하여 검출된 오류를 재전송 요구 없이 스스로 수정하는 방식
        - 오류 검출과 수정을 위한 방식에는 해밍 코드 방식과 상승 코드 방식이 있음
    - 후진(역방향) 오류 수정(BEC; Backward Error Correction)
        - 데이터 전송 과정에서 오류가 발생하면 송신 측에 재전송을 요구하는 방식
        - 패리티 검사, CRC, 블록합 검사를 사용하여 오류를 검출하고, 오류 제어는 자동 반복 요청(ARQ; Automatic Repeat reQuest)에 의해 이루어짐

- FEC의 방식은 해밍 코드 방식과 상승 코드 방식이 있다.
    - 해밍(Hamming) 코드 방식
        - 수신측에서 오류가 발생한 비트를 찾아 재전송을 요구하지 않고 자신이 직접 오류를 수정하는 방식으로 1비트의 오류 수정이 가능
    - 상승 코드(부호) 방식
        - 1개의 오류 비트를 수정할 수 있는 해밍 코드 방식과는 다르게 여러 개 비트의 오류가 있더라도 한곗값(경곗값), 순차적 디코딩을 이용하여 모두 수정할 수 있는 방식
        
- BEC의 방식은 패리티 검사, CRC, 블록합 검사, ARQ 등이 있다.
    - 패리티 검사(Parity Check)
        - 7~8개의 비트로 구성되는 전송 문자에 패리티 비트를 추가하여 오류를 검출하는 방식
    - 순환잉여검사(CRC; Cycle Redundancy Check)
        - 다항식을 통해 산출된 값을 토대로 오류를 검사하는 방식으로 집단 오류를 해결하기 위한 방식
    - 블록합 검사(Block Sum Check)
        - 프레임의 모든 문자로부터 계산되는 잉여 패리티 비트들을 사용하는 이차원(가로/세로) 패리티 검사 방식
        - 블록의 맨 마지막에 수평 방향으로 패리티 비트를 부여해서 에러 유무 판결
    - 자동반복 요청 방식(ARQ; Automatic Repeat reQuest)
        - 신뢰성 있는 데이터 전달을 위해 재전송을 기반으로 하는 에러제어 방식
        - Stop and Wait(정지-대기) ARQ: 송신 측에서 한 개의 블록을 전송한 후 수신 측으로부터 응답을 기다리는 방식
        - Go-Back-N ARQ: 오류가 발생한 블록 이후의 모든 블록을 재전송하는 방식
        - Selective Repeat(선택적 재전송) ARQ: 오류가 발생한 블록만 재전송하는 방식
    

---

Q. 다음은 비트(Bit) 위주의 프로토콜로, 각 프레임에 데이터 흐름을 제어하고 오류를 보정할 수 있는 비트 열을 삽입하여 전송하는 역할을 하는 HDLC에 대한 설명이다. 다음이 설명하는 용어를 보기에서 고르시오.

> 정보, 감독, 비번호, 동기 균형 모드, 비동기 균형 모드
> 
- HDLC 프레임의 구조는 플래그(Flag), 주소부(Address Field), 제어부(Control Field)로 구성되어 있다.
- 여기에서 제어부는 프레임의 종류를 식별하기 위해 사용되는데 제어부의 첫 번째, 두 번째 비트를 사용하여 프레임의 종류를 구별할 수 있다.
- 프레임의 종류 중 ( ① ) 프레임은 제어부가 ‘0’으로 시작되는 프레임으로, 사용자가 데이터를 전달하는 역할을 하고, ( ② ) 프레임은 제어부가 ‘10’으로 시작하는 프레임으로, 오류 제어와 흐름 제어를 위해 사용된다. 또한, ( ③ ) 프레임은 제어부가 ‘11’로 시작하는 프레임으로, 링크의 동작 모드 설정과 관리를 한다.
- HDLC의 데이터 전송 모드는 세 가지로 구분되는데 ( ④ )은/는 포인트 투 포인트 균형 링크에서 사용하고, 혼합국끼리 허가 없이 언제나 전송할 수 있도록 설정하는 특징이 있다.
- ( ⑤ )은/는 전이중 통신을 하는 포인트 투 포인트 불균형 링크구성에 사용하고, 종국은 주국의 허가 업이 송신할수 있지만, 링크 설정이나 오류 복구 등의 제어 기능은 주국만 하는 성질이 있다.

[보기]

감독, 익명, 정보, 비번호, 릴레이, 표준 응답 모드, 양방향 응답 모드, 동기 균형 모드, 비동기 응답 모드, 동기 응답 모드, 비동기 균형 모드

- **캡슐화(Encapsulation)**
    - 캡슐화는 단편화된 데이터에 송•수신지 주소, 오류 검출 코드, 프로토콜 기능을 구현하기 위한 프로토콜 제어 정보 등의 정보를 부가하는 것으로, 요약화라고도 함
    - 대표적인 예가 **데이터 링크 제어 프로토콜**의 **HDLC 프레임** 임
        
        ![이미지](/assets/img/exam/previous/2023(2)_2.png)
        
    - 정보 데이터를 오류 없이 정확하게 전송하기 위해 캡슐화를 수행함

- **HDLC(High-level Data Link Control)**
    - 비트(Bit) 위주의 프로토콜로, 각 프레임에 데이터 흐름을 제어하고 오류를 보정할 수 있는 비트 열을 삽입하여 전송함
    - 포인트 투 포인트 및 멀티 포인트(1:다), 루프 방식에서 모두 사용 가능함
    - 단방향, 반이중, 전이중 통신을 모두 지원하며 동기식 전송 방식을 사용함
    - 에러 제어를 위해 GO-Back-N ARQ와 선택적 재전송(Selective Repeat) ARQ를 사용함
    - 흐름 제어를 위해 슬라이딩 윈도우 방식을 사용함
    - 전송 제어상의 제한을 받지 않고 자유로이 비트 정보를 전송할 수 있음(비트 투과성)
    - 전송 효율과 신뢰성이 높다.
    - HDLC의 데이터 전송 모드 : 표준(정규) 응답 모드(NRM), 비동기 응답 모드(ARM), 비동기 균형(평형) 모드(ABM)

- HDLC 프레임 구조
    - 플래그(Flag)
        - 프레임의 시작과 끝을 나타내는 고유한 비트 패턴(01111110)으로, 프레임의 시작과 끝을 구분, 동기 유지(통화로의 혼선을 방지하기 위해), 비트 투과성을 이용한 기본적인 오류 검출 등의 기능을 수행함
    - 주소부(Address Field)
        - 송•수신국을 식별하기 위해 사용함
        - 모든 수신국에 전송되는 방송용은 ‘11111111' 임의로 지정된 수신국에만 전송되는 시험용은 '00000000’이다
    - 제어부(Control Field) : 프레임의 종류를 식별하기 위해 사용함
        - 정보 프레임(Information Frame) : 사용자 데이터를 전달함, 제어부 ‘0’으로 시작되는 프레임
        - 감독 프레임(Supervisory Frame) : 오류 제어와 흐름 제어를 수행함, 제어부가 ‘10’으로 시작하는 프레임
        - 비(무)번호 프레임(Unnumbered Frame) : 회선의 설정, 유지 및 종결을 담당함(링크와 동작 모드 설정과 관리), ‘11’로 시작하는 프레임
    - 정보부(Information Field)
        - 실제 정보 메시지가 들어 있는 부분
    - FCS(프레임 검사 순서 필드)
        - 프레임 내용에 대한 오류검출을 위해 사용되는 부분으로, 일반적으로 CRC 코드가 사용됨

![이미지](/assets/img/exam/previous/2023(2)_3.png)

- HDLC는 비트(Bit) 위주의 데이터 링크 제어 프로토콜로, 각 프레임에 데이터 흐름을 제어하고 오류를 보정할 수 있는 비트 열을 삽입하여 전송하는 역할을 한다.
- HDLC 프레임은 플래그, 주소부, 제어부, 정보부, FCS로 구성되어 있다.
    - 플래그: 프레임의 동기를 제공하기 위해 사용하는 영역
    - 주소부: 프레임 목적지인 보조국의 주소를 나타내는 영역
    - 제어부: 프레임의 종류를 식별하기 위해 사용하는 영역
    - 정보부: 실제 정보 메시지가 들어있는 영역
    - FCS(Frame Check Sequence): 프레임에 대한 전송 오류를 검출하기 위해 사용하는 영역
- 제어부는 프레임의 종류를 식별하기 위해 사용되는데 제어부의 첫 번째, 두 번째 비트를 사용하여 프레임의 종류를 구별할 수 있다.
- 프레임의 종류에는 I프레임, S프레임, U프레임이 있다.
    
    
    | 유형 | 설명 |
    | --- | --- |
    | I 프레임 | 정보 프레임이라고 하고, 제어부가 ‘0’으로 시작되는 프레임으로, 사용자 데이터를 전달하는 역할을 함 |
    | S 프레임 | 감시 프레임이라고 하고, 제어부가 ‘10’으로 시작하는 프레임으로, 오류 제어와 흐름 제어를 위해 사용됨 |
    | U 프레임 | 비번호 프레임이라고 하고, 제어부가 ‘11’로 시작하는 프레임으로, 링크와 동작 모드 설정과 관리를 함 |
- HDLC 동작 모드는 세 가지가 있다.
    - 정규 응답 모드(NRM; Normal Response Mode)
        - 점대점이나 멀티포인트 불균형 링크 구성에 사용
        - 주국(Primary Station)이 링크 제어를 담당하며, 보조국(Secondary Station)은 주국으로부터 폴메시지를 수신한 경우에만 데이터를 전송
        
        ![이미지](/assets/img/exam/previous/2023(2)_4.png)
        
    - 비동기 응답 모드(ARM; Asynchronous Response Mode)
        - 전이중 통신을 하는 포인트 투 포인트 불균형 링크 구성에 사용
        - 보조국은 주국의 허가 없이 송신할 수 있지만, 링크 설정이나 오류 복구 등의 제어 기능은 주국만 하는 특징
        - 보조국도 전송 개시할 필요가 있는 특수한 경우에만 사용
        
        ![이미지](/assets/img/exam/previous/2023(2)_5.png)
        
    - 비동기 균형 모드(ABM; Asynchronous Balanced Mode)
        - 포인트 투 포인트 균형 링크 구성에 사용
        - 각국이 혼합국(복합국)으로 허가 없이 서로 대등하게 균형적으로 명령과 응답을 하며 동작
        
        ![이미지](/assets/img/exam/previous/2023(2)_6.png)
        

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 505
> 

```c
#include <stdio.h>
int main() {
	int c=0;
	int i;
	
	for(i=1; i<=2023; i++) {
		if(i%4 == 0) c++;
	}
	print("%d", c);
	return 0;
}
```

- 메인 함수부터 시작
- c라는 이름의 정수형 변수를 선언하고 0으로 초기화
- i라는 이름의 정수형 변수를 선언
- i=1부터 i가 1씩 증가하면서 i<=2023을 만족할 때까지 반복
- i를 4로 나누었을 때 나머지가 0(4의 배수)이면 c++에 의해 c 값이 증가
- 1~2023 사이의 4의 배수는 505개이므로 c는 505가 됨
- c 변수 값인 505를 출력

---

Q. 다음은 암호화에 대한 설명이다. ①, ②가 설명하는 암호화 방식의 종류들을 보기에서 골라 쓰시오.

> DES, AES, ARIA, SEED / RSA, ECC
> 

① : 암호화와 복호화에 같은 암호 키를 쓰는 방식으로 비밀키 전달을 위한 키 교환이 필요하고, 암호화 및 복호화의 속도가 빠른 특징이 있는 암호화 방식이다. 

② : 공개키와 개인 키가 존재하며, 공개키는 누구나 알 수 있지만, 그에 대응하는 개인 키는 키의 소유자만이 알 수 있는 암호화 방식이다. 

[보기]

RSA, DES, AES, ECC, ARIA, SEED

- ①번은 대칭키 암호화 방식에 대한 설명이고, ②번은 비대칭키 암호화 방식에 대한 설명이다.
- 대칭키 암호화와 비대칭키 암호화의 종류는 다음과 같다.
    - 대칭키 암호화 종류
        - DES: 1975년 IBM에서 개발하고 미국의 연방 표준국(NIST)에서 발표한 대칭 키 기반의 블록 암호화 알고리즘
        - SEED: 1999년 국내 한국인터넷진흥원(KISA)이 개발한 블록 암호화 알고리즘
        - AES: 2001년 미국 표준 기술 연구소(NIST)에서 발표한 블록 암호화 알고리즘
        - ARIA: 2004년 국가정보원과 산학연구협회가 개발한 블록 암호화 알고리즘
    - 비대칭키 암호화 종류
        - RSA: 1977년 3명의 MIT 수학 교수(Rivest, Shamir, Adleman)가 고안한 큰 인수의 곱을 소인수 분해하는 수학적 알고리즘 이용하는 공개키 암호화 알고리즘
        - ECC: 유한체 위해서 정의된 타원곡선 군에서의 이산대수의 문제에 기초한 공개키 암호화 알고리즘
- 이외에도 대칭키 암호화 방식 종류에는 IDEA, LFSR(스트림 방식), Skipjack 등이 있고, 비대칭키 암호화 방식의 종류에는 디피-헬만, ElGamal 등이 있다.

---

Q. ()은/는 임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 단방향 함수를 말한다. 아무리 큰 숫자를 넣더라도 정해진 크기의 숫자가 나오는 함수이다. 괄호() 안에 들아갈 용어를 쓰시오.

> 해시함수(Hash Function) 또는 해싱 함수(Hashing Function) 또는 해싱(Hashing)
> 

- 임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 단방향 함수는 해시 함수이다.
- 해시 함수를 이용한 해시 알고리즘은 일방향 암호 방식으로 임의 길이의 정보를 입력받아, 고정된 길이의 암호문(해시값)을 출력하는 암호 방식이다.
- 해시 알고리즘의 종류에는 MD5, SHA-1, SHA-256/384/512, HAS-160, HAVAL 등이 있다.

---

Q. **다음은 [처리 조건]을 만족하는 SQL 문을 완성할 수 있도록 밑줄 안에 들어갈 옵션은 무엇인가?**

> cascade
> 

[처리 조건]

- “soojebi” 뷰 테이블 제거
- “soojebi” 뷰 테이블을 참조하는 테이블도 연쇄적으로 제거

```sql
DROP VIEW soojebi       ;
```

- VIEW 테이블 삭제 시 DROP 명령어를 사용한다.
- DROP 명령어 옵션은 다음과 같다.
    
    
    | 종류 | 설명 |
    | --- | --- |
    | CASCADE | 참조하는 테이블까지 연쇄적으로 제거하는 옵션 |
    | RESTRICT | 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션 |

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> engneng
> 

```python
a = "engineer information processing"
b = a[:3]
c = a[4:6]
d = a[29:]
e = b+c+d
print(e)
```

---

Q. 다음은 자바 소스 코드이다. 출력 결과를 쓰시오.

![이미지](/assets/img/exam/previous/2023(2)_7.png)

```java
class Soojebi {
	public static void main(String[] args) {
		String str1 = "soojebi";
		String str2 = "soojebi";
		String str3 = new String("soojebi");
	
		System.out.println(str1==str2);
		System.out.println(str1==str3);
		System.out.println(str1.equals(str3));
		System.out.println(str2.equals(str3));
	}
}
```

- 자바에서 **`==`** 연산자는 객체의 주소값을 비교하고, equals 메서드는 비교하는 두 대상의 값을 비교하는 메서드이다.

---

Q. 다음은 통합 테스트에 대한 설명이다. 괄호() 안에 들어갈 용어를 쓰시오.

> 스텁(Stub) 또는 테스트 스텁(Test Stub), 드라이버(Driver) 또는 테스트 드라이버(Test Driver)
> 
- ( ① )은/는 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 더미 모듈로 하향식 통합 테스트 수행 시 필요하다.
- ( ② )은/는 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈로 상향식 통합 테스트 수행 시 필요하다. 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후 결과를 도출하는 역할을 수행한다.