---
categories: [Certificate, "[정보처리기사] 기출문제(20~23년)"]
---


Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 3
> 

```java
class Soojebi {
	static private Soojebi instance = null; // 프로그램 시작 시 올라가는 변수
	private int count = 0; // 객체 생성하면 잡히는 변수
	static public Soojebi get() {
		if(instance == null) {
			instance = new Soojebi();
		}
		return instance;
	}
	public void count(){count ++;}
	public int getCount(){return count;}
}

public class Soojebi2 {
	public static void main() {
		Soojebi s1 = Soojebi.get();
		s1.count();
		Soojebi s2 = Soojebi.get(); // 100번지를 전부 참조(오직 하나의 인스턴스 공유)
		s2.count();
		Soojebi s3 = Soojebi.get();
		s3.count();
		System.out.print(s1.getCount());
	}
}
```

- 싱글톤 패턴 코드이다.
- instance를 static으로 선언하고 get 메서드에서는 instance가 null인 경우에만 객체를 생성하도록 하므로 프로그램에는 하나의 instance만 생성하여 사용한다.

---

Q. 다음은 3A에 대한 설명이다. 각각이 설명하는 3A의 구성 요소를 쓰시오.

> Authentication, Authorization, Accounting
> 

① 접근을 시도하는 가입자 또는 단말에 대한 식별 및 검증

② 검증된 가입자나 단말에게 어떤 수준의 권한과 서비스를 허용

③ 리소스 사용에 대한 정보를 수집하고 관리하는 서비스

- 3A는 유무선 이동 및 인터넷 환경에서 가입자에 대한 안전하고, 신뢰성 있는 인증, 권한 검증, 계정관리 기능을 체계적으로 제공하는 정보보호 기술이다.
    
    
    | 인증(Authentication) | 접근을 시도하는 가입자 또는 단말에 대한 식별 및 신분을 검증 |
    | 권한 부여(Authorization) | 검증된 가입자나 단말에게 어떤 수준의 권한과 서비스를 제공 |
    | 계정 관리(Accounting) | 리소스 사용에 대한 정보를 수집하고 관리하는 서비스 |

---

Q. GRANT의 기능을 서술하시오.

> GRANT는 사용자에게 권한을 부여하는 명령어이다.
> 

- 데이터 제어어의 유형에는 GRANT, REVOKE가 있다.
    
    
    | 유형 | 설명 |
    | --- | --- |
    | GRANT | 관리자(DBA)가 사용자에게 데이터베이스에 대한 권한을 부여하는 명령어 |
    | REVOKE | 관리자(DBA)가 사용자에게 부여했던 권한을 회수하기 위한 명령어 |

---

Q. 특정 호스트의 MAC 주소를 자신의 MAC 주소로 변경, 희생자로부터 특정 호스트로 나가는 패킷을 공격자가 가로채는 공격기법은 () Spoofing이다. () 안에 들어갈 용어를 쓰시오.

> ARP
> 

- ARP Spoofing은 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP reply를 만들어 희생자에게 지속적으로 전송하여 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보를 공격자의 MAC 정보로 변경, 희생자로부터 특정 호스트로 나가는 패킷을 가로채는 공격기법이다.

---

Q. 결합도(Coupling) 종류 중 단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우의 결합도를 영어로 쓰시오.

> 제어 결합도(Control Coupling)
> 

- 결합도(Coupling) 종류 중 단순 처리할 대상인 값만 전달하는 게 아니라 어떻게 처리를 해야 한다는 제어요소가 전달되는 경우의 결합도는 제어 결합도(Control Coupling)이다.
- 결합도의 유형은 다음과 같다.
    - 내용 결합도(Content Coupling)
        - 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도
        - 하나의 모듈이 **직접**적으로 다른 모듈의 내용을 **참조**할 때 두 모듈은 내용적으로 결합되어 있는 경우의 결합도
    - 공통 결합도(Common Coupling)
        - 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 **전역 변수**를 갱신하는 식으로 상호 작용하는 경우의 결합도
        - 공유되는 공통 데이터 영역을 여러 모듈이 사용 할 때의 결합도
    - 외부 결합도(External Coupling)
        - 두 개의 모듈이 외부에서 도입된 **데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스**를 공유할 경우의 결합도
        - **외부 모듈**에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
    - 제어 결합도(Control Coupling)
        - 어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 **제어 신호**를 이용하여 통신하는 경우의 결합도
        - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도 현상이 발생하는 결합도
    - 스탬프 결합도(Stamp Coupling)
        - 모듈 간의 인터페이스로 **배열이나 객체, 구조** 등이 전달되는 경우의 결합도
        - 두 모듈이 동일한 자료구조를 조회하는 경우의 결합도이며, 자료구조의 어떤한 변화는 모든 모듈에 영향을 미치게 됨
    - 자료 결합도(Data Coupling)
        - 모듈 간의 인터페이스로 전달되는 **파라미터**를 통해서만 모듈 간의 상호 작용이 일어나는 경우의 결합도
        - 한 모듈의 내용을 변경하더라도 다른 모듈에는 영향을 미치지 않는 상태로 가장 바람직한 결합도

---

Q. 다음은 OSI 7 Layer에 대한 설명이다. 각 항목에 해당하는 계층을 쓰시오.

> 데이터 링크 계층(Data Link Layer), 네트워크 계층(Network Layer), 표현 계층(Presentation Layer)
> 

① 직접적으로 연결된 두 개의 노드 사이에 데이터 전송을 가능하게 하고, 오류를 수정

② 단말기 간 데이터 전송을 위한 최적화된 경로 제공

③ 데이터의 압축과 형식 설정, 암∙복호화를 담당

- OSI 7 Layer의 특징은 다음과 같다.
    - 응용 계층(Application Layer)
        - 사용자와 네트워크 간 응용서비스 연결, 데이터 생성
        - 프로토콜: HTTP, FTP
        - 전송단위: 데이터(Data)
    - 표현 계층(Presentation Layer)
        - 데이터 형식 설정과 부호교환, 암/복호화
        - 프로토콜: JPEG, MPEG
        - 전송단위: 데이터(Data)
    - 세션 계층(Session Layer)
        - 연결 접속 및 동기제어
        - 프로토콜: SSH, TLS
        - 전송단위: 데이터(Data)
    - 전송 계층(Transport Layer)
        - 신뢰성 있는 통신 보장
        - 데이터 분할과 재조립, 흐름 제어, 오류 제어, 혼잡 제어 등을 담당
        - 프로토콜: TCP, UDP
        - 전송단위: 세그먼트(Segment)
    - 네트워크 계층(Network Layer)
        - 단말 간 데이터 전송을 위한 최적화된 경로 제공
        - 프로토콜: IP, ICMP
        - 전송단위: 패킷(Packet)
    - 데이터 링크 계층(Data Link Layer)
        - 인접 시스템 간 데이터 전송, 전송오류 제어
        - 동기화, 흐름 제어 등의 전송 기능 제공
        - 오류검출/재전송 등 기능 제공
        - 프로토콜: 이더넷
        - 전송단위: 프레임(Frame)
    - 물리 계층(Physical Layer)
        - 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
        - 프로토콜: RS-232C
        - 전송단위: 비트(Bit)

---

Q. UML 관계(Relationships)에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> Aggregation, Generalization
> 
- 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현(클래스들 사이의 전체 또는 부분 같은 관계): ( ① )
- 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현(IS-A 관계): ( ② )

- 집합 관계(Aggregation)
    - 하나의 사물이 다른 사물에 포함되어 있는 관계 표현
    - 하나의 객체에 여러 개의 독립적인 객체들이 구성되는 관계
    - 포함되는 쪽(Part; 부분)에서 포함하는 쪽(Whole; 전체)으로 **속이 빈 마름모**를 연결하여 표현
- 일반화 관계(Generalization)
    - 일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현
    - 일반적인 개념을 부모(상위)라고 하고, 구체적인 개념을 자식(하위)이라 함
    - 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 **속이 빈 화살표**로 연결하여 표현
    - 일반화 관계는 다른 의미로 상속 관계라고 함

- UML 관계
    - 연관관계(Association) : 관련된 관계
    - 의존관계(Dependency) : **짧은 시간**만 사용하는 관계
    - 일반화 관계(Generalization) : 상속관계
    - 실체화 관계(Realization) : 추상 메서드를 오버라이딩
    - 집합 관계 - 집약관계(Aggregation) : 부분 객체는 독립적
    - 집합 관계- 합성관계(Composition) : 부분 객체는 의존적

---

Q. 다음은 테스트 케이스 구성요소이다. () 안에 들어갈 구성 요소를 쓰시오.

> 테스트 조건(=전제 조건, 실행 조건), 테스트 데이터(=입력 값) , 예상 결과(=기대 결과)
> 
- ( ① ) : 테스트 간의 종속성, 테스트 수행 전 실행되어야 할 고려 사항 등
- ( ② ) : 테스트 실행 시 입력할 입력값, 선택 버튼, 체크 리스트 값 등
- ( ③ ) : 테스트 실행 후 출력 데이터, 결과 화면, 기대 동작 등

- 개별 테스트 케이스 필요 항목은 다음과 같다.

| 항목 | 설명 |
| --- | --- |
| 테스트 ID 작성 | 테스트 케이스를 고유하게 식별하기 위한 ID를 작성 |
| 테스트 목적 작성 | 테스트 시 고려해야 할 중점 사항이나 테스트 케이스의 목적을 작성 |
| 테스트할 기능 | 애플리케이션의 테스트할 기능을 간략하게 작성 |
| 테스트 환경 | 테스트 시 사용할 물리적, 논리적 테스트 환경, 사용할 데이터, 결과 기록 서버 등의 내용을 작성 |
| 테스트 데이터(=입력 데이터) | 테스트 실행 시 입력할 데이터(입력 값, 선택 버튼, 체크리스트 값 등)를 작성 |
| 예상 결과(=기대결과) | 테스트 실행 후 기대되는 결과 데이터(출력 데이터, 결과 화면, 기대 동작 등)를 작성 |
| 테스트 조건(=전제 조건) | 테스트 간의 종속성, 테스트 수행 전 실행되어야 할 고려 사항 등을 작성 |
| 성공/실패 기준 | 테스트를 거친 애플리케이션 기능의 성공과 실패를 판단하는 조건을 명확하게 작성 |
| 기타 요소 | 시용자의 테스트 요구사항 중 특별히 고려해야 할 내용을 간략하게 기술 |
- 테스트 케이스: 하나의 단위 테스트 - 로그인, 회원가입, 정보 수정
- 테스트 시나리오: 테스트 케이스들의 묶음

---

Q. 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법은 무엇인가?

> 원인-결과 그래프(Cause-Effect Graph)
> 

- 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를선정하여 테스트하는 기법은 원인-결과 그래프(Cause-Effect Graph) 기법이다.

---

Q. 블록 암호의 일종으로, IBM에서 개발한 블록 암호화 알고리즘으로 미국 NBS(현재 NIST)에서 국가 표준으로 정한 암호화 알고리즘이나 취약점이 발견되어 현재는 잘 사용되지 않느다. 블록의 크기는 64비트, 키 길이는 56비트, 16라운드 암호화 알고리즘은 무엇인가?

> DES(Data Encryption Standard)
> 

- 블록암호 알고리즘
    - DES : 64비트 블록, 56비트 키, 16라운드, Feistel 구조
    - 3-DES : 2개의 키, 암호화, 복호화, 암호화 , Feistel 구조
    - AES : 128비트 블록, 128/192/256비트 키, 10/12/14 라운드, SPN 구조
    - SKIPJACK : 64비트 블록, 80비트 키, 32라운드, Feistel 변형
    - IDEA : 64비트 블록, 128비트 키, 8라운드, Feistel+SPN구조(스위스)
    - SEED : 128비트블록, 128비트 키, 16라운드, Feistel 구조(한국)
    - ARIA : 128비트블록, 128/192/256비트 키, 12/14/ 16라운드, SPN 구조(한국)
    - LEA : 128비트블록, 128/192/256비트 키, 24/28/32라운드, SPN 구조(한국, 경량)

- 스트림암호 알고리즘
    - LFSR : 선형 피드백 시프트 레지스터
    - RC4 : 인터넷 보안 프로토콜에서 널리 사용
    - A5 : GSM 통신에서 사용

- 공개키암호 알고리즘(비대칭키)
    - 소인수 분해 : RSA,Rabin
    - 이산대수 : Diffie-Hellman, DSA, ELGamal
    - 타원곡선 : ECC

- 단방향암호 알고리즘
    - MD5 : 빠른 계산 속도, 취약점 발견
    - SHA : NIST(미국 국립표준기술연구소)에 의해 개발된 해시 함수
    - HAS-160 : 한국에서 개발된 해시 함수, KCDSA(디지털서명)에 사용

- 무차별 대입 공격 → 키스트레칭
- 레인보우 테이블 공격 → 솔팅

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 7
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int a = 3, b = 4, c = 3, d = 5;
		if((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d)) {
			a = b + c;
			if(7 == b ^ c != a) {
				System.out.println(a);
			}
			else {
				System.out.println(b);
			}
		}
		else {
			a = c + d;
			if(7 == c ^ d != a) {
				System.out.println(a);
			}
			else {
				System.out.println(d);
			}
		}
	}
}
```


- if((a == 2|a == c) & !(c > d) & (1 == b ^ c != d))
    - a==2는 거짓이므로 0이 되고, a==c는 3==3이기 때문에 참이므로 1이 된다.
    - c>d는 3>5이므로 거짓이기 때무에 0이 되지만, 앞에 !(NOT 연산)이 있어 !0인 1이 된다.
    - 1==b는 거짓이므로 0이 되고, c!=d는 3!=5(3과 5는 다름)이 참이므로 1이 되기 때문에 0^1은 XOR 연산에 의해 참이 되어 1이 된다.
- a = b + c;
    - b는 4, c는 3이므로 a는 4+3인 7이 된다.
- if(7 == b ^ c != a)
    - if 문에서 7==b는 거짓이라 0이 되고, c != a는 3 != 7이므로 참이라 1이 되므로 if(7 == b ^ c != a)는 if(0^1)과 같고, 0과 1을 2진수로 바꿨을 때 같은 자리끼리 XOR 연산하면 1이므로 if(1)이 되어 if문 조건을 만족하므로 a 값인 7을 출력한다.

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 37
> 

```c
#include <stdio.h>

void main() {
	int *arr[3];
	int a = 12, b = 24, c = 36;
	arr[0] = &a;
	arr[1] = &b;
	arr[2] = &c;
	
	printf("%d\n", *arr[1] + **arr +1);
}
```

- arr이라는 **포인터 배열**을선언
- arr[0]에 a 변수의 **주솟값을 저장**
- arr[1]에 b 변수의 주솟값을 저장
- arr[2]에 c 변수의 주솟값을 저장
- **arr[1]에 b에 주솟값이 저장**되어 있으므로 ***arr[1]은 b 변수의 값인 24**가 되고, ****arr은 *arr[0]과 같으므로** a 변수의 값인 12가 되기 때문에 24 + 12 + 1인 37이 출력

- 데이터_타입 배열명[요소]; 일 때 다음 코드는 동일하다.
    
    
    | 배열의 주소 | 배열명 == &배열명[0]; |
    | 배열의 0번지 값 | 베열명[0] == *배열명; |

- **arr은 *(*arr)과 같고, *arr은 arr[0]과 같으므로 **arr은 *arr[0]으로 바꿀 수 있다.

---

Q. 다음 SQL의 실행 결과를 쓰시오.

> 5
> 

[SOO] 테이블

| NAME |
| --- |
| SOPHIA |
| OLIVIA |
| SEMA |

[JEBI]

| RULE |
| --- |
| S% |
| %A% |

```sql
SELECT COUNT(*) CNT
FROM SOO
CROSS JOIN JEBI
WHERE SOO.NAME LIKE JEBI.RULE;
```

- SOO 테이블과 JEBI 테이블을 CROSS JOIN을 수행하면 다음과 같다.

```sql
SELECT SOO.NAME, JEBI.RULE
FROM SOO
CROSS JOIN JEBI;
```

[결과] 테이블

| NAME | RULE |
| --- | --- |
| SOPHIA | S% |
| OLIVIA | %A% |
| SEMA | S% |
| SOPHIA | %A% |
| OLIVIA | S% |
| SEMA | %A% |

- WHERE 조건절이 수행이 되면 다음과 같다.

```sql
SELECT SOO.NAME, JEBI.RULE
FROM SOO
CROSS JOIN JEBI
WHERE SOO.NAME LIKE JEBI.RULE;
```

[결과]

| NAME | RULE |
| --- | --- |
| SOPHIA | S% |
| SEMA | S% |
| SOPHIA | %A% |
| OLIVIA | %A% |
| SEMA | %A% |

- SELECT 절에서 COUNT 함수를 사용하면 다음과 같다.

```sql
SELECT COUNT(*) CNT 
FROM SOO
CROSS JOIN JEBI
WHERE SOO.NAME LIKE JEBI.RULE;
```

[결과] 테이블

| CNT |
| --- |
| 5 |


---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> False
> 

```python
a, b = 100, 200
print(a==b)
```

- a는 100, b는 200이 대입
- a와 b는 값이 다르므로 거짓

---

**Q. UML의 유형 중 () 다이어그램은 속성, 메서드를 포함하는 다이어그램이다. () 안에 들어갈 용어를 쓰시오.**

> 클래스(Class)
> 

- 클래스 다이어그램은 객체 지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램이다.
- 클래스 다이어그램의 구성요소는 **클래스 이름, 속성, 연산(=메서드), 접근 제어자, 관계**가 있다.
    - 클래스(Class)
        - 공통의 속성, 연산(메서드), 관계, 의미를 공유하는 객체들의 집합
    - 속성(Attribute)
        - 클래스의 구조적 특성에 이름을 붙인 것으로 특성에 해당하는 인스턴스가 보유할 수 있는 값의 범위를 기술
    - 연산(Operation), 메서드
        - 이름, 타입, 매개변수들과 연관된 행위를 호출하는데 요구되는 제약사항들을 명시하는 클래스의 행위적 특징
        - 객체에 요청하여 **행동에 영향**을 줄 수 있는 서비스
    - 접근 제어자(Access Modifier)
        - 클래스에 접근할 수 있는 정도를 표현
            - `-`: 클래스 내부 접근만 허용(private)
            - `+`: 클래스 외부 접근을 허용(public)
            - `#`: 동일 패키지/파생 클래스에서 접근 가능(protected)
            - `~`: 동일 패키지 클래스에서 접근 가능(default)

- 구조적 다이어그램(Structure Diagram)
    - 클래스 다이어그램
        - 시스템의 클래스와 이들 간의 관계를 표현
    - 패키지 다이어그램
        - 시스템의 패키지와 이들 간의 관계를 표현
    - 복합체 구조 다이어그램
        - 시스템 내의 복합 구조를 표현
    - 객체 다이어그램
        - 시스템 내의 객체와 이들 간의 관계를 표현
    - 컴포넌트 다이어그램
        - 시스템의 물리적 구조, 즉 컴포넌트와 그 상호작용을 표현
    - 배치 다이어그램
        - 시스템의 물리적 배치와 구성요소들 간의 관계를 표현

- 행위 다이어그램(Behavior Diagra)
    - 유스 케이스 다이어그램
        - 시스템의 기능과 사용자 간의 상호작용을 표현
    - 시퀀스 다이어그램
        - 객체 간의 상호작용을 시간 순서에 따라 표현
    - 커뮤니케이션 다이어그램
        - 객체 간의 상호작용과 통신을 표현
    - 상태 다이어그램
        - 객체의 생명주기 동안의 상태 변화를 표현
    - 활동 다이어그램
        - 시스템의 프로세스 또는 워크플로우를 표현
    - 상호작용 다이어그램
        - 시스템의 상호작용을 하나의 고수준 워크플로우로 표현
    - 타이밍 다이어그램
        - 객체의 행동과 시간에 따른 상호작용을 표현

---

**Q. 디자인 패턴의 종류 중 () 패턴은 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다. ()안에 알맞은 패턴을 영어로 쓰시오.**

> Factory Method
> 

- Factory Method(팩토리 메서드) 패턴은 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴이다.
- Factory Method 패턴은 생성할 객체의 클래스를 국한하지 않고 객체를 생성한다.

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 501
> 

```c
#include <stdio.h>

struct Soojebi {
	char name[20];
	int os, db, hab1, hab2;
};

void main() {
	struct Soojebi s[3] = { {"데이터1", 95, 88}, 
													{"데이터2", 84, 91}, 
													{"데이터3", 86, 75} }; // s는 100번지를 가짐
	struct Soojebi *p;
	
	p = &s[0]; // p는 100번지(0행)을 가지게 된다.
	(p+1)->hab1 = (p+1)->os+(p+2)->db; // p 변경코드 없으므로 p는 여전히 100이다.
	(p+1)->hab2 = (p+1)->hab1 + p->os + p->db;
	
	printf("%d\n", (p+1)->hab1 + (p+1)->hab2);
}
```

- stdio.h 헤더파일을 include 함
- Soojebi 구조체를 선언함
- 크기가 20인 char 배열 name을 선언함
- 정수형 변수 os, db, hab1, hab2를 선언함

- main 함수를 선언함
- 크기가 3인 Soojebi **구조체 배열 변수 s**를 선언하고 각각 초기화함
- s[0]의 name은 “데이터1”, os는 95, db는 88, hab1은 0, hab2는 0이 됨
- s[1]의 name은 “데이터2”, os는 84, db는 91, hab1은 0, hab2는 0이 됨
- s[2]의 name은 “데이터3”, os는 86, db는 75, hab1은 0, hab2는 0이 됨

- **구조체 포인터 변수 p**를 선언함
- **s[0]의 주소를 가져오기 위해 ‘&’를 앞에 붙이**고 **구조체 포인터 변수 p에 대입**하여, p는 s[0], (p+1)는 s[1], (p+2)는 s[2]의 주소를 가리키게 함
- (p+1)→os값 84와 (p+2)→db 값 75를 합한 값 159를 (p+1)->hab1 변수에 대입함
- (p+1)->hab1 값 159와 p->os 값인 95, p->db의 값인 88을 합한 342를 (p+1)->hab2에 대입함
- (p+1)->hab1과 (p+1)->hab2를 합한 값 501을 화면에 출력함

---

Q. 다음이 설명하는 용어를 쓰시오.

> 인덱스(Index)
> 
- ()은/는 데이터베이스에서 <키값, 주소> 형태의 자료구조이다.
- 데이터베이스 파일 구조에는 순차, (), 해싱 접근 방법이 있다.

- 인덱스는 검색 연산의 최적화를 위해 데이터베이스 내 값에 대한 주소 정보로 구성된 데이터 구조이다.
- 데이터베이스 파일 구조는 다음과 같다.
    - 순차 방법
        - 레코드들의 물리적 순서가 레코드들의 논리적 순서와 같게 순차적으로 저장하는 방법
    - 인덱스 방법
        - 인덱스가 가리키는 주소를 따라 원하는 레코드에 접근할 수 있도록 하는 방법
        - <키값, 주소>의 쌍으로 구성
    - 해싱 방법
        - 키값을 해시 함수(Hash Function)에 대입시켜 계산한 결과를 주소로 사용하여 레코드에 접근하게 할 수 있는 방법

- 인덱스(Index)의 개념
- 인덱스는 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
    - 인덱스는 데이터가 저장된 물리적 구조와 밀접한 관계가 있음
        - 실제 데이터가 저장된 물리적인 저장장치의 주소값으로 인덱스 구성
    - 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공함
    - 인덱스를 통해서 파일의 레코드에 대한 액세스를 빠르게 수행할 수 있음
    - 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적임
        - 데이터의 삽입, 삭제가 일어날 때마다 인덱스 역시 수정해줘야 함
    - 데이터 정의어(DDL)를 이용하여 사용자가 생성, 변경, 제거할 수 있음
    - 인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 확인하는 TABLE SCAN이 발생함
    - 기본키를 위한 인덱스를 기본 인덱스라 하고, 기본 인덱스가 아닌 인덱스들을 보조 인덱스라고 함
    - 대부분의 관계형 데이터베이스 관리 시스템에서는 모든 기본키에 대해서 자동적으로 기본 인덱스를 생성함
    - 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터드(Clustered) 인덱스라고 함
        - 인덱스의 키의 순서에 따라 데이터가 정렬되어 저장됨
    - 인덱스는 인덱스를 구성하는 구조나 특징에 따라 트리 기반 인덱스, 비트맵 인덱스, 함수 기반 인덱스, 비트맵 조인 인덱스, 도메인 인덱스 등으로 분류됨.
        
        ![이미지](/assets/img/exam/previous/2021(3)_1.png)
        
        ![이미지](/assets/img/exam/previous/2021(3)_2.png)
        

---

Q. 사용자가 그래픽 환경을 기반으로 한 마우스, 전자펜 등을 이용하는 사용자 인터페이스는 무엇인가?

> GUI(Graphical User Interface)
> 

- 사용자가 그래픽 환경을 기반으로 한 마우스, 전자펜 등을 이용하는 사용자 인터페이스는 GUI이다.
- GUI의 유형은 다음과 같다.
    - CLI(Command Line Interface)
        - 정적인 텍스트 기반 인터페이스(Character User Interface)
        - 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스
    - GUI(Grahical User Interface)
        - 그래픽 반응 기반 인터페이스
        - 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 사용자 인터페이스
    - NUI(Natural User Interface)
        - 직관적 사용자 반응 인터페이스
        - 키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스
        - 터치, 음성 포함
    - OUI(Organic User Interface)
        - 유기적 상호 작용 기반 인터페이스
        - 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스
    - VUI(Voice User Interface)
        - 목소리
    

---

Q. ( ① ) 테스트는 최하위 모듈로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 테스트와 통합을 수행하는 방식이고, 하위 모듈을 포함하는 ( ② )이/가 필요하다. () 안에 들어갈 용어를 쓰시오.

> 상향식(Bottom up), 테스트 드라이버(Test Driver)
> 

- 상향식 테스트는 애플리케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트를 수행하는 방식이다.
- 상향식 테스트를 위해서는 하위 모듈을 포함하는 테스트 드라이버가 필요하다.
- 테스트 드라이버는 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미모듈이다.