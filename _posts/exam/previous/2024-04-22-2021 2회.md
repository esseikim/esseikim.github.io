---
categories: [정보처리기사, 기출문제]
---

Q. 네트워크 장치를 필요로하지 않고 네트워크 토폴로지가 동적으로 변화되는 특징이 있으며 응용 분야로는 긴급 구조, 긴급 회의, 전쟁터에서의 군사 네트워크에 활용되는 네트워크 이름을 쓰시오.

> 애드 혹 네트워크(Ad-hoc Network)
> 

- 애드 혹 네트워크(Ad-hoc Network)는 노드(Node)들에 의해 자율적으로 구성되는 기반 구조가 없는 네트워크이다.
- 애드 혹 네트워크의 특징은 다음과 같다.
    - 네트워크의 구성 및 유지를 위해 기지국이나 액세스 포인트와 같은 기반 네트워크 장치를 필요로 하지 않는 네트워크
    - 애드혹(Ad-hoc) 노드들은 무선 인터페이스를 사용하여 서로 통신하고, 멀티 홉 라우팅 기능에 의해 무선 인터페이스가 가지는 통신 거리상의 제약을 극복하며, 노드들의 이동이 자유롭기 때문에 네트워크 토폴로지가 동적으로 변화되는 특징이 있음
    - 애드 혹 네트워크는 완전 독립형이 될 수 도 있고, 인터넷 게이트웨이를 거쳐 인터넷과 같은 기반 네트워크와 연동될 수 있음
    - 응급 분야로는 긴급 구조, 긴급회의, 전쟁터에서의 군사 네트워크 등이 있음
    
- 무선 네트워크 구성 방식
    - 애드 혹 네트워크(Ad-hoc Network)
        - 센서망, 재난망에 사용되며 구성이 빠르고 모든 단말이 동등한 자격으로 망을 구성
        - 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트(Mobile Host)만을 이용하여 구성한 네트워크
            - 두개의 스마트폰은 무선공유기를 통해 서로 패킷(데이터)을 전송, 애드 혹 네트워크는 무선 공유기 없이 스마트폰에서 스마트폰으로 직접 데이터를 주고 받음
        - 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합함
    - Infrastructure 네트워크 - 이동통신망, Wi-Fi에 사용되며 중앙집중형 방식
        - **네트워크 슬라이싱(Network Slicing)**
        - 네트워크에서 하나의 물리적인 코어 네트워크 인프라 (Infrastructure)를 독립된 다수의 가상 네트워크로 분리하여 각각의 네트워크를 통해 다양한 고객 맞춤형 서비스를 제공하는 것을 목적으로 하는 네트워크 기술
        - 3GPP를 포함한 여러 글로벌 이동통신 표준화 단체가 선정한 5G(IMT-2020)의 핵심기술 중 하나임(3GPP: 이동통신 국제표준을 위해 각국 통신관련 기관들이 참여하는 기술협력기구)
    - 메시 네트워크(Mesh Network), 망형 네트워트
        - 무선백본망에 사용되며 신뢰성이 우수하고, 계층적인 구조를 가지고 있음
        - 차세대 이동통신, 홈네트워킹, 공공 안전 등 특수 목적을 위한 새로운 방식의 네트워크 기술
            - 인터넷 망을 이용하지 않고, 컴퓨터와 컴퓨터를 직접 연결하여 정보를 주고받는 네트워크 형태
        - 대규모 디바이스의 네트워크 생성에 최적화되어 있음
        
        ![이미지](/assets/img/exam/previous/2021(2)_1.png)
        
        ![이미지](/assets/img/exam/previous/2021(2)_2.png)
        

---

Q.  다음이 설명하는 용어를 쓰시오.

> UX(User Experience), UI(User Interface)
> 

(1) 사람의 감정이나 경험을 나타내는 개념

(2) 사용자 인터페이스. 예로는 CLI이 있다.

- UX(User Experience): 제품과 시스템, 서비스 등을 사용자가 직/간접적으로 경험하면서 느끼고 생각하는 총체적 경험을 의미
- UI(User Interface)
    - 넓은 의미에서 사용자와시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체
    - UI의 유형에는 CLI, GUI, NUI, OUI가 존재

---

**Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.**

> 26
> 

```python
a=100
i=0
result=0
for i in range(1,3);
   result = a >> i
   result += 1
print(result)
```

- i가 1일 때 a >> i는 100 >> 1이므로 result에는 50이 저장되고, result 값에 1을 증가시키므로 51이 됨
- i가 2일 때 a >> i는 100 >> 2이므로 result에는 25가 저장되고, result 값에 1을 증가시키므로 26이 됨
- 26을 출력

- 들여쓰기 주의, a의 값 변경은 없으므로 100으로 >> 연산 수행한다.

---

Q. 다음 [회원] 테이블에서 회원번호가 N4인 튜플의 전화번호를 수정하는 쿼리를 작성하시오.

> UPDATE, SET
> 

```sql
  ①   회원   ②   전화번호 = '010-14' WHERE 회원번호 = 'N4';
```

- UPDATE는 데이터의 내용을 변경할 때 사용하는 명령어이다.
    
    ```sql
    UPDATE 테이블명
    SET 속성명 = 데이터, ...
    WHERE 조건;
    ```
    

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 8
> 

```c
#include <stdio.h>

void main(){
	int ary[3] = {1};
	int s = 0;
	int i = 0;
	
	ary[1] = *(ary+0)+2;
	ary[2] = *ary+3;
	
	for(i=0; i<3; i++){
	  s=s+ary[i]
	}
	
	printf("%d",s);

}
```

- ary라는 배열에 0번지 값만 1로 초기화하므로 **1, 2번지에는 0으로 초기화**
- *(ary+0)은 ary[0]과 같고, ary[0]의 값인 1에 2를 더하므로 ary[1]은 3이 됨
- *ary는 ary가 가리키는 값인 1에 3을 더하므로 ary[2]는 4가 됨
- s에 ary[0], ary[1], ary[2]를 더하므로 1+3+4가 되어 s는 8이 저장됨
- 8을 출력

---

Q. [학생정보] 테이블과 [학과정보] 테이블을 조인하려고 한다. 밑줄 친 곳을 채워 알맞은 쿼리를 작성하시오.

> ON, 학과
> 

[학생정보] 테이블

| 학번 | 이름 | 학과 |
| --- | --- | --- |
| 1001 | 홍길동 | 컴퓨터 |
| 1002 | 장길산 | 보안 |
| 1003 | 임꺽정 | 빅데이터 |
| 1004 | 강은미 | 인공지능 |

[학과정보] 테이블

| 학과 | 지도교수 |
| --- | --- |
| 컴퓨터 | 두음쌤 |
| 보안 | 보안쌤 |
| 빅데이터 | 지기쌤 |
| 인공지능 | 수제비쌤 |

```sql
SELECT 학생정보.학번, 학생정보.이름, 학과정보.학과, 학과정보.지도교수
FROM 학생정보
[INNER] JOIN 학과정보
  ①   학생정보.학과 = 학과정보.  ②  ;
```

- JOIN 절에는 조인조건으로 ON을 사용한다.
- 교차 조인
    
    ```sql
    SELECT 컬럼1, 컬럼2, ...
    FROM 테이블1
    CROSS JOIN 테이블2
    [WHERE 검색조건];
    ```
    
    - 조인 조건이 없는 모든 데이터 조합을 추출하기 때문에 ON절이 없음
- 셀프 조인
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ... B.컬럼1, B.컬럼2
    FROM 테이블1 A
    [INNER] JOIN 테이블1 B
    [WHERE 검색조건];
    ```
    

---

Q. 트랜잭션 원자성에 대해 설명하시오.

> 원자성은 트랜잭션을 구성하는 연산 전체가 모두 정상적으로 실행되거나 모두 취소되어야 하는 성질이다.
> 
> 
> 원자성은 트랜잭션의 연산 전체가 성공 또는 실패(All or Nothing) 되어야 하는 성질이다.
> 

- 트랜잭션은 4가지 특성을 가지며 원자성은 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장한다.
- 원자성(Atomicity)
    - 트랜잭션을 구성하는 연산 전체가 모두 정상적으로 실행되거나 모두 취소되어야 하는 성질
    - 트랜잭션의 연산 전체가 성공 또는 실패(All or Nothing)되어야 하는 성질
- 일관성(Consistency)
    - 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것
    - 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 하는 성질
- 독립성(Isolation)
    - 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우, 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어 들 수 없다는 점
    - 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 한다는 성질
- 지속성(Durability)
    - 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장되어야 하는 성질
    - 트랜잭션이 성공적으로 완료되었을 경우에 결과는 영구적으로 반영되어야 한다는 점

---

Q. 다음은 부분 함수 종속성을 제거하여 완전 함수 종속을 만족하는 ()정규형이다. () 안에 알맞은 정규형을 쓰시오.

> 2정규형
> 

[수강강좌] 테이블

| 학생번호 | 강좌이름 | 강의실 | 성적 |
| --- | --- | --- | --- |
| 501 | 데이터베이스 | 공학관 110 | 3.5 |
| 401 | 데이터베이스 | 공학관 110 | 4.0 |
| 402 | 스포츠경영학 | 체육관 103 | 3.5 |
| 502 | 자료구조 | 공학관 111 | 4.0 |
| 501 | 자료구조 | 공학관 111 | 3.5 |

[수강] 테이블

| 학생번호 | 강좌이름 | 성적 |
| --- | --- | --- |
| 501 | 데이터베이스 | 3.5 |
| 401 | 데이터베이스 | 4.0 |
| 402 | 스포츠경영학 | 3.5 |
| 502 | 자료구조 | 4.0 |
| 501 | 자료구조 | 3.5 |

[강의실]테이블

| 강좌이름 | 강의실 |
| --- | --- |
| 데이터베이스 | 공학관 110 |
| 스포츠경영학 | 체육관 103 |
| 자료구조 | 공학관 111 |

- 부분 함수적 종속성 : 기본키의 부분집합이 결정자가 되어버린 현상
- 데이터베이스 정규화 단계는 다음과 같다.
    - 제 1정규형(NF): 도메인이 원자값으로 구성
    - 제 2정규형(NF): 부분 함수 종속 제거(완전 함수적 종속 관계)
    - 제 3정규형(NF): 이행 함수 종속 제거
    - 보이스-코드 정규형(BCNF) : 결정자이면서 후보키가 아닌 함수 종속 제거
    - 제 4정규형(4NF) : 다치(다중 값) 종속 제거
    - 제 5정규형(5NF) : 조인 종속 제거

---

Q. 미국 국립 표준 기술연구소(NIST)에서 발표한 블록 암호화 알고리즘으로 DES의 성능문제를 극복하기 위해 개발된 128bit의 블록 크기를 갖는 보안 알고리즘은?

> AES(Advanced Encryption Standard)
> 

- AES(Advanced Encryption Standard)의 특징은 다음과 같다.
    - 2001년 미국 표준 기술 연구소(NIST)에서 발표한 블록 암호화 알고리즘
    - DES의 개인 키에 대한 전사적 공격이 가능해지고, 3 DES의 성능 문제를 극복하기 위해 개발
    - 블록 크기는 128bit이며, 키 길이에 따라 128bit, 192bit, 256bit로 분류
    - AES의 라운드 수는 10, 12, 14라운드로 분류되며, 한 라운드는 SubBytes, ShiftRows, MixColumns, AddRoundKey의 4가지 계층으로 구성

- 개인키 암호화(Private Key Encryption) 기법
    - 동일한 키로 데이터를 암호화, 복호화하는 암호화 기법
    - 대칭 암호 기법 또는 단일키 암호화 기법이라고도함
    - 암호화/복호화 속도가 빠르지만, 관리해야 할 키의 수가 많음(사람마다 서로 다른 키를 나눠줘야 함)
    - 개인키 암호화 기법의 종류
        
        ![이미지](/assets/img/exam/previous/2021(2)_3.png)
        
    
- 공개키 암호화(Public Key Encryption) 기법
    - 데이터를 암호화할 때 사용하는 공개키(Public Key)는 사용자에게 공개 하고, 복호화할 때의 비밀키(Secret Key)는 관리자가 비밀리에 관리하는 암호화 기법
    - 비대칭 암호 기법이라고도함
    - 관리해야 할 키의 수가 적지만, 암호화/복호화 속도가 느림
    - 대표적으로는 RSA(Rivest Shamir Adleman) 기법이 있음

- 양방향 알고리즘의 종류
- 대칭 키 암호화 방식의 종류는 다음과 같다.
    - 블록 암호화 방식
        - DES(Data Encryption Standard)
            - 1975년 미국의 연방 표준국(NIST)에서 발표한 대칭 키 기반의 블록 암호화 알고리즘
            - 블록 크기는 64bit, 키 길이는 56bit인 페이스텔(Feistel) 구조
            - DES를 3번 적용하여 보안을 더욱 강화한 3 DES(Triple DES)도 활용됨
        - SEED
            - 1999년 국내 한국인터넷진흥원(KISA)이 개발한 블록 암호화 알고리즘
            - 128bit 비밀키로부터 생성된 16개의 라운드 키를 사용하여 총 16회의 라운드를 거쳐 128bit의 평문 블록을 128bit 암호화블록으로 암호화하여 출력하는 방식
            - 블록 크기는 128bit이며, 키 길이에 따라 128bit, 256bit로 분류
        - AES(Advanced Encryption Standard)
            - 2001년 미국 표준 기술 연구소(NIST)에서 발표한 블록 암호화 알고리즘
            - DES의 개인 키에 대한 전사적 공격이 가능해지고, 3 DES의 성능 문제를 극복하기 위해 개발
            - 블록 크기는 128bit이며, 키 길이에 따라 128bit, 192bit, 256bit로 분류
            - AES의 라운드 수는 10, 12, 14라운드로 분류되며, 한 라운드는 SubBytes, ShiftRows, MixColumns, AddRoundKey의 4가지 계층으로 구성
        - ARIA(Academy, Research Institute, Agency)
            - 2004년 국가정보원과 산학연구협회가 개발한 블록 암호화 알고리즘
            - ARIA는 학계(Academy), 연구기관(Research Institute), 정부(Agency)의 영문 앞글자로 구성
            - 블록 크기는 128bit이며, 키 길이에 따라 128bit, 192bit, 256bit로 분류
            - ARIA는 경량 환경 및 하드웨어에서의 효율성 향상을 위해 개발되었으며, ARIA가 사용하는 대부분의 연산은 XOR과 같은 단순한 바이트 단위 연산으로 구성
        - IDEA(International Data Encryption Algorithm)
            - 스위스의 라이(Lai)와 메시(Messey)가 1990년에 개발한 PES를 개선한 알고리즘
            - DES를 대체하기 위해 스위스 연방기술 기관에서 개발한 블록 암호화 알고리즘
            - 128bit의 키를 사용하여 64bit의 평문을 8라운드에 거쳐 64bit의 암호문을 만듦
            - 블록 크기는 64비트이고, 키 길이는 128비트임
        - Skipjack
            - 국가 안전 보장국(NSA)에서 개발한 암호화 알고리즘
            - 클리퍼 칩(Clipper Chip)이라는 IC 칩에 내장되어 사용
            - 블록 크기는 64비트이고, 키 길이는 80비트임
            - 주로 음성 통신 장비에 삽입되어 음성 데이터를 암호화함
        
    - 스트림 암호화 방식
        - TKIP(Temporal Key Integrity Protocol)
            - 무선랜 보안에 사용된 WEP을 보완한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라고도 함
            - WEP의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키 할당, 키값 재설정 등 키 관리 방식을 개선하였음
        - LFSR(Linear Feedback Shift Register)
            - 선형 되먹임 시프트 레지스터(LFSR)는 시프트 레지스터의 일종으로, 레지스터에 입력되는 값이 이전 상태 값들의 선형 함수로 계산되는 구조로 되어 있는 스트림 암호화 알고리즘
            - 이때 사용되는 선형 함수는 주로 배타적 논리합(XOR)이고, LFSR의 초기 비트 값은 시드(Seed)라고 함
    
- 비대칭 키(공개 키) 암호화 방식의 종류는 다음과 같다.
    - 디피-헬만(Diffie-Hellman)
        - 최초의 공개키 알고리즘으로 W.Diffie와 M.Hellman이 1976년 고안한 알고리즘으로서 유한 필드 내에서 이산대수의 계산이 어려운 문제를 기본 원리로 하고 잇음
        - Diffie-Hellman은 공개키 암호 방식의 개념을 이용하여 두 사용자 간에 공통의 암호화 키를 안전하게 공유할 방법을 제시하였으며, 많은 키 분배 방식에 관한 연구의 기본이 됨(최초의 비밀키 교환 프로토콜)
    - RSA(Rivest-Shamir-Adleman)
        - 1977년 3명의 MIT 수학 교수(Rivest, Shamir, Adleman)가 고안한 큰 인수의 곱을 소인수분해하는 수학적 알고리즘을 이용하는 공개키 암호화 알고리즘
        - 비밀키의 복호화가 어려운 RSA 안정성은 소인수분해 문제의 어려움에 근거를 두고 있음
            
            ![이미지](/assets/img/exam/previous/2021(2)_4.png)
            
    - ECC(Elliptic Curve Cryptography)
        - 1985년 코블리치와 밀러가 RSA 암호 방식에 대한 대안으로 처음 제안
        - 타원 곡선 암호(ECC)는 유한체 위에서 정의된 타원곡선 군에서의 이산대수의 문제에 기초한 공개키 암호화 알고리즘
        - PKI 기반의 RSA의 문제점인 속도와 안정성을 해결하기 위해 타원 기반 구조체의 안정성과 효율성을 기반으로 생성되었고, RSA보다 키의 비트 수를 적게 하면서 동일한 성능을 제공하는 것이 가장 큰 특징
    - ElGamal
        - T.ElGamal이 1984년에 제안한 공개키 알고리즘
        - 이산대수의 계산이 어려운 문제를 기본 원리로 하고 있으며, RSA와 유사하게 전자서명과 데이터 암∙복호화에 함께 사용 가능

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 11
> 

```java
public class over1 {
	public static void main(String[] args){
    	ovr1 a1 = new ovr1();
      ovr2 a2 = new ovr2();
      
      System.out.print(a1.san(3,2) + a2.san(3,2));
  }
    
  int san(int x, int y){
  	return x + y;
  }
}

class ovr2 extends ovr1 {
	int san(int x, int y){
    	return x - y + super.san(x,y);
  }
}
```

- ovr1 클래스의 main 함수에서 a1.san(3,2)+a2.san(3,2)의 결과를 구해야 한다.
- a1.san(3,2)는 ovr1 클래스의 san 함수이고, ovr1 클래스의 san 함수는 입력받은 2개의 값을 더한 3+2인 5를 반환한다.
- a2.san(3,2)는 ovr2 클래스의 san 함수이고, ovr2 클래스의 san 함수는 x-y에서 상위 클래스의 san 함수를 호출하고 반환한 값을 더해주는데, super.san(3,2)는 ovr1 클래스의 san 함수이므로 입력받은 두 개의 값인 3+2인 5를 반환해주게 되므로 3-2+5인 6을 반환한다.
- ovr1 클래스의 main 함수에서 a1.san(3,2) + a2.san(3,2)은 5+6이므로 11이 되어 11을 출력하게 된다.

---

**다음은 C언어 코드이다. 출력 결과를 쓰시오.**

> 1024
> 

```c
#include <stdio.h>

int Soojebi(int base, int exp) {
	int i, result = 1;
	for(i=0; i<exp; i++)
      result *= base;
   return result;
}

void main() {
	printf("%d", Soojebi(2, 10));
}
```

- Soojebi 함수에서 base와 exp를 매개변수로 전달받는다.
- 정수형 변수 i를 선언하고, 정수형 변수 result를 1로 선언과 동시에 초기화한다.
- for 반복문은 i 값이 0부터 exp까지 i 값을 1씩 증가시키면서 result *= base;를 수행한다.
- for 반복문이 종료되고 result를 리턴한다.
- printf 함수에서 2의 10승인 1024를 출력하는데 포맷 스트링이 “%d”이므로 10진수인 1024를 출력한다.

---

Q. 럼바우 데이터 모델링 중에서 다음이 설명하는 모델링 유형을 보기에서 골라서 쓰시오.

> Function, Dynamic, Information
> 

① 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현하는 모델링으로 자료 흐름도(DFD)를 활용하여 표현

② 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작, 순서 등의 동적인 행위를 표현하는 모델링으로 상태 다이어그램을 활용하여 표현

③ 시스템에서 요구하는 객체를 찾고 객체 간의 관계를 정의하여 ER 다이어그램을 만드는 과정까지의 모델링으로 객체 다이어그램으로 활용하여 표현

- 객체 모델링(Object Modeling)
    - 정보 모델링(Information Modeling)이라고도 하며, 시스템에서 요구되는 객체를 찾고 객체 간의 관계를 규정하여 **ER 다이어그램**을 만드는 과정까지의 모델링
- 동적 모델링(Dynamic Modeling)
    - 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동적 순서 등의 동적인 행위를 표현하는 모델링
    - **상태 다이어그램**을 활용하여 표현
    - 시퀀스 다이어그램
    - 커뮤니케이션 다이어그램
    - 상태 다이어그램
- 기능 모델링(Functional Modeling)
    - 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현한 모델링
    - **자료흐름도(DFD)**를 활용하여 표현
    - 유스케이스(Use Case) 다이어그램
    - 활동, 액티비티(Activity) 다이어그램

- 기능 모델링: 사용자관점, 시스템이 제공할 수 있는 기능, 기능에 중점을 두고 표현하는 방법
- 정적 모델링: 개발자 관점, 시스템 내부의 구성요소들을 표현하는 방법(ex, 클래스 다이어그램)
- 동적 모델링: 시스템 설계자가 시간에 흐름에 따라 변하는 시스템 내부 구성요소의 상태를 파악하기 위해 그림으로 표현

---

Q. 화이트박스 테스트 검증 기준(=커버리지)를 쓰시오.

> 구문(문장), 결정(분기), 조건
> 

① 최소 한번은 모든 **문장** 수행

② 결정(Decision) 검증기준이라고도 함. 조건 별 True/False일 때 수행

③ ②와 달리 전체 조건식을 무시하며,  전체 조건식에 상관없이 개별 조건식의 True/False 수행

---

Q. 다음 [학생] 테이블을 이용해 이름이 이로 시작하는 학생들에 대해 내림차순 정렬하려고 한다. 쿼리의 빈칸에 알맞은 키워드를 쓰시오.

> **"**이%**"**, DESC
> 

```sql
SELECT *
FROM 학생
WHERE 이름 LIKE   ①  
ORDER BY 이름   ②  ;
```

---

Q. 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법은 무엇인지 쓰시오.

> 로킹(Locking)
> 

- 병행제어(Concurrency Control)
    - 병행제어란 다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것
- 병행제어의 목적
    - 데이터베이스의 공유를 최대화함
    - 시스템의 활용도를 최대화함
    - 데이터베이스의 일관성을 유지함
    - 사용자에 대한 응답 시간을 최소화함
- 병행제어 기법의 종류
    - 로킹(Locking)
        - 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock(잠금)을 요청해서 Lock이 허락되어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법
        - 주요 데이터의 액세스를 상호 배타적으로 함
    - 타임 스탬프 순서(Time Stamp Ordering)
        - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기전에 시간표(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
        - 직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중에서 가장 보편적인 방법임
    - 최적 병행수행(검증 기법,  확인 기법, 낙관적 기법)
        - 병행수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read Only) 트랜잭션일 경우, 트랜잭션 간의 충돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법
    - 다중 버전 기법
        - 타임 스탬프의 개념을 이용하는 기법
        - 다중 버전 타임 스탬프 기법이라고도 함
        - 타임 스태프 기법은 트랜잭션 및 데이터들이 이용될 때의 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때 마다의 버전을 부여하여 관리함
    - 로킹 단위(Locking Granularity)
        - 로킹 단위는 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미 함
        - 데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있음
        - 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아짐
        - 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 로킹 오버헤드가 증가하지만 병행성 수준이 높아짐 - 데이터베이스 공유도 증가

---

Q. 다음은 자바 코드이다. 밑줄 친 곳에 들어갈 키워드를 쓰시오.

> static
> 

```java
public class Soojebi {
	public static void main(String[] args){
		System.out.print(Soojebi.check(1));
	}
   
        String check (int num) {
     return (num >= 0) ? "positive" : "negative";
  }
}

[출력결과] positive
```

- 객체 생성 없이 메서드를 사용하기 위해서는 static 키워드를 사용하여 메서드를 선언한다.

---

Q.  디자인 패턴 중에서 (   )패턴은 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 클래스나 객체들이 상호작용하는 방법, 알고리즘 등과 관련된 패턴이다. () 안에 들어갈 용어를 쓰시오.

> 행위(Behavioral)
> 

[예시]

Interpreter, Observer, Command, Iterator, Strategy, Visitor

- 행위패턴은 객체나 클래스 간의 교류 방법에 대해 정의하는 방법을 제시한다.
    - 행위패턴 클래스 : Interpreter, Template Method
    - 행위패턴 객체 : Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Visitor

---

**Q.** 테스트 하네스 구성요소 중 모듈 통합 테스트에서 사용하는 요소로 상향식 통합 테스트에서는 테스트 드라이버, 하향식 통합 테스트에서는 테스트 ( )을/를 사용한다. () 안에 들어갈 용어를 쓰시오.

> 스텁(Stub)
> 

- 테스트 하네스 : 애플리케이션의 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로 테스트를 지원하기 위해 생성된 코드와 데이터를 의미하며, 테스트가 실행될 환경을 시뮬레이션하며 컴포넌트 및 모듈이 정상적으로 테스트 되도록 하는 도구, 코드 개발자가 작성하는 요소임
- 테스트 하네스 구성요소는 다음과 같다.
    - 테스트 드라이버
        - 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 후 결과를 도출하는 도구
        - 상향식 통합 시험을 위해 모듈 테스트 수행 후의 결과를 도출하는 시험용 모듈
    - 테스트 스텁
        - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 하향식 통합시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈
    - 테스트 슈트
        - 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
    - 테스트 케이스
        - 입력 값, 실행조건, 기대 결과 등의 집합
    - 테스트 시나리오
        - 애플리케이션의 테스트 되어야 할 기능 및 특징, 테스트가 필요한 상황을 작성한 문서로 하나의 단일 테스트 시나리오가 하나 또는 여러 개의 테스트 케이스들을 포함할 수 있음
    - 테스트 스크립트
        - 자동화된 테스트 실행 절차에 대한 명세서
    - 목 오브젝트
        - 사전에 사용자의 행위를 조건부로 입력해두면, 그 상황에 맞는 예정된 행위를 수행하는 객체

---

Q. 다음이 설명하는 패킷 교환 방식을 쓰시오.

> 가상 회선 방식, 데이터그램 방식
> 

① 목적지 호스트와 미리 연결한 후 통신하는 연결형 교환 방식

② 헤더에 붙여서 개별적으로 전달하는 비연결형 교환 방식

| 데이터그램 | 가상회선 |
| --- | --- |
| 연결 경로를 확립하지 않고 각각의 패킷을 순서에 무관하게 독립적으로 전송하는 방식 | 패킷이 전송되기 전에 송∙수신 스테이션 간의 논리적인 통신 경로를 미리 설정하는 방식 |
| 헤더를 붙여서 개별적으로 전달하는 비연결형 교환방식 | 목적지 호스트와 미리 연결 후 통신하는 연결형 교환 방식 |

- 패킷 교환 방식(Packet Switching)은 메시지를 일정한 길이의 패킷으로 잘라서 전송하는 방식으로, 가상 회선 방식과 데이터그램 방식이 있음
    - 가상 회선 방식
        - 단말기 상호 간에 논리적인 가상 통신 회선을 미리 설정하여 송신지와 수신지 사이의 연결을 확립한 후에 설정된 경로를 따라 패킷들을 순서적으로 운반하는 방식
        - 정보 전송 전에 제어 패킷에 의해 경로가 설정됨
        - 모든 패킷은 같은 경로로 발생 순서대로 전송됨. 즉 패킷의 송•수신 순서가 같음
    - 데이터그램 방식
        - 연결 경로를 설정하지 않고 인접한 노드들의 트래픽(전송량) 상황을 감안하여 각각의 패킷 들을 순서에 상관없이 독립적으로 운반하는 방식
        - 패킷마다 전송 경로가 다르므로, 패킷은 목적지의 완전한 주소를 가져야 함
        - 순서에 상관없이 여러 경로를 통해 도착한 패킷들은 수신 측에서 순서를 재정리함
    
    ![이미지](/assets/img/exam/previous/2021(2)_4.png)
    

- 회선 교환 방식(비 저장 방식)
    - 물리적 전용선을 활용하여 데이터 전달 경로가 정해진 후 동일 경로로만 전달
    - 데이터를 동시에 전송할 수 있는 양을 의미하는 대역폭이 고정되고 안정적인 전송률을 확보할 수 있음(ex, 전화망)

---

Q. 다음이 설명하는 응집도 종류를 쓰시오.

> 절차적 응집도(Procedural Cohesion), 교환적 응집도(Communication Cohesion) 또는 통신적 응집도, 기능적 응집도(Functional Cohesion)
> 

1. 입출력 간 연관성은 없으나, 순서에 따라 수행될 필요가 있음

2. 동일한 입력과 출력 사용하여 다른 기능을 수행하는 활동

3. 모듈 내부의 모든 기능이 단일한 목적을 위해 수행


<br>
**참고 자료**

---

- [https://m.blog.naver.com/jhst3103/221851513130 - 메시 네트워크](https://m.blog.naver.com/jhst3103/221851513130)