---
categories: [정보처리기사, 기출문제]
---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 10
> 
> 
> 11
> 
> 10
> 
> 20
> 

```java
class Static {
	public int a = 20;
	static int b = 0;
}
public class Soojegi {
	public static void main(String[] args) {
		int a;
		a = 10;
		Static.b = a;
		Static st = new Static();
		System.out.println(Static.b++);
		System.out.println(st.b);
		System.out.println(a);
		System.out.print(st.a);
	}
}
```

- 자바에서 main 메서드 실행 전에 **static 변수가 먼저 실행**
- Static 클래스 내에 static int b = 0;에 의해 b라는 static 변수에 0을 대입
- **main 메서드** 실행
- main 내부의 a 변수에 10을 대입한다.
    
    
    | 0 | Static.b |
    | 10 | a |
- **main 내의 a 변수값 10을 Static.b 변수에 대입**
    
    
    | 10 | Static.b |
    | 10 | a |
- Static 클래스가 st 변수에 할당
    
    
    | 20 | st.a |
    | 10 | Static.b(또는 st.b) |
    | 10 | a |
- System.out.println(Static.b++);에 의해 Static.b 값인 10이 출력되고, Static.b의 값이 1 증가
    
    
    | 20 | st.a |
    | 11 | Static.b(또는 st.b) |
    | 10 | a |
- st.b는 11, a는 10, st.a는 20이므로 11, 10, 20이 출력

---

Q. 다음은 C 코드이다. 출력 결과를 쓰시오.

> Art
> 
> 
> A
> 
> A
> 
> Art
> 
> Art
> 

```c
#include <stdio.h>
int main() {
	char a[] = "Art";
	char* p = NULL;
	int i = 0;
	
	
	p = a;
	printf("%s\n", a);
	printf("%c\n", *p);
	printf("%c\n", *a);
	printf("%s\n", p);
	
	for(i=0; a[i] != '\0'; i++) {
		printf("%c", a[i]);
	}
return 0;
}
```

- main 함수부터 시작
- 문자형 배열 a에 “Art” 저장
- 문자형 포인터 p에 NULL 저장
- i라는 이름의 정수형 변수를 0으로 초기화
- p의 값에 **a를 대입**
    - **a는 배열이므로 &a[0]과 같음**
    - p = a이므로 a랑 p는 같음
    
    | a[0], p[0] | a[1], p[1] | a[2], p[2] | a[3], p[3] |
    | --- | --- | --- | --- |
    | A | r | t | NULL |

- 배열 a에 저장된 모든 값 “Art” 출력
    - a는 &a[0]과 같으므로 printf(”%s\n”, a);는 a[0]번지에 있는 A부터 NULL 전의 값인 t까지 출력
    
    | a == &a[0] | 배열+i == &배열[i];에서 배열 자리에 a를 i 자리에 0을 넣음 |

- p가 가리키는 a의 0번지의 값 “A”를 출력
    - *p는 p[0]와 같으므로 printf(”%c\n”, *p);는 p[0]번지 값인 A를 출력
    - *p == &p[0]
- a는 p와 같으므로 “A” 출력
    - *a는 a[0]과 같으므로 printf("%c\n", *a);는 a[0]번지 값인 A를 출력
    - *a == &a[0]
- p는 a와 같으므로 “Art” 출력
    - p는 &p[0]와 같으므로 printf("%s\n", p);는 a[0]번지에 있는 A부터 NULL 전의 값인 t까지 출력
    - p == &p[0]
- for 문을 통해 i=0부터 a[i] != '\0'가 거짓일 때까지 반복
- a[0], a[1], a[2]의 값 “Art”를 순서대로 출력

| i | a[i] | a[i] != '\0' |
| --- | --- | --- |
| 0 | a[0] == ‘A’ | 참 |
| 1 | a[1] == ‘r’ | 참 |
| 2 | a[2] == ‘t’ | 참 |
| 3 | a[3] == NULL | 거짓 |

- NULL이 ‘\0’이므로 a[3]의 값인 **NULL과 ‘\0’은 같기 때문에 a[i] != '\0'은 거짓이 되어 반복문을 탈출**

---

Q. 다음은 C 코드이다. 출력 결과를 쓰시오.

> qwe
> 

```c
#include <stdio.h>
void main() {
	char* a = "qwer";
	char* b = "qwety";
	int i, j;
	for(i=0; a[i] != '\0'; i++) {
		for(j=0; b[j] != '\0'; j++) {
			if(a[i] == b[j])
				printf("%c", a[i]);
		}
	}
}
```

- main 함수부터 시작
- a 포인터에 다음과 같이 문자열이 저장
    
    
    | a[0] | a[1] | a[2] | a[3] | a[4] |
    | --- | --- | --- | --- | --- |
    | q | w | e | r | NULL |
- b 포인터에 다음과 같이 문자열이 저장
    
    
    | a[0] | a[1] | a[2] | a[3] | a[4] | a[5] |
    | --- | --- | --- | --- | --- | --- |
    | q | w | e | t | y | NULL |
- i와 j라는 이름의 정수형 변수를 선언
- for(i=0; a[i] != '\0'; i++) 명령어를 통해 i=0부터 a[i] != '\0'가 거짓일 때까지 반복하고, for(j=0; b[j] != '\0'; j++) 명령어를 통해 j=0부터 b[j] != '\0'가 거짓일 때까지 반복

---

Q. 다음 중 빈칸에 공통으로 들어갈 용어를 쓰시오.

> AJAX(Asynchronous Javascript And XML)
> 
- ()은/는 웹에서 Javascript, XML을 이용하여 비동기식으로 웹 페이지의 일부 콘텐츠만 리로드(Reload) 해오는 방식이다.
- ()은/는 하이퍼텍스트 표기 언어(HTML)만으로는 어려운 다양한 작업을 웹 페이지에서 구현해서 이용자가 웹 페이지와 자유롭게 상호 작용할 수 있도록 구현하는 기법이다.
- Google Maps와 Google ()에서 이러한 방식을 사용한다.

- AJAX는 자바스크립트를 사용하여 웹 서버와 클라이언트 간 비동기적으로 XML 데이터를 교환하고 조작하기 위한 웹 기술이다.
- AJAX는 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 로드하지 않고 필요한 일부 페이지의 데이터만을 로드하는 기법이다.

---

Q. 패킷 교환 방식에서 패킷이 전송되기 전에 송/수신 스테이션 간의 논리적인 통신 경로를 미리 설정하는 방식은 ( ① ) 방식이며, 연결경로를 확립하지 않고 각각의 패킷을 순서에 무관하게 독립적으로 전송하는 방식은 ( ② ) 방식이다. 빈칸에 들어갈 알맞은 용어를 쓰시오.

> 가상회선(Virtual Circuit), 데이터그램(Datagram)
> 

- 패킷 교환 방식에는 데이터그램 방식과 가상회선 방식이 있다.
    - 데이터그램 방식
        - 연결 경로를 확립하지 않고 각각의 패킷을 순서에 무관하게 독립적으로  전송하는 방식
        - 각각의 패킷을 독립적으로 취급하는 방식으로 앞에 보낸 메시지나 앞으로 보낼 메시지의 어떠한 결과와도 관계가 없는 단일 패킷 단위로 전송하고 수신하는 방식
        - 헤더를 붙여서 개별적으로 전달하는 비 연결형 교환 방식
    - 가상 회선 방식
        - 패킷이 전송되기 전에 송/수신 스테이션 간의 논리적인 통신 경로를 미리 설정하는 방식
        - 많은 이용자들이 상호 통신을 할 때 하나의 통신 설비를 공유하여 여러 개의 논리적인 채널을 확정한 후 통신을 할 수 있는 방식
        - 목적지 호스트와 미리 연결 후 통신하는 연결형 교환 방식

- **순서 제어(Sequencing)**
    - 순서 제어는 전송되는 데이터 블록(PDU)에 전송 순서를 부여하는 기능으로, 연결 위주의 데이터 전송 방식(가상 회선 방식)에만 사용됨
    - 송신 데이터들이 순서적으로 전송되도록 함으로써 흐름 제어 및 오류 제어를 용이하게 하는 기능을 함

- 패킷 교환 방식
    - 패킷 교환 방식(Packet Switching)은 메시지를 일정한 길이의 패킷으로 잘라서 전송하는 방식으로, 가상 회선 방식과 데이터그램 방식이 있음
    - 가상 회선 방식(자전거 라이딩 동호회)
        - 단말기 상호 간에 논리적인 가상 통신 회선을 미리 설정하여 송신지와 수신지 사이의 연결을 확립한 후에 설정된 경로를 따라 패킷들을 순서적으로 운반하는 방식
        - 정보 전송 전에 제어 패킷에 의해 경로가 설정됨
        - 모든 패킷은 같은 경로로 발생 순서대로 전송됨. 즉 패킷의 송•수신 순서가 같음
    - 데이터그램 방식
        - 연결 경로를 설정하지 않고 인접한 노드들의 트래픽(전송량) 상황을 감안하여 각각의 패킷 들을 순서에 상관없이 독립적으로 운반하는 방식
        - 패킷마다 전송 경로가 다르므로, 패킷은 목적지의 완전한 주소를 가져야 함
        - 순서에 상관없이 여러 경로를 통해 도착한 패킷들은 수신 측에서 순서를 재정리함
        

---

Q. VPN(Virtual Private Network)에서 사용되는 프로토콜 중 하나로, L2F(Layer 2 Forwarding Protocol)와 PPTP(Point-to-Point Tunneling Protocol)의 기능을 결합하여 **인터넷상**에서 **두 지점** 간에 **가상의 터널**을 만들어 **통신**을 안전하게 전송하는 **기술**은 무엇인가?

> L2TP(Layer 2 **Tunneling** Protocol)
> 

- L2F(Layer 2 Forwarding Protocol)와 PPP(Point-to-Point Tunneling Protocol)의 기능을 결합하여 인터넷상에서 두 지점 간에 가상의 터널을 만들어 통신을 안전하게 전송하는 기술은 L2TP이다.
- VPN 기술 중 2계층 터널링 프로토콜은 PPTP, L2F, L2TP이다.
    - PPTP(Point to Point Tunnel Protocol)
        - 마이크로소프트사(Microsoft)가 개발한 프로토콜로 IP, IPX 페이로드를 암호화하고, IP 헤더로 캡슐화하여 전송하여 프로토콜
        - PPP(Point-to-Point Protocol)에 기초하여 두 대의 컴퓨터가 직렬 인터페이스를 이용하여 통신할 때 사용
        - 하나의 터널에 하나의 연결만을 지원하여 일대일 통신만 가능
    - L2F(Layer 2 Forwarding)
        - 시스코사(Cisco)에서 개발한 프로토콜로 하나의 터널에 여러 개의 연결을 지원하여 다자간 통신이 가능하도록 하는 프로토콜
        - 전송 계층 프로토콜로 TCP가 아닌 UDP를 사용
    - L2TP(Layer 2 Tunneling Protocol)
        - L2F와 PPTP의 결합한 방법으로 마이크로소프트사와 시스코에서 지원하고 있으며 호환성이 뛰어난 프로토콜
        - UDP 포트가 사용되고 터널링에 대한 인증을 수행
        - 암호화와 기밀성과 같은 데이터에 보안을 제공하지 않기 때문에 **IPSec(Internet Protocol Security) 기술과 함께 사용**
    
    - OSI(Open System Interconnection) 참조 모델은 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)임
                
    - **VPN(Virtual Private Network, 가상 사설 통신망)**
    인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션
    - 연결 방식, 프로토콜에 따라 크게 두가지로 나뉨
        - SSL VPN : PC에 VPN Client 프로그램을 설치하여 **VPN 서버에 접속**하는 방식으로, 암호화를 위해 SSL 프로토콜을 사용함
        - IPSec VPN : VPN 서버가 설치된 각각의 **네트워크를 서로 연결**하는 방식으로, 암호화를 위해 IPSec 프로토콜을 사용함
            - SSL(Secure Sockets Layer), **트랜스포트(전송) 계층**
            데이터를 송•수신하는 두 컴퓨터 사이에 위치하여 **TCP/IP 계층**과 애플리케이션 계층 사이에서 **인증, 암호화, 무결성을 보장**하는 업계 표준 프로토콜 - 보안, 인증서 관련(http://~~사이트 접속 시 ‘이 사이트는 안전하지 않습니다.’ 경고 ← 서버에 SSL 안 먹여서)
            - IPsec(IP Security), **네트워크 계층**
            네트워크 계층에서 IP **패킷** 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜
                - IP계층에서 무결성과 **인증을 보호하는 인증 헤더(AH)**와 **기밀성을 보장하는 암호화(ESP)**를 이용하여 양 종단 간(End Point) 구간에 보안 서비스를 제공하는 터널링 프로토콜
                                        
                
    - **PPTP(Point to Point Tunneling Protocol)**, 지점간 터널링 프로토콜
        - PPP 패킷을 IP 패킷에 캡슐화하여 통과시키기 위한 터널링 프로토콜
        - 마이크로소프트가 제안한 VPN 프로토콜
        - PPP(Point-to-Point Protocol)에 기초 하며 두 대의 컴퓨터가 직렬 인터페이스를 이용하여 통신할 때 사용
    - **L2F(Layer 2 Forarding)**
        - 인터넷을 통한 VPN(가상 사설 통신망) 연결을 위해 개발된 터널링 프로토콜(VPN 구현)
        - 미국 시스코 시스템즈사가 개발한 VPN 프로토콜
        - PPTP나 IPSEC와 달리, 데이터 링크 층 수준에서 캡슐화가 가능하고, IP 네트워크 이외에서도 이용할 수 있음
    - **L2TP(Layer 2 Tunneling Protocol)**
        - 데이터 링크 계층에서 구현되는 터널링 프로토콜
        - 터널링 프로토콜인 PPTP와 VPN의 구현에 사용하는 L2F의 기술적 장점들을 결합하여 만든 프로토콜
        - 자체적으로 암호화 및 인증 기능을 제공하지 않아 다른 보안 프로토콜과 함께 사용되는 경우가 많다

---

Q. 포트 번호 22번을 사용하고 인증, 암호화, 압축, 무결성을 제공하며, Telnet보다 강력한 보안을 제공하는 원격 접속 프로토콜은 무엇인가?

> SSH(Secure Shell)
> 

- SSH는 Telnet보다 강력한 보안을 제공하는 원격 접속 프로토콜이다.
- 키를 통한 인증은 클라이언트의 공개키를 서버에 등록해야 하고 전송되는 데이터는 암호화된다.
- 인증, 암호화, 압축, 무결성을 제공하고 기본 포트는 22번을 사용한다.

---

Q. 괄호에 들어갈 용어를 쓰시오.

> 웜(Worm), 트로이목마(Trojan Horse), 바이러스(Virus)
> 
- ( ① )은/는 인터넷 또는 네트워크를 통해 컴퓨터에서 컴퓨터로 스스로 전파되는 악성 프로그램이다. 윈도우의 취약점 또는 응용 프로그램의 취약점을 이용하거나 이메일 또는 공유 폴더를 통해 전파되며, 최근에는 공유 프로그램인 P2P 등을 이용하여 전파되기도 한다. 가장 큰 특징은 자신을 복제하여 네트워크 연결을 통해서 다른 컴퓨터로 스스로 전파되고 확산된다는 것이다.
- ( ② )은/는 악성 루틴이 숨어 있는 프로그램으로 겉보기에는 정상적인 프로그램으로 보이지만 실행하면 악성 코드를 실행하는 프로그램이다. 자기 복제를 하지 않으며 다른 파일을 감염시키거나 변경시키지 않지만, 해당 프로그램이 포함된 프로그램이 실행되는 순간, 시스템은 공격자에게 시스템을 통제할 수 있는 권한을 부여하게 된다.
- ( ③ )은/는 사용자 컴퓨터(네트워크로 공유된 컴퓨터 포함) 내에서 프로그램이나 실행 가능한 부분을 변형해 감염(Infect)시키는 프로그램이다. 자신 또한 자신의 변형을 복사하는 프로그램으로 가장 큰 특성은 다른 네트워크의 컴퓨터로 스스로 전파되지는 않는다.

- 바이러스(Virus)
    - 사용자 컴퓨터(네트워크로 공유된 컴퓨터 포함) 내에서 실행 가능한 부분을 변형해서 감염(Infect)시키는 프로그램
    - 자신 또는 자신의 변형을 복사하는 프로그램으로 가장 큰 특성은 **다른 네트워크의 컴퓨터로 스스로 전파되지는 않음**
- 웜(Worm)
    - 인터넷 또는 네트워크를 통해 컴퓨터에서 컴퓨터로 스스로 전파되는 악성 프로그램
    - 윈도우의 취약점 또는 응용 프로그램의 취약점을 이용하거나 이메일 또는 공유 폴더를 통해 전파되며, 최근에는 공유 프로그램(P2P)를 이용하여 전파되기도 함
    - 자신을 복제하여 네트워크 연결을 통해서 다른 컴퓨터로 스스로 전파되고 확산
- 트로이목마(Trojan Horse)
    - 악성 루틴이 숨어 있는 프로그램으로 겉보기에는 정상적인 프로그램으로 보이지만 실행하면 악성 코드를 실행하는 프로그램
    - 자기 복제를 하지 않으며 다른 파일을 감염시키거나 변경시키지 않지만, 해당 프로그램이 포함된 프로그램이 실행되는 순간, 시스템은 공격자에게 **시스템을 통제할 수 있는 권한**을 부여하게 됨

---

Q. 다음은 이진수를 십진수로 변환하는 C언어 코드이다. ①, ②에 적합한 코드를 작성하시오.

> %,  10
> 

```c
#include <stdio.h>
int main() {
	int input = 101110;
	int di = 1;
	int sum = 0;
	
	while(1) {
		if (input == 0) break;
		else {
			sum = sum + (input   ①     ②  ) * di;
			di = di * 2;
			input = input / 10;  
		}
	}
	
	printf("%d", sum);
	return 0;
}
```

- 2진수를 10진수로 변환하는 프로그램이다. 2진수 101110을 10진수로 변환하기 위해서는 1x2^5 + 0x2^4 + 1x2^3 + 1x2^2 + 1x2^1 + 1x2^0과 같이 계산한다.
- C 프로그램으로 2진수를 10진수로 변환하기 위해서는 2진수의 가장 마지막 자릿수의 값을 추출한 후 자릿수가 n이면 2^n을 곱하고 그 결과를 합하는 과정을 반복한다.

- main 함수부터 시작
- 정수형 변수 input에 101110을 대입
- 정수형 변수 di에 1을 대입
- 정수형 변수 sum에 0을 대입
- while 문에서는 조건식이 참일 경우 반복을 수행하는데, 조건이 1이면 참이므로 while문을 무한 반복함
- input이 0인 경우 while 문을 탈출
- **input이 0이 아닌 경우 실행**
- input의 가장 오른쪽 숫자를 추출하여 di와 곱한 뒤 오른쪽 sum에 더한 결과를 왼쪽 sum에 대입
- 오른쪽 di와 2를 곱한 결과를 왼쪽 di에 대입
- 다음 자리수로 이동하기 위해 오른쪽 input을 10으로 나눈 몫을 왼쪽 input에 대입
- sum의 값을 출력

---

Q. IP의 동작 과정에서의 전송 오류가 발생하는 경우에 오류 정보를 전송하는 목적으로 사용하는 프로토콜로, **Ping-of-Death**에서도 사용하는 프로토콜은 무엇인가?

> ICMP(Internet Control Message Protocol)
> 

- ICMP는 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 오류 정보를 전송하는 목적으로 사용하는 프로토콜이다.
- ICMP 프로토콜을 사용해서 ping 유틸리티의 구현을 통해 오류가 발생했음을 알리는 기능을 수행한다.

---

Q. 디자인 패턴 중 객체의 대리자를 이용하여 원래 객체의 작업을 대신 처리하는 패턴을 쓰시오.

> Proxy
> 

- Proxy 패턴은 실제 객체에 대한 대리 객체로 실제 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실제 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴이다.
- 특정 **객체로의 접근을 제어**하기 위한 용도로 사용 된다.

---

Q. 다음은 데이터베이스에 관련된 내용이다. 각 괄호에 들어갈 답을 [보기]에서 골라 쓰시오.

> 튜플(Tuple), 릴레이션 인스턴스(Relation Instance) 카디널리티(Cardinality)
> 
- ( ① )은/는 테이블 내 행을 의미하며, **레코드(Record)**라고도 한다. 어떤 요소의 집합이지만 일반적인 집합과는 달리 중복이 허용될 수 있다.
- ( ② )은/는 릴레이션에 **실제로 저장된 데이터의 집합**을 의미한다. 릴레이션 또는 릴레이션 외연(Relation Extension)라고도 한다.
- ( ③ )은/는 특정 **데이터 집합의 유니크(Unique)한 값의 개수**를 의미한다.

[보기]

Tuple(튜플), 릴레이션 스키마(Relation Schema), 릴레이션 인스턴스(Relation Instance), 카디널리티(Cardinality), 디그리(Degree), 애트리뷰트(Attribute)

- 튜플
    - 어떤 요소의 집합, 혹은 테이블에서의 행
    - 일반적인 집합과는 달리 중복이 허용될 수 있음
    - 테이블 내의 행을 의미하며, **레코드(Record)**라고도 함
- 릴레이션 인스턴스
    - 릴레이션에 실제로 저장된 데이터의 집합
    - **릴레이션 외연(Relation Extension)**이라고도 함
- 카디널리티
    - 특정 데이터 집합의 유니크(Unique)한 값의 개수

- 관계형 데이터베이스 릴레이션(Relation) 구조
    - 릴레이션(Relation): 테이블
    - 튜플(Tuple)
        - 릴레이션을 구성하는 **각각의 행**
        - 속성의 모임으로 구성
        - 파일 구조에서 레코드와 같은 의미
        - 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응수 라고도 함
        - <학생> 릴레이션에서 카디널리티는 4이다.
    - 속성(Attribute)
        - 데이터베이스를 구성하는 가장 작은 논리적 단위
        - 파일 구조에서 데이터 항목 또는 데이터 필드에 해당
        - 개체의 특성을 기술
        - 속성의 수를 디그리(Degree) 또는 차수라고 함
        - <학생> 릴레이션에서 차수(디그리)는 5이다.
    - 카디널리티(Cardinality): 튜플의 수
    - 차수(Degree): 속성의 수
    - 스키마(Schema): 제약조건 등 정보 담고 있는 기본적인 DB의 구조
    - 인스턴스(Instance): 스키마에 따라 실제 저장된 데이터의 **집합**
    - 도메인(Domain)
        - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합
        - 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는 데에도 이용
        - <학생>릴레이션의 '학년' 도메인은 1~4이다.

![이미지](/assets/img/exam/previous/2023(1)_5.png)

- 튜플은 중복된 값을 허용하지 않는다고 알고 있는데, 아무런 제약조건이 없다면 튜플은 중복이 가능하다고 한다. 다만 컬럼에 **키나 UNIQUE**와 같은 것이 포함된다면 튜플끼리 중복될 수 없다.

---

Q. [학생] 테이블에서 학생 이름이 ‘민수’인 튜플을 삭제하는 쿼리를 작성하시오.

```sql
DELETE FROM 학생 WHERE 이름 = '민수';
```

---

Q. 다음은 자바 코드이다. 빈칸에 들어갈 코드를 쓰시오.(단, 변수명으로 쓰시오.)

> idx2, nx
>

```java
class Soojebi {
	static void swap(int[] a, int idx1, int idx2) {
		int t = a[idx1];
		i[idx1] = a[idx2];
		a[ ① ] = t;
	}
	
	static void Usort(int[] a, int len) {
		for(int i=0; i<len; i++) {
			for(int j=0; j<len-i-1; j++) {
				if(a[j] > a[j+1]) {
					swap(a, j, j+1);
				}
			}
		}
	}
	public static void main(String[] args) {
		int []item = {5, 4, 9, 1, 3, 7};
		int nx = 6;
		Usort(item,  ②  );
			for(int data : item) {
				System.out.print(data + " "); // 1 3 4 5 7 9
			}
	}
}
```

- 정수형 배열을 버블 정렬을 사용해 오름차순으로 정렬하는 함수를 구현하는 코드이다.
- 프로그램에서 교환할 때 구문은 a=b; b=c; c=a;의 형태가 되어야 하므로 ①은 idx2가 되어야 한다.
- Usort 메서드 호출하는 부분은 Usort(item,  ②  );이고, 전달받는 부분은 Usort(int[] a, int len)이므로 ②는 int len에 전달하는 값이다.
- main 메서드에서 int형 변수는 nx 밖에 없으므로 ②는 nx가 되어야 한다.

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> {’한국’, ‘중국’, ‘베트남’, ‘홍콩’, ‘태국’}
> 

```python
a = {'한국', '중국', '일본'}
a.add('베트남')
a.add('중국')
a.remove('일본')
a.update({'홍콩', '한국', '태국'})
print(a)
```

- **세트는 순서가 상관없는 컬렉션 자료형**이므로 출력 순서는 상관없다.
- a라는 세트형 변수에 '한국', '중국', '일본'을 초기화
- '베트남'이라는 값을 추가
- '중국'이라는 값을 추가하는데 **이미 ‘중국’이 존재하므로 무시**
- '일본'이라는 값을 제거
- update를 통해 '홍콩', '한국', '태국'을 추가하는데, ‘한국’은 이미 있으므로 ‘홍콩’, ‘태국’이 추가
- 세트 값을 출력

---

Q. 다음 중 [성적] 테이블에서 과목별로 그룹을 묶었을 때 과목 평균이 90 이상인 과목, 최소점수, 최대점수를 조회하는 쿼리를 작성하시오.

```sql
SELECT 과목, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수
FROM 성적
GROUP BY 과목
HAVING AVG(점수) >= 90;
```

[성적] 테이블

| 순서 | 과목 | 점수 |
| --- | --- | --- |
| 1 | 데이터베이스 | 91 |
| 2 | 데이터베이스 | 92 |
| 3 | 네트워크 | 78 |
| 4 | 소프트웨어 공학 | 60 |
| 5 | 네트워크 | 89 |
| 6 | 소프트웨어 공학 | 91 |

[결과]

| 과목 | 최소점수 | 최대점수 |
| --- | --- | --- |
| 데이터베이스 | 91 | 92 |

[조건]

- SQL 문은 ISO/IEC 9075 표준을 기반으로 작성해야 한다.
- WHERE절을 사용하지 않아야 한다.
- SELECT절에 별칭을 사용하여 작성해야 한다.
- SQL 구문의 마지막에는 세미콜론(;) 생략이 가능하다.
- 반드시 GROUP BY 함수와 HAVING을 사용해야 한다.
- 집계함수를 사용해야 한다.

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> Vehicle name: Spark
> 

```java
abstract class Vehicle {
	String name;
	abstract public String getName(String val);
	public String getName() {
		return "Vehicle name: " + name;
	}
	public void setName(String val) {
		name = val;
	}
}

class Car extends Vehicle {
	public Car(String val) {
		setName(val);
	}
	public String getName(String val) {
		return "Car name: " + val;
	}
	public String getName(byte val[]) {
		return "Car name: " + val;
	}
}

public class Soojebi {
	public static void main(String[] args) {
		Vehicle obj = new Car("Spark");
		System.out.println(obj.getName());
	}
}
```

- main 메서드부터 실행
- Car라는 생성자를 실행하면서 매개변수로 “Spark”를 전달
- obj 변수에 Car 클래스가 생성됨
- Car 클래스의 생성자인 Car(String val)에 “Spark”를 넘겨주면 val = “Spark”이 됨
- setName(”Spark”);으로 호출
- setName은 Vehicle 클래스에 있으므로 Vehicle 클래스의 setName 메서드에 “Spark” 값을 전달
- setName 메서드에서 매개변수로 받은 “Spark”를 val 변수에 저장
- val 값인 “Spark”를 name이라는 변수에 저장
- obj 변수의 getName 메서드를 호출
- getName에 파라미터가 없으므로 부모 클래스의 getName() 메서드를 실행하게 되고, Vehicle의 getName에 있는 "Vehicle name: " + name;을 반환
- name은 이미 new Car(”Spark”)라는 생성자에 의해서 “Spark”라는 값으로 대입이 되었기 때문에 getName에서는 “Vehicle name: ” + “Spark”인 “Vehicle name: Spark”를 받게 됨
- getName에서 반환받은 “Vehicle name: Spark”를 System.out.println 함수를 이용하여 출력

---

Q. 다음은 스키마와 관련된 내용이다. 각 괄호 안에 알맞은 답을 작성하시오.

> 외부, 개념, 내부
> 
- ( ① ) 스키마는 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조이고, 사용자 뷰를 나타내며 서브 스키마로 불린다.
- ( ② ) 스키마는 데이터베이스의 전체적인 논리적 구조이다. 전체적인 뷰를 나타내고, 개체 간의 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의한다.
- ( ③ ) 스키마는 물리적 저장 장치의 관점에서 보는 데이터베이스 구조이고, 실제로 데이터베이스에 저장될 레코드의 형식을 정의한다. 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현한다.

- 외부 스키마(External Schema)
    - 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조
    - 사용자 뷰를 나타내며, 서브 스키마로 불림
- 개념 스키마(Conceptual Schema)
    - 데이터베이스의 전체적인 논리적 구조
    - 전체적인 뷰를 나타내며, 개체 간의 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의
- 내부 스키마(Internal Schema)
    - 물리적 저장 장치의 관점에서 보는 데이터베이스 구조
    - 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장
    - 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현

---

Q. 다음 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.

> ① 1, 2, 3, 4, 5, 6, 7 / 1, 2, 4, 5, 6, 1 ② 1, 2, 3, 4, 5, 6, 1 / 1, 2, 4, 5, 6, 7
> 

- 분기 커버리지(결정 커버리지)는 각 분기의 결정 포인트 내의 전체 조건식이 적어도 한 번은 참(T)과 거짓(F)의 결과를 수행해야 하기 때문에 첫 번째 분기문도 참, 거짓이 한 번씩 와야 하고, 두 번째 분기문도 참, 거짓이 한 번씩 와야 한다.
    
    
    | 첫 번째 분기문이 참이고, 두 번째 분기문이 거짓일 경우 | 1, 2, 3, 4, 5, 6, 7 |
    | 첫 번째 분기문이 거짓이고, 두 번째 분기문이 참일 경우 | 1, 2, 4, 5, 6, 1 |
    | 첫 번째 분기문과 두 번째 분기문이 둘 다 참일 경우 | 1, 2, 3, 4, 5, 6, 1 |
    | 첫 번째 분기문과 두 번째 분기문이 모두 거짓일 경우 | 1, 2, 4, 5, 6, 7 |
- 답은 2개 이다.

---

**Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.**

> 500
> 

```java
class Parent {
	int x = 100; 
	Parent() {
		this(500);
	}
	Parent(int x) {
		this.x = x;
	}
	int getX() {
		return x;
	}
}

class Child extends Parent {
	int x = 4000; 
	Child() {
		this(5000);
	}
	Child(int x) {
		this.x = x;
	}
}

public class Soojebi {
	public static void main(String[] args) {
		Child obj = new Child();
		System.out.println(obj.getX());
	}
}
```

- main 메서드부터 실행
- new Child()에 의해 클래스를 생성하고, 클래스를 생성하면서 생성자를 호출
- 생성자는 자식 클래스(Child) 생성자의 **첫 번째 명령어에서 호출되지 않으므로** 부모 클래스(Parent)의 생성자 중 **파라미터가 없는 생성자인 Parent() 호출**하고, 그 다음에 자식 클래스(Child) 생성자를 호출
- 부모 클래스인 Parent 클래스의 생성자인 Parent()를 호출
- this(500)로 Parent 클래스에서 매개변수를 1개 가지는 Parent(int x) 생성자를 호출하고 x에 500을 매개변수로 전달
- **Parent(int x) 생성자가 this(500)에 의해 호출**되고, **this.x = x;**에 의해 x 값인 500을 **Parent 클래스의 변수 x에 대입**
- 자식 클래스인 Child 클래스의 생성자인 Child()를 호출
- this(5000)로 Child 클래스에서 매개변수를 1개 가지는 Child(int x)생성자를 호출하고 x에 5000을 매개변수로 전달
- Child(int x) 생성자가 this(5000)에 의해 호출되고, this.x;에 의해 5000을 this.x인 Child 클래스의 변수 x에 대입(Parent 클래스 변수 x에는 500, Child 클래스 변수 x에는 5000이 저장)
- getX() 메서드 호출
- **Parent 클래스에 있으므로 Parent 클래스의 x값**인 500을 반환

- this
    - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
    - 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다. → 선언x, 사용 가능
- this(), this (매개변수)
    - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
    - 클래스 이름 대신에 this() 사용