---
categories: [Certificate, "[정보처리기사] 기출문제(20~23년)"]
---

Q. 물리 네트워크(MAC) 주소에 해당하는 IP 주소를 알려주는 프로토콜로 역순 주소 결정 프로토콜을 무엇이라고 하는지 쓰시오.

> RARP (Reverse Address Resolution Protocol)
> 

- RARP(Reverse Address Resolution Protocol)는 IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만, 논리적인 주소인 IP 주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜이다.
- 네트워크 계층(3계층) 프로토콜에는 IP, ARP, RARP, ICMP, IGMP, 라우팅 프로토콜이 있다.
    - IP(Internet Protocol)
        - 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신 프로토콜
    - ARP(Address Resolution Protocol)
        - IP 네트워크상에서 IP 주소를 MAC 주소(물리 주소)로 변환하는 프로토콜
    - RARP(Reverse Address Protocol)
        - IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP 주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜
    - ICMP(Internet Control Message Protocol)
        - IP 패킷을 처리할 때 발생하는 문제를 알려주는 프로토콜
        - 메시지 형식은 8bit의 헤더와 가변길이의 데이터 영역으로 분리
        - 수신지 도달 불가 메시지는 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는 데 사용
        - ICMP 프로토콜을 사용해서 ping 유틸리티의 구현을 통해 오류가 발생했음을 알리는 기능을 수행
    - IGMP(Internet Group Management Protocol)
        - 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용하는 통신 프로토콜
        - 화상회의, IPTV에서 활용되는 프로토콜
        - IGMP 기능에는 그룹 가입, 멤버십 감시, 멤버십 응답, 멤버십 탈퇴가 있음
    - 라우팅 프로토콜(Routing Protocol)
        - 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜

 

- OSI 7계층은 국제표준화기구(International Standard Organization, ISO)에서 발표한 네트워크 표준 모델로써 네트워크 통신의 각 과정을 계층별로 개념화한 모델이기에 각 계층의 구간별로 데이터의 움직임을 알 수 있고, 장치간의 데이터 통신을 설명하는데 유용하게 활용됨
    
    [1계층] 물리 계층 : 전선, 전파, 광섬유, 동축케이블, 도피관, PSTN, DSU, CSU, Modem
    
    [2계층] 데이터 링크 계층 : Ethernet, ToKen Ring, PPP, HDLC, ISDN, ATM
    
    [3계층] 네트워크 계층 : IP, ARP, RARP, ICMP, IGMP, 라우팅 프로토콜
    
    [4계층] 전송 계층 : TCP, UDP, RTCP, SCTP, SPX
    
    [5계층] 세션 계층 : TLS, SSH, ISO 8327 / CCITTX225, RPC, NetBIOS
    
    [6계층] 표현 계층 : JPEG, MPEG, XDR, ASN1, SMB, AFP
    
    [7계층] 응용 계층 : HTTP, SMTP, SNMP, FTP, Telnet, SSH&SCP, NFS, RTSP
    

---

Q. 다음은 DB 설계 절차에 관한 설명이다. 다음 빈칸에 들어갈 알맞은 용어를 쓰시오.

> 물리적 설계, 개념적 설계, 논리적 설계
> 
- (   ①   )은/는 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있다.
- (   ②   )은/는 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산출물에는 E-R 다이어그램이 있다.
- (   ③   )은/는 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행한다.

[보기] 

구현 / 개념적 설계 / 논리적 설계 / 요구사항 분석 / 물리적 설계

- DB 설계 절차에는 요구사항 분석, 개념적 설계, 논리적 설계, 물리적 설계, 구현이 있다.
    - 요구사항 분석
        - 사용자에게서 데이터베이스를 사용하는 용도를 파악함
        - 다양한 요구사항을 수집하는 단계로 요구사항 명세서를 작성함
    - 개념적 설계
        - 요구사항 명세서를 기반으로 개념적 데이터 모델을 표현하며 E-R 다이어그램으로 표현할 수 있음
    - 논리적 설계
        - 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행함
    - 물리적 설계
        - 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 잇음
    - 구현
        - SQL 문을 실행하여 데이터베이스를 실제로 생성함

---

Q. 다음은 요구사항의 분류에 대한 설명이다. 괄호 (   ) 안에 들어갈 요구사항의 유형에 대해서 쓰시오.

> 기능(적), 비기능(적)
> 
- ( ① ) 요구사항은 시스템이 제공하는 기능, 서비스에 대한 요구사항이다.
- ( ② ) 요구사항은 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항이다.

- 요구사항의 분류는 다음과 같다.
    - 기능적 요구사항
        - 시스템에서 제공해야 할 기능, 서비스에 대한 요구사항
        - 특정 입력에 대해 시스템이 어떻게 반응해야 하는지에 대한 기술
        - 특정 상황에 대해 시스템이 어떻게 동작해야 하는지에 대한 기술
        - 기능성, 완전성 일관성
        - 온라인 홈페이지에서는 쇼핑카트에 주문하고자 하는 품목을 저장할 수 있는 장바구니 기능을 제공해야 함
        - 상품의 결제수단은 신용카드, 무통장 입금, 포인트 결제가 가능해야 함
        - 입력기능, 출력기능, 데이터베이스 기능, 통신 기능 등
    - 비기능적 요구사항
        - 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항
        - 품질 속성에 관련하여 시스템이 갖춰야 할 사항에 관한 기술
        - 시스템이 준수해야 할 제한 조건에 관한 기술
        - 신뢰성, 사용성, 효율성, 유지보수성, 이식성 및 품질 관련 요구사항, 제약사항
        - 특정 함수의 호출은 3초를 넘지 않아야 함
        - 시스템은 하루 24시간 가동되어야 하며 가동률 99.5%를 만족해야 함
        - 시스템은 운영되는 중에 패치 및 업그레이드를 할 수 있어야 함
        - 성능적인 면: 응답 속도, 자원 사용량 등
        - 보안 측면: 침입 대응, 침입 탐지, 사용자 인증, 권한 부여 등

- 요구 도출은 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계이다.
- 요구 분석은 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대해 이해하는 단계라 할 수 있다.
- 도메인 분석은 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 하게 된다.

---

Q. 웹 서비스명, 제공 위치, 메세지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구성된 언어를 무엇이라고 하는지 쓰시오.

> WSDL(Web Service Description Language)
> 
- 서비스 기술언어로 Web Service가 제공하는 서비스에 대한 정보를 기술하기 위한 XML 기반의 마크업 언어
- 웹서비스와 관련된 서식이나 프로토콜을 표준적인 방법으로 기술하고 게시하기 위한 언어

- WSDL은 SOAP와 XML 스키마와 결합하여 인터넷상에 웹 서비스를 제공하기 위해 사용되기도 한다.
- UDDL
    - 웹 서비스에 대한 정보의 공개 및 검색에 대한 방법을 정의하는 XML 기반의 공용 디렉토리 또는 프로토콜의 집합체를 의미하는 용어
    - 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스트리이자 표준
    - 인터넷에서 전세계의 비지니스 업체 목록에 자신의 정보를 등록하기 위한 확장성 언어(XML) 기반의 규격, WSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용됨
- SOAP(Simple Object Access protocol)
    - HTTP, HTTPS, SMTP 등을 이용하여 XML을 교환하기 위한 통신 규약 (RESTful 프로토콜로 대체 가능)
        
        ![이미지](/assets/img/exam/previous/2021(1)_1.png)
        

- 마크업 언어: 서식이나 문서 내, 외의 다른 요소와의 연결 등을 표현하는 부호를 정의하여 다른 문서의 논리 구조나 체계를 정의하는 언어
- XML: 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어
- RESTful 프로토콜: HTTP와 REST(Representational State Transfer)의 원칙을 사용하여 구현되는 웹서비스로, HTTP로 자원을 관리하는 데 사용되는 웹서비스 API의 집합

- ESB(Enterprise Service Bus)
    - 메시지 기반으로 느슨한 결합형태의 표준 인터페이스 통신을 지원하는 미들웨어, 버스형, 외부와 연동
    - 기업 안팎에 있는 모든 시스템 환경을 연동하는 미들웨어
    - 구성요소 → Rest(Json 구조의 이동)
        - SOAP: 실제 통신 프로토콜
        - UDDI: 도서관
        - WSDL: 설명서, XML(eXtensible Markup Language)

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> SKIDDP
> 

```python
class Soojebi:
    li = ["Seoul", "Kyeonggi", "Inchon", "Daejoen", "Deagu", "Pusan"] # 멤버 리스트

s = Soojebi()
str01 = ' ' # 공백: 빈 문자열
for i in s.li:
    str01 = str01 + i[0]
    
print(str01)
```

- Soojebi 클래스를 선언하고 리스트 li에는 "Seoul", "Kyeonggi", "Inchon", "Daejoen", "Deagu", "Pusan"으로 초기화한다.
- Soojebi() 클래스 객체 s를 생성한다.
- str01는 ‘’로 초기화한다.
- for 반복문은 s.li 만큼 i 값을 반복한다. 오른쪽 str01에 i[0] **문자열을 합하여** 왼쪽 str01에 대입한다.
- str01을 화면에 출력한다.
- 들여쓰기 미적용 시 concat 결과를 반복마다 자동개행하며 출력한다.

---

Q. 다음 SQL 실행 결과를 숫자만 쓰시오.

> 1
> 

[급여]

![이미지](/assets/img/exam/previous/2021(1)_2.png)

```sql
SELECT COUNT(*) FROM 급여
WHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;
```

- **AND** 연산자는 OR 연산자보다 **우선순위**가 **높다**.
- EMPNO > 100이므로 EMPNO가 100 초과인 200, 300에 해당하며 SAL >= 3000이므로 SAL은 3000만 해당한다.
- 두 조건이 AND이므로 둘 다 참인 데이터만 해당하며 COUNT 결과는 1이 된다.

| EMPNO | SAL |
| --- | --- |
| 200 | 3000 |

---

Q. 다음 Java 프로그램 결과를 쓰시오.

> 3
> 
> 
> 1 
> 
> 45 
> 
> 50
> 
> 89
> 

```java
public class Soojebi{
	public static void main(String []args){
	int[][] arr = new int[][]{ {45, 50, 75}, {89} };
	System.out.println(arr[0].length);
	System.out.println(arr[1].length);
	System.out.println(arr[0][0]);
	System.out.println(arr[0][1]);
	System.out.println(arr[1][0]);
	}
}
```

- 2차원 배열을 선언하고 초깃값으로 45, 50, 75, 89로 초기화한다.

---

Q. 정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 무엇이라고 하는지 쓰시오.

> 반정규화 또는 비정규화 또는 역정규화
> 

- 반정규(De-Normalization)는 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법으로 비정규화, 역정규화라고도 불린다.
- 반정규화를 위해서는 데이터의 일관성과 무관성을 우선으로 할지 데이터베이스의 성능과 단순화에 우선순위를 둘 것인지를 비교하여 조정하는 과정이 중요하다.
    - 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가
    
    ![이미지](/assets/img/exam/previous/2021(1)_3.png)
    
    ![이미지](/assets/img/exam/previous/2021(1)_4.png)
    

---

Q. 다음은 블랙박스 기법에 대한 예제이다. 블랙박스 기법 두 가지를 쓰시오.

> 경계값 분석, 동등 분할(동치 분할, 균등 분할, 동치 클래스 분해)
> 

① 0 <= x <= 10이면 -1 0 10 11 검사

② 입력 데이터의 영역을 유사한 도메인별로 유횻값 / 무효값을 그룹핑하여 나누어서 검사

- 블랙박스 테스트(Black-Box Test) 또는 명세 기반 테스트는 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 기능 테스트이며, 소프트웨어의 특징, 요구사항, 설계 명세서 등에 초점을 맞춰 이뤄지는 테스트이다.
- 블랙박스 테스트의 유형은 다음과 같다.
    - 동등분할 테스트 = 동치분할 테스트, 균등 분할 테스트, 동치 클래스 분해 테스트(Equivalence Partitioning Testing)
        - 입력 데이터의 영역을 유사한 도메인별로 유효 값/무효 값을을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트하는 기법
    - 경곗값 분석 테스트 = 한곗값 테스트(Boundary Value Analysis Testing)
        - 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법
        - 최솟값 바로 위, 최대치 바로 아래 등 입력값의 극한 한계를 테스트하는 기법
        - 경곗값은 클래스 간의 경곗값, 경계 바로 위 값, 경계 바로 아래 값이 있음
    - 원인-결과 그래프 테스트(Cause-Effect Graphing Testing)
        - 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법
    - 비교 테스트(Comparison Testing)
        - 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해 보는 테스트 기법
    - 오류 추정 테스트(Error Guessing Testing)
        - 개발자가 범할 수 있는 실수를 추정하고 이에 따른 결함이 검출되도록 테스트 케이스를 설계하여 테스트하는 기법
        - 특정 테스트 대상이 주어지면 테스터의 경험과 직관을 바탕으로 개발자가 범할 수 있는 실수들을 나열하고, 해당 실수에 따른 결함을 노출하는 테스트로 다른 블랙박스 테스트 기법을 보완할 때 사용하는 기법
    - 결정 테이블 테스트(Decision Table Testing)
        - 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법
    - 분류 트리 테스트(Classification Tree Method Testing)
        - SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법
    - 페어와이즈 테스트(Pairwise Testing)
        - 테스트 데이터값 간에 최소한 한 번씩은 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 기법
    - 상태 전이 테스트(State Transition Testing)
        - 테스트 대상∙시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법
    - 유스케이스 테스트(Use Case Testing)
        - 시스템이 실제 사용되는 유스케이스로 모델링 되어있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법

---

Q. 다음은 테스트 종류에 대한 설명이다. 빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.

> 단위 테스트, 통합 테스트
> 
- ( ① ) 은/는 개별 모듈, 서브루틴이 정상적으로 실행되는지 확인
- ( ②) 은/는 인터페이스 간 시스템이 정상적으로 실행되는지 확인

[보기] 

시스템 테스트 / 인수 테스트 / 알파 테스트 / 단위 테스트 / 통합 테스트 / 회귀 테스트

| 테스트 | 설명 |
| --- | --- |
| 단위 테스트 | 사용자의 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계 |
| 통합 테스트 | 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 단계 |
| 시스템 테스트 | 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 테스트 단계 |
| 인수 테스트 | 계약상의 요구사항이 만족하였는지 확인하기 위한 단계 |
| 알파 테스트 | 선택된 사용자(회사 내의 다른 사용자 또는 실제 사용자)가 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 인수 테스트 |
| 베타 테스트 | 실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 인수 테스트 |
| 회귀 테스트 | 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정 때문에 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법 |

- 개발 단계에 따른 애플리케이션 테스트
    - 소프트웨어의 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 분류됨 이렇게 분류된 것을 테스트 레벨이라고 함
    - 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것을 V-모델이라고 함
        
        ![이미지](/assets/img/exam/previous/2021(1)_5.png)
        
- 단위 테스트(Unit Test)
    - 단위 테스트는 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것
    - **인터페이스**, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사함
    - 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행함
    - 구조 기반 테스트(화이트박스 테스트, 복잡도 위주)와 명세 기반 테스트(블랙박스 테스트, 기능 위주)로 나뉘지만 주로 구조 기반 테스트를 시행함
- 통합 테스트(Integration Test)
    - 통합 테스트는 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미함
    - 통합 테스트는 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법
    - 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사함
    - 비점진적 통합 방식 - 빅뱅 통합 테스트 방식(모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트)
    - 점진적 통합 방식 - 하향식, 상향식, 혼합식 통합 테스트
- 시스템 테스트
    - 구현된 시스템이 정해진 요건에 적합한지 여부를 평가하기 위해 실제 운용과 같은 환경에서 시스템 전체에 대해서 행하는 테스트
    - 시스템 테스트는 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트임
    - 기능적 요구사항과 비기능적 요구사항으로 구분하여 각각을 만족하는지 테스트함
- 인수 테스트
    - 인수 테스트는 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 개발한 소프트웨어를 **사용자가 직접** 테스트함
    - 사용자 인수 테스트
        - 사용자가 시스템 사용의 적절성 여부를 확인함
    - 운영상의 인수 테스트
        - 시스템 관리자가 시스템 인수 시 수행하는 테스트 기법
        - 백업/복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등을 확인함
    - 계약 인수 테스트
        - 계약상의 인수/검수 조건을 준수하는지 여부를 확인함
    - 규정 인수 테스트
        - 소프트웨어가 정부 지침, 법규, 규정 등 규정에 맞게 개발되었는지 확인함
    - **알파** 테스트
        - 특정 사용자들에 의해 개발자 관점에서 수행 (가장 자주 사용)
        - **개발자의 장소**에서 사용자가 **개발자 앞에서** 행하는 테스트 기법
        - 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록함
    - **베타** 테스트
        - **선정된 최종 사용자**가 **여러 명의 사용자 앞에서** 행하는 테스트 기법
        - 실업무를 가지고 사용자가 직접 테스트
    - 회귀 테스트
        - 어플리케이션에 대하여 변경, 결함 수정 또는 기능개선 등과 같은 원인으로 프로그램 코드에 대하여 물리적인 변경이 발생했을 경우, 새로운 결함에 대비하여 이미 실시했던 테스트케이스를 재시험하는 테스트
        - 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트
        - 회귀 테스트는 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트
        - 이미 테스트된 프로그램의 테스팅을 반복하는 것

---

Q. 다음은 빈칸에 들어갈 알맞은 용어를 쓰시오.

> 128, 8
> 
- IPv6는 ( ① ) 비트 길이를 가진다.
- IPv4는 길이 32bit이며, ( ② ) 비트씩 네 부분으로 나눈다.

- IPv6는 주소길이가 128bit이고 IPv4는 32bit이다.
- IPv4와 IPv6 특징
    
    
    | 구분 | IPv4 | IPv6 |
    | --- | --- | --- |
    | 주소 길이 | 32Bit | 128Bit |
    | 표시 방법 | 8비트씩 4부분으로 나뉜 10진수(192.168.10.1) | 16비트씩 8부분으로 나뉜 16진수(2001:9e76:..:e11c) |
    | 주소 개수 | 약 43억 개 | 3.4x10^38 |
    | 주소 할당 | A, B, C, D 등 클래스 단위 비순차적 할당(비효율적) | 네트워크 규모 및 단말기 수에 따른 순차적 할당(효율적) |
    | 품질 제어 | 품질보장 곤란 | 등급별, 서비스별로 패킷 구분 가능해 품질보장 용이(QoS) |
    | 헤더 크기 | 가변 | 고정 |
    | QoS | Best Effort 방식 / 보장 곤란 | 등급별, 서비스별 패킷 구분 보장 |
    | 보안 기능 | IPSec 프로토콜 별도 설치 | 확장 기능에서 기본 제공 |
    | Plug & Play | 지원 안함 | 지원 |
    | 모바일 IP | 곤란 | 용이 |
    | 웹 캐스팅 | 곤란 | 용이 |
    | 전송방식 | 유니캐스트, 멀티캐스트, 브로드캐스트 | 유니캐스트, 멀티캐스트, 애니캐스트 |

- IP(Internet Protocol)
    - OSI 7계층의 네트워크 계층에 해당함
    - 데이터그램을 기반으로 하는 비연결형 서비스를 제공함
    - Best Effort 원칙에 따른 전송 기능을 제공함
    - 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공함
    - 헤더의 길이는 최소 20Byte에서 최대 60Byte이다.
    - IP 헤더에는 Version, Header Length, Total Packet Length, Header, Checksum, Source IP Address, Destination IP Address 등이 포함됨
    
- IPv4 & IPv6 비교
    - IP 주소(Internet Protocol Address)
        - IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소
    - IPv4
        - 8비트씩 4부분, **총 32비트**로 구성되어 있음 ← `.`으로 구분, 10진수
        - IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있음, **비** 순차적 할당
        - 호스트 주소를 자동으로 설정하며, 클래스별로 네트워크와 호스트 주소의 길이가 다름
        - 20-60 바이트의 가변 길이의 헤더 크기, 패킷에 대한 보안을 신경씀
            
            ![이미지](/assets/img/exam/previous/2021(1)_6.png)
            
        - IPv4은 다음과 같이 세 가지 주소 체계로 나누어짐
            - 유니캐스트(Unicast): 단일 송신자와 단일 수신자 간의 통신(1 대 1 통신에 사용), 아는 사람
            - 멀티캐스트(Multicast): 단일 송신자와 다중 수신자 간의 통신(1대 다 통신에 사용)
            - **브로드**캐스트**(Broadcast)**: 로컬 네트워크에 연결되어 있는 모든 시스템에게 프레임을 보내는 방식, 방송용, 효율 떨어짐(아무에게나 다 쏨)
            
            ![이미지](/assets/img/exam/previous/2021(1)_7.png)
            
            ![이미지](/assets/img/exam/previous/2021(1)_8.png)
            
    - IPv6(Internet Protocol version 6)
        - IPv6은 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발되었음
        - **16비트씩 8부분**으로 구성, 총 **128**비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있음 ← `:` 으로 구분, 16진수
        - **주소 자동설정(Auto Configuration)** 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬 수 있음, **네트워크 규모 및 단말기 수**에 따라 **순차**할당(자동할당, 원하면 순서대로 할당함)
        - 헤더는 40 바이트의 고정 길이, 확장 기능을 통해 보안기능을 제공
            - IP 헤더 옵션이 없음, 일반적으로, IPv6 헤더는 IPv4 헤더보다 간단함
        - IPv4에 비해 자료 전송 속도가 빠름
        - 보안과 인증 확장 헤더를 사용함으로써 인터넷 계층의 보안기능을 강화
        - 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있음
        - 주소의 확장성, 융통성, 연동성이 뛰어남
        - 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원함
        - 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없음
        - 기본 헤더 뒤에 확장 헤더를 더함으로써 더욱 다양한 정보의 저장이 가능해져 네트워크 기능 확장이 용이함
        - IPv4와 호환성이 뛰어남
            
            ![이미지](/assets/img/exam/previous/2021(1)_9.png)
            
        - IPv6은 다음과 같이 세 가지 주소 체계로 나누어짐
            - 유니캐스트(Unicast): 단일 송신자와 단일 수신자 간의 통신(1 대 1 통신에 사용), 아는 사람
            - 멀티캐스트(Multicast): 단일 송신자와 다중 수신자 간의 통신(1대 다 통신에 사용)
            - 애니캐스트(Anycast): 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신(1 대 1 통신에 사용)
                - 하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달하는 방식
                - 옆으로 전달하는 방식, 인접해있는 것들을 전달해서 점차적으로 확장
                
                ![이미지](/assets/img/exam/previous/2021(1)_10.png)
                
                ![이미지](/assets/img/exam/previous/2021(1)_11.png)
                
    
    ![이미지](/assets/img/exam/previous/2021(1)_0.png)
    
    - IPv4/IPv6 전환 기술
        - 듀얼스택(Dual Stack)
            - IPv4/IPv6 동시 지원, IPv4/IPv6 패킷을 동시에 주고받을 수 있음
        - 터널링(Tunneling)
            - 두 IPv6 네트워크 간에 터널을 이용하는 기술
            - IPv4/IPv6 호스트와 라우터에서 IPv6 패킷을 IPv4 패킷에 캡슐화하여 전송
        - 주소변환Address Translation)
            - IPv4와 IPv6 간에 주소를 변환하여 두 버전을 연동
    

---

Q. 공유메모리, 소켓, 세마포어, 메세지 큐 등 프로세스 간 통신하는 기술을 무엇이라고 하는지 쓰시오.

> IPC (Inter Process Communication)
> 

- IPC (Inter Process Communication)는 프로세스 간 통신 기술이다.
- IPC 기법에는 메시지 큐, 공유메모리, 소켓, 세마포어가 있다.
    
    
    | 기법 | 설명 |
    | --- | --- |
    | 메시지 큐 | 메시지(또는 패킷) 단위로 동작하여 프로세스 간 통신함 |
    | 공유 메모리 | 한 프로세스의 일부분을 다른 프로세스와 공유 |
    | 소켓 | 클라이언트와 서버 프로세스 둘 사이에 통신을 가능하게 함 |
    | 세마포어 | 프로세스 사이의 동기를 맞추는 기능을 제공함 |

---

Q. 시스템 통합에 사용되는 솔루션으로 구축 유형에는 Point to Point, Hub & Spoke, Message Bus가 있다. 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션을 무엇이라고 하는지 쓰시오.

> EAI (Enterprise Application integration)
> 

- EAI는 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션이다.
- EAI를 사용함으로써 각 비지니스 간 통합 및 연계성을 증대시켜 효율성을 높여줄 수 있으며 각 시스템 간의 확장성을 높여줄 수 있다.
- EAI 구축 유형에는 포인트 투 포인트, 허브 앤 스포크, 메시지 버스, 하이브리드가 있다.

![이미지](/assets/img/exam/previous/2021(1)_12.png)

---

Q. 주어진 테이블의 Cardinality, Degree를 구하시오.

> 5, 4
> 

![이미지](/assets/img/exam/previous/2021(1)_13.png)

- 관계 데이터 모델의 구성요소는 다음과 같다.
    - 릴레이션: 행(Row)와 열(Column)로 구성된 테이블
    - 튜플(Tuple): 릴레이션 행(Row)에 해당하는 요소, 릴레이션을 구성하는 각각의 행
    - 속성(Attribute): 릴레이션 열(Column)에 해당하는 요소,  DB를 구성하는 가장 작은 논리적 단위
    - 카디널리티(Cardinality): 튜플(Tuple)의 수
    - 차수(Degree): 속성(Attribute)의 수
    - 스키마(Schema): 데이터베이스의 구조, 제약조건 등의 정보를 담고 잇는 기본적인 구조
    - 인스턴스(Instance): 정의된 스키마에 따라 생성된 테이블에 실제 저장된 데이터의 집합
    - 도메인: 하나의 속성이 취할 수 있는 같은 타입의 원자 값들의 집합
    
    ![이미지](/assets/img/exam/previous/2021(1)_14.png)
    

---

Q. 다음은 C언어 프로그램이다. 실행 결과를 쓰시오.

> Lee
> 
> 
> 38
> 

```c
#include <stdio.h>

int main() {
    struct insa { // 여러 변수들을 모아, 하나의 객체를 구성
        char name[10];
        int age;
    } a[] = {"Kim", 28, "Lee", 38, "Park", 41, "Choi", 30}; // 바로 인스턴스 생성(선언x)

    struct insa *p; // 구조체 변수를 포인터 변수로 만듦
    p = a;
    p++;
    printf("%s\n", p->name);
    printf("%d\n", p->age);
}
```

- 크기가 10인 char 타입의 name 필드와 정수형 변수 age를 가지는 insa라는 구조체를 선언과 동시에 구조체 배열 a를 선언하고 필드를 초기화한다.
- struct insa *p;라는 문장에서 구조체 포인터(struct insa *) 타입의 변수 p를 선언한다.
- 구조체 배열 a의 주솟값을 p에 대입한다. 배열의 경우 배열명은 주솟값을 의미한다.
- p++ 문장을 수행하여 포인터 값을 증가시킨다.
- printf 함수에서 p가 가리키는 name과 age를 출력한다.

| struct insa a[] | name | age | struct insa *p |
| --- | --- | --- | --- |
| a[0] | Kim | 28 |  |
| a[1] | Lee | 38 | p++ 수행으로 가리키는 주소(p를 1 증가) |
| a[2] | Park | 41 |  |
| a[3] | Choi | 30 |  |

※  구조체란?

- 여러 변수들을 모아서, 하나의 객체를 구성할 때 사용하는 사용자 정의 타입 객체
- 구조체: `struct` 로 선언
- 일반 변수로 만든 경우: `.`으로 접근
- 포인터 변수로 만든 경우: `->` 로 접근
    - insa 구조체를 담을 수 있는 포인터 변수 p 생성하고 주소값 대입
    - p++로 인해 s[1]가 되면서 두번째 배열인 Lee와 38이 출력이 된다.

---

Q. 데이터 모델 구성요소 3가지를 쓰시오.

> 연산, 구조, 제약조건
> 
- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구이다.
- 개체 데이터 모델에서는 ( ① ) 을/를 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타내는데 논리 데이터 모델에서는 ( ② ) 을/를 어떻게 나타낼 것인지 표현한다.
- ( ③ ) 은/는 데이터 무결성 유지를 위한 db의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다.

- DBMS 필수 기능 3가지: 정의, 조작, 제어
- 스키마: 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것
- 데이터 모델: 현실 세계의 정보들을 단순화, 추상화하여 체계적으로 표현한 개념적 모형
    
    
- 데이터 모델(Data Model)
    - 데이터 모델은 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형
    - 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 사용되는 지능적인 도구
    - 데이터 모델은 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들로 구성
    
- 데이터 모델 구성 요소

| 개체(Entity) | 사람이 생각하는 개념이나 정보단위 같은 현실 세계의 대상체 |
| 속성(Attribute) | 가장 작은 논리적 단위, 데이터 항목, 데이터 필드 |
| 관계(Relationship) | 개체 간의 관계, 속성간의 논리적 연결  |

- 데이터 모델 종류

| 개념적 데이터 모델 | 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정, 대표적인 개념적 데이터 모델로는 E-R 모델이 있다.                                                                                                                                 연산을 이용하여 실제 데이터를 처리하는 작업에 대한 명세를 나타냄 |
| 논리적 데이터 모델 | 개념적 모델링 과정에서 얻은 구조를 컴퓨터가 이해하고 처리할 수 있게 변환하는 과정, ‘정규화’ 작업은 이부분에 해당한다.                                                                                                                       구조를 어떻게 나타낼 것인지 표현 |
| 물리적 데이터 모델 | 실질적 데이터 구조 설계로, 테이블 정의서, 명세서 등이 있다. |

- 데이터 모델 표시 정보

| 연산
(Operation) | 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구 |
| 구조
(Structure) | 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현 |
| 제약 조건
(Constraint) | 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건                                                   데이터 무결성 유지를 위한 db의 보편적 방법으로 릴레이션의 특정 칼럼에 설정하는 제약을 의미하며, 개체무결성과 참조 무결성 등이 있다. |

- 연산(Operation)
    - 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세
    - 릴레이션을 조작하기 위한 관계 연산을 나타내며 관계 연산에는 select, project, join 등이 있음
- 구조(Structure)
    - 논리적으로 표현된 개체 타입 간의 관계
    - 데이터 구조 및 정적 성질 표현
    - 릴레이션에 해당하는 것으로 데이터를 원잣값으로 갖는 이차원의 테이블로 표현
- 제약 조건(Constraint)
    - 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약조건

- DB 설계 순서
    
    ① 요구조건 분석
    
    - 수집된 정보를 바탕으로 요구 조건 명세서 작성
    
    ② 개념적 설계
    
    - 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산출물에는 E-R 다이어그램
    - 개념 스키마, 트랜잭션 모델링, E-R 모델링
    
    ③ 논리적 설계
    
    - 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행
    - 개념 스키마 평가 및 정제, 논리 스키마 설계
    
    ④ 물리적 설계
    
    - 특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서
    - 논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환하는 과정
    - 레코드 집중의 분석,설계 / 저장레코드 양식 설계 / 저장 구조 및 액세스 경로 설정
    
    ⑤ 구현
    
    - DDL로 데이터베이스 생성
    - 응용 프로그램을 위한 트랜잭션 작성
    - 논리적 설계, 물리적 설계 단계에서 도출된 스키마를 파일로 생성하는 과정

---

Q. 다음은 Java 프로그램이다. 실행 결과를 쓰시오.

> 0+1+2+3+4+5=15
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int i, j;
		for (j=0, i=0; i<= 5; i++) {
			j += i;
			System.out.print(i);
			if (i == 5) {
				System.out.print("=");
				System.out.print(j);
			} 
			else {
				System.out.print("+");
			}
		}
	}
}
```

- 정수형 변수 i, j를 선언한다.
- for 반복문에서는 j=0, i=0으로 초깃값을 설정하고 i가 5보다 작거나 같을 때까지 i 값을 1씩 증가하며 반복한다.
- i와 j를 더한 결과를 j에 대입하고 i를 화면에 출력한다.
- 만약 i가 5와 같으면 “=”을 화면에 출력하고 j 값을 화면에 출력하고 그렇지 않으면 “+”를 화면에 출력한다.

| i | j | 출력값 |
| --- | --- | --- |
| 0 | 0 | 0+ |
| 1 | 1 | 1+ |
| 2 | 3 | 2+ |
| 3 | 6 | 3+ |
| 4 | 10 | 4+ |
| 5 | 15 | 5=15 |

---

Q. 시스템 객체의 접근을 개인 또는 그룹의 식별자에 기반을 둔 방법, 어떤 종류의 접근 권한을 가진 사용자가 다른 사용자에 자신의 판단에 따라 권한을 허용하는 접근제어 방식은?

> 임의적 접근 통제 (DAC; Discretionary Access Control)
> 

- 서버 접근통제 유형에는 임의적 접근통제, 강제적 접근통제, 역할 기반 접근통제가 있다.
    - 임의적 접근 통제(DAC; Discretionary Access Control)
        - 시스템에 대한 접근을 사용자/그룹의 **신분** 기반으로 제한하는 방법
        - DAC에서 사용자는 자원과 관련된 **ACL(Access Control List)이 수정**됨으로써 자원에 대한 권한을 부여
    - 강제적 접근 통제(MAC; Mandatory Access Control)
        - 시스템 정보의 허용**등급**을 기준으로 사용자가 갖는 접근 허가 권한에 근거하여 시스템에 대한 접근을 제한하는 방법
        - MAC에서 사용자들은 자원에 대한 권한을 관리자로부터 부여
        - **관리자만이** 시스템 자원에 대한 권한을 할당할 수 있음
    - 역할기반 접근 통제(RBAC; Role Based Access Control)
        - 중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 **역할(Role)**에 기초하여 자원에 대한 접근을 제한하는 방법
        - RBAC에서 자원에 대한 접근은 사용자에게 **할당된 역할에 기반**
        - 관리자는 사용자에게 특정한 권리와 권한이 정의된 역할을 할당

- 서버 접근통제 간 비교
    
    
    | 정책 | DAC | MAC | RBAC |
    | --- | --- | --- | --- |
    | 권한 부여 | 데이터 소유자 | 시스템 | 중앙 관리자 |
    | 접근 결정 | 신분(Identity) | 보안등급(Label) | 역할(Role) |
    | 정책 변경 | 변경 용이 | 고정적(변경 어려움) | 변경 용이 |
    | 장점 | 구현 용이, 유연함 | 안정적, 중앙 집중적 | 관리 용이 |

---

Q. 다음은 결합도에 대한 설명이다. 빈칸에 들어갈 알맞은 용어를 보기에서 찾아 기호로 쓰시오.

> 내용 결합도, 스탬프 결합도, 공통 결합도
> 
- ( ① ) 은/는 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도
- ( ② ) 은/는 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도
- ( ③ ) 은/는 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도

[보기]

자료 결합도 / 스탬프 결합도 / 제어 결합도 / 공통 결합도 / 내용 결합도 / 외부 결합도

- 결합도의 유형은 다음과 같다.
    - 내용 결합도(Content Coupling)
        - 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도
        - 하나의 모듈이 **직접**적으로 다른 모듈의 내용을 **참조**할 때 두 모듈은 내용적으로 결합되어 있는 경우의 결합도
    - 공통 결합도(Common Coupling)
        - 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 **전역 변수**를 갱신하는 식으로 상호 작용하는 경우의 결합도
        - 공유되는 공통 데이터 영역을 여러 모듈이 사용 할 때의 결합도
    - 외부 결합도(External Coupling)
        - 두 개의 모듈이 외부에서 도입된 **데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스**를 공유할 경우의 결합도
        - **외부 모듈**에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
    - 제어 결합도(Control Coupling)
        - 어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 **제어 신호**를 이용하여 통신하는 경우의 결합도
        - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도 현상이 발생하는 결합도
    - 스탬프 결합도(Stamp Coupling)
        - 모듈 간의 인터페이스로 **배열이나 객체, 구조** 등이 전달되는 경우의 결합도
        - 두 모듈이 동일한 자료구조를 조회하는 경우의 결합도이며, 자료구조의 어떤한 변화는 모든 모듈에 영향을 미치게 됨
    - 자료 결합도(Data Coupling)
        - 모듈 간의 인터페이스로 전달되는 **파라미터**를 통해서만 모듈 간의 상호 작용이 일어나는 경우의 결합도
        - 한 모듈의 내용을 변경하더라도 다른 모듈에는 영향을 미치지 않는 상태로 가장 바람직한 결합도
- 결합도가 낮을수록 품질이 좋아진다.

![이미지](/assets/img/exam/previous/2021(1)_15.png)

---

Q. () 안에 공통으로 들어갈 공격 기법을 적으시오.

> 세션 하이재킹
> 
- ( ) 은/는 '세션을 가로채다' 라는 의미로 정상적 연결을 RST 패킷을 통해 종료시킨 후 재연결 시 희생자가 아닌 공격자에게 연결한다.
- ( ) 은/는 세션 관리 취약점을 이용한 공격 기법이다.

- 세션 하이재킹(Session Hiacking)
    - 케빈 미트닉이 사용했던 공격 방법의 하나로 TCP의 세션 관리 취약점을 이용한 공격 기법이다.
    - 세션 하이재킹에 대응을 하기 위해서는 비동기화 상태 탐지, ACK 패킷 비율 모니터링, 특정 세션에서 패킷 유실 및 재전송이 증가하는 것을 탐지해야 한다.
    - 상호 인증 과정을 거친 후 접속해 있는 서버와 서로 접속되어 클라이언트 사이의 세션 정보를 가로채는 공격 기법으로, 접속을 위한 인증 정보 없이도 가로챈 세션을 이용해 공격자가 원래의 클라이언트인 것처럼 위장하여 서버의 자원이나 데이터를 무단으로 사용한다.
    - TCP 3-Way-Handshake 과정에 끼어듦으로써 클라이언트와 서버 간의 동기화된 시퀀스번호를 가로채 서버에 무단으로 접근하는 TCP 세션 하이재킹이 대표적인 예이다.
- RST(Reset) - R: 재 연결 종료
    - 재설정(Reset)을 하는 과정이며 양방향에서 동시에 일어나는 중단 작업이다. 비 정상적인 세션 연결 끊기에 해당한다. 이 패킷을 보내는 곳이 현재 접속하고 있는 곳과 즉시 연결을 끊고자 할 때 사용한다.