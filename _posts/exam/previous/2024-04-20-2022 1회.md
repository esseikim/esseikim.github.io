---
categories: [정보처리기사, 기출문제]
---

Q. 다음 설명에 맞는 RAID 단계를 숫자로 쓰시오.

> 0
> 
- 패리티(오류 검출 기능)가 없는 중복 없는 스트라이핑된 세트로 구성되어 있다.
- 개선된 성능에 추가적인 기억 장치를 제공하는 장점이 있지만, 장애 시 데이터의 안전을 보장할 수 없다.

- RAID(Redundant Array of Independent Disks; 복수 배열 독립 디스크)는 하나의 대형 저장장치 대신 다수의 저용량의 저장장치를 배열로 구성하는 기술이다.
- 여러 개의 하드디스크에 일부 중복된 데이터를 나눠서 저장하기 때문에 디스크 어레이(Dist Array)라고도 한다.
- 데이터를 나누는 다양한 방법이 존재하며, 이 방법들을 레벨이라 하는데, 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등 다양한 목적을 만족시킬 수 있다.
- RAID 유형은 다음과 같다.
    - RAID 0 - 개수만큼 용량과 속도 배로 증가
        - 패리티(오류 검출 기능)가 없고 중복 없는 **스트라이핑**된 세트로 구성되는 방식
        - 적어도 **2개**의 디스크 필요
    - RAID 1 - 미러링(중복 저장, 데이터의 다중화), 높은 신뢰도
        - 패티티(오류 검출 기능)가 없는 **미러링**된 세트로 구성되는 방식
        - 적어도 2개의 디스크 필요
        - 디스크 2개에 동일한 데이터가 저장되고, 제공해야 할 논리 디스크 크기의 2배 공간을 필요로 하기 때문에 비용 측면에서 단점이 있음
    - RAID 2
        - 오류정정부호(ECC)를 기록하는 전용의 하드디스크를 이용해서 안정성을 확보하는 방식
        - **비트** 레벨의 스트라이핑과 **해밍코드** 패리티 사용하여 하나의 멤버 디스크가 고장 나도 ECC를 이용하여 정상적인 작동을할 수 있지만, 추가적인 연산이 필요하여 입출력 속도 매우 늦음
    - RAID 3
        - 데이터는 **바이트** 단위로 쪼개져서 모든 디스크에 스트라이핑된 세트로 구성되고, 패리티 정보는 별도의 전용 디스트에 저장되는 방식
        - 적어도 3개의 디스크 필요
        - 1개의 드라이브가 고장 나는 것을 허용하며, 순차적 쓰기 성능과 순차적 읽기 성능은 매우 우수하지만 문제 해결이 어려워서 잘 사용되지 않음
    - RAID 4
        - 데이터는 **블록** 단위로 쪼개져서 모든 디스크에 스트라이핑된 세트로 구성되고, 패리티 정보는 별도의 전용 디스트에 저장되는 방식
        - 적어도 3개의 디스크 필요
        - 읽기 성능은 좋지만, 쓰기 성능은 나쁜 단점이 있음
    - RAID 5
        - 패리티가 **배분되는(Distributed)** 스트라이핑된 세트로 구성된 방식
        - 적어도 3개의 디스크 필요
        - 모든 디스크에 나뉘어 저장되지만, 항상 균등하진 않고 패리티 정보도 모든 디스크에 나뉘어 저장
    - RAID 6
        - 패리티가 배분되는(Distributed) 스트라이핑된 세트로 구성된 방식
        - 적어도 **4개**의 디스크 필요
        - 각 디스크에 피리티 정보가 **두 번 독립적으로 분산**되어 저장

![이미지](/assets/img/exam/previous/2022(1)_1.png)

![이미지](/assets/img/exam/previous/2022(1)_2.png)

RAID 0 - 스트라이핑 방식, 중복저장X, 에러검출X 

RAID 1 - 미러링 방식, 중복저장O, 높은 신뢰도 

![이미지](/assets/img/exam/previous/2022(1)_3.png)

RAID 2 - 스트라이핑 방식, 비트 단위, 해밍코드를 사용하여 에러 검증(오류 검출 내용 보관) 

![이미지](/assets/img/exam/previous/2022(1)_4.png)

RAID 3 - 스트라이핑 방식, 패리티(8bit)를 에러 검증, 바이트 단위(한 줌)

![이미지](/assets/img/exam/previous/2022(1)_5.png)

RAID 4 - 블록/워드 단위(바가지)

![이미지](/assets/img/exam/previous/2022(1)_6.png)

RAID 5 - 패리티 블록을 각 디스크마다 분산저장(불안)

![이미지](/assets/img/exam/previous/2022(1)_7.png)

RAID 6 - 패리티 블록을 이중구조로 구축 

![이미지](/assets/img/exam/previous/2022(1)_8.png)

```
[키워드]
0 스트라이핑, 중복저장x 에러검출x
1 미러링(중복저장), 신뢰성
2 해밍코드(비트)
3 패리티를 에러검증 바이트 단위
4 패리티 블록 단위
5 패리티 블록 각 디스크마다 분산저장
5 패리티 블록 이중구조 구축
```

---

Q, 다음에 해당하는 DB 트랜잭션 연산을 [보기]에서 찾아 적으시오.

> Redo, Undo
> 

① 장애 발생 전 DB로 복구하는 기법으로 디스크에 저장된 로그를 분석하여 트랜잭션의 시작(Start)와 완료(Commit)에 대한 기록이 있는 트랜잭션들의 작업을 재실행하는 방법

② 장애 시 디스크에 저장된 로그를 분석하여 트랜잭션의 시작(Start)은 있지만, 완료(Commit) 기록이 없는 트랜잭션들이 작업한 변경 내용을 모두 취소하는 기법

- 데이터베이스 회복 기법 관련 용어 중 REDO, UNDO 용어는 다음과 같다.
    - REDO
        - 데이터베이스가 비정상적으로 종료되었을 때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작(Start)과 완료(Commit)에 대한 기록이 있는 트랜잭션들의 작업을 재 작업하는 기법
    - UNDO
        - 데이터베이스가 비정상적으로 종료되었을 때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작(Start)은 있지만, 완료(Commit) 기록이 없는 트랜잭션이 작업한 변경 내용을 모두 취소하는 방법

- 회복(Recovery)
    - 회복은 트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상 되었을 때 손상되기 이전의 정상 상태로 복구하는 작업
    - 트랜잭션: 데이터베이스에서 작업하는 단위
- 회복 기법의 종류
    
    ![이미지](/assets/img/exam/previous/2022(1)_9.png)
    

- 취소(Undo) : 로그(Log)에 보관한 정보를 이용하여 가장 최근에 변경된 내용부터 거슬러 올라가면서 트랜잭션 작업을 취소하여 원래의 데이터베이스로 복구함
    - 정상적 처리, 잘못되었을 때 처음부터 다시 해라
- 재시도(Redo) : 덤프와 로그를 이용하여 가장 최근의 정상적인 데이터베이스로 회복시킨 후 트랜잭션을 재실행 시킴
    - 정상적 처리, 정상적 처리부터 다시 시도

![이미지](/assets/img/exam/previous/2022(1)_10.png)

![이미지](/assets/img/exam/previous/2022(1)_11.png)

![이미지](/assets/img/exam/previous/2022(1)_12.png)

- 즉각 갱신 기법(Immediate Update)
    - 트랜잭션이 데이터를 갱신하면 트랜잭션이 부분완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 방법
        - a 작업 완료 시 바로 데이터베이스에 반영
    - 장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들은 Log에 보관시킴
    - 회복 작업을 수행할 경우 Redo와 Undo 모두 사용 가능함
    
- 연기 갱신 기법(Deferred Update)
    - 트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법
    - 트랜잭션이 수행되는 동안 갱신된 내용은 일단 Log에 보관됨
    - 트랜잭션의 부분 완료 시점에 Log에 보관한 갱신 내용을 실제 데이터베이스에 기록함
    - 트랜잭션이 부분 완료되기 전에 장애가 발생하여 트랜잭션이 Rollback되면 트랜잭션이 실제 데이터베이스에 영향을 미치지 않았기 때문에 어떠한 갱신내용도 취소(Undo)시킬 필요 없이 무시하면 됨
    - Redo 작업만 가능함
    
    ![이미지](/assets/img/exam/previous/2022(1)_13.png)
    
- 그림자 페이지 대체 기법(Shadow Paging)
    - 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지를 별도 보관 해놓고, 실제 페이지를 대상으로 갱신 작업을 수행하다가 장애가 발생하여 트랜잭션 작업을 Rollback시킬 때는 갱신 이후의 실제 페이지 부분을 그림자 페이지로 대체하여 회복시키는 기법
    - 로그, Undo 및 Redo 알고리즘 필요 없음
    
    ![이미지](/assets/img/exam/previous/2022(1)_14.png)
    

- 검사점 기법(Check Point)
    - 트랜잭션 실행 중 특정 단계에서 재실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 검사점을 로그에 보관해 두고, 장애 발생 시 트랜잭션 전체를 철회(Undo)하지 않고 검사점부터 회복 작업을 수행하여 회복시간을 절약하도록 하는 기법
        - 1~5번 작업을 모두 수행 후 다시 한번 이상유무  검사, 6번 작업 수행, 7번 작업 수행 중 오류 발생 → 5번까진 완벽하다, 검사점 설정, 6번 작업부터 회복작업 수행 진행
        
        ![이미지](/assets/img/exam/previous/2022(1)_15.png)
        

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 2000
> 

```java
class A {
	int a;
	int b;
}

public class Soojebi {
	static void func1(A m) {
		m.a *= 10;
	}
	static void func1(A m) {
		m.a += m.b;
	}

public static void main(String args[]) {
	A m = new A();
	m.a = 100;
	func1(m);
	m.b = m.a;
	func2(m);
	
	System.out.printf("%d", m.a);
	}
}
```

- func1 호출될 때 m.a 값이 100이므로 m.a *= 10에 의해 m.a 값이 1000이 됨
- func2 호출될 때 m.a 값이 1000이고, m.b의 값이 1000이므로 m.a += 10에 의해 m.a의 값이 2000이 됨
- A 클래스 타입의 m 변수에 A 클래스를 생성
- m의 a 변수에 100을 저장
- func1 메서드에 m 전달
- m.b에 m.a 값인 1000을 저장
- func2 메서드에  m 전달
- m의 a 변수값인 2000을 출력

---

Q. 다음은 점수에 대해 내림차순 하는 SQL이다. () 안에 들어갈 SQL 구문을 쓰시오.

> ORDER, SCORE, DESC
> 

```sql
SELECT NAME, **SCORE**
FROM 성적
( ① ) BY ( ② )( ③ )
```

---

Q. 이상 현상 중 삭제 이상에 대해 서술하시오.

> 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 이상 현상
> 

- 이상 현상은 데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상으로 삽입, 삭제, 갱신 이상이 있다.
    
    
    | 이상 현상 | 설명 |
    | --- | --- |
    | 삽입 이상 | 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 현상 |
    | 삭제 이상 | 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 이상 현상 |
    | 갱신 이상 | 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 이상 현상 |

---

**Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.**

> **a= 20 b= 2**
> 

```python
def func(num1, num2=2):
	print('a=', num1**,** 'b=', num2)

func(20)
```

- func(20)을 통해 func 함수에 20이라는 파라미터를 전달
- func(20)을 통해서 num1에 20이라는 값 넘겨주고, num2는 넘겨주지 않았으므로 2가 됨
- 파이썬은 `,`단위로 띄어쓰기 가 되기 때문에 a=20 b=2가 출력됨

---

**Q. 다음은 리스트와 관련된 파이썬 함수이다. 각 항목에 해당하는 함수를 보기에서 골라서 쓰시오.**

> extend(), pop(), reverse()
> 

① 리스트의 확장, 여러 값을 한 번에 추가할 수 있음

② 마지막 또는 지정요소를 삭제하고 그 값을 반환함

③ 역순으로 뒤집음

[보기]

remove(), reverse(), sort(), index(), insert(), select(), pop(), extend()

- 리스트와 관련된 파이썬 함수는 다음과 같다.
    
    
    | 함수 | 설명 |
    | --- | --- |
    | append() | 리스트 마지막 요소 뒤에 값을 추가 |
    | insert() | 리스트의 인덱스 위치에 값을 삽입 |
    | remove() | 리스트에서 해당하는 값을 제거 |
    | reverse() | 역순으로 뒤집음 |
    | pop() | 마지막 또는 지정 요소를 삭제하고 그 값을 반환 |
    | extend() | 리스트 확장, 여러 값을 한 번에 추가 |

---

Q. 임시 키 무결성 프로토콜의 약자를 쓰시오.

> TKIP(Temporal Key Integrity Protocol)
> 

- 임시 키 무결성 프로토콜(TKIP; Temporal Key Integrity Protocol)은 IEEE 802.11i의 암호화 방식으로 초기 Wi-Fi 장비에서 널리 사용되었던 안전하지 않은 WEP(Wired Equivalent Privacy) 암호화 표준을 대체하기 위한 암호 프로토콜이다.
- 다수의 마스터키를 사용하여 마스터키의 노출을 최소화하도록 자주 키를 갱신하는 특징이 있고, 프레임마다 카운팅(Sequence Counting)할 수 있도록 하여 재생 공격에 대응할 수 있는 특징이 있다.
- 무선 랜 보안에 사용된 WEP을 보안한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라고도 함
- WEP의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키 할당, 키값 재설정 등 키 관리 방식을 개선하였다.

---

Q. 신체를 활용한 사용자 인터페이스(UI)를 무엇이라고 하는가?

> NUI(Natural User Interface)
> 

- UI 유형에는 CLI, GUI, NUl, OUI가 있다.
    - CLI(Command Line Interface)
        - 정적인 테스트 기반 인터페이스
        - 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스
    - GUI(Graphical User Interface)
        - 그래픽 반응 기반 인터페이스
        - 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 사용자 인터페이스
    - NUI(Natural User Interface)
        - 직관적 사용자 반응 기반 인터페이스
        - 키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스
        - 터치, 음성 포함
    - OUI(Organic User Interface)
        - 유기적 상호 작용 기반 인터페이스
        - 현실에 존재하는 모든 사물이 입출력 장치로 변화할 수 있는 사용자 인터페이스

---

Q. 다음은 분석 도구에 대한 설명이다. 각 항목에 해당하는 도구를 쓰시오.

> Static Analysis, Dynamic Analysis
> 

① 실행하지 않고 원시 코드 분석

② 프로그램 동작이나 반응을 추적하고 보고함, 프로그램 모니터, 스냅샷 생성

- 정적 분석(Static Analysis)은 소프트웨어를 실행하지 않고 코드를 분석하는 기법이다.
- 동적 분석(Dynamic Analysis)은 소프트웨어를 실행하여 동작이나 반응을 추적하고 분석하는 기법이다.

---

Q. 다음은 스레드에 관한 코드이다. 밑줄 친 곳에 알맞은 코드를 쓰시오.

> Car
> 

```java
class car implements Runnable {
	int a;
	public void run() {
			// ...     
	}
}

public class Soojebi {
	public static void main(String[] args) {
		Thread t1 = new Thread(new      ());
		t1.start();
	}
}
```

- Runnable 인터페이스를 상속하여 스레드를 구현할 수 있다.

```java
class car implements Runnable {
	public void run() {
			// 스레드 동작 시 수행할 코드
	}
}

public class Soojebi {
	public static void main(String[] args) {
		Thread t1 = new Car();
		Thread t2 = new Thread(new Car());
		t1.start();
		t2.start();
	}
}                                  
```

- 스레드를 만들기 위해서는 Runnable 인터페이스를 상속받고, 스레드를 생성하기 위해서는 new 뒤에 Runnable 인터페이스를 상속받은 스레드 클래스를 선언해준다.
    - Thread 스레드변수 = new 상속받은 스레드클래스();
    - Thread 스레드변수 = new Thread(new 상속받은 스레드클래스());

---

Q. 다음에서 설명하는 인터페이스 도구를 쓰시오.

> JUnit
> 
- 자바를 이용한 xUnit 테스트 도구이다.
- Erich Gamma와 Kent Beck 등이 작성한 오픈소스로 JAVA 단위 테스트 프레임워크이다.

- JUnit은 자바 프로그래밍 언어용 단위 테스트 도구이다.
- JUnit은 자바 코드에 주석을 달아 특별한 의미를 부여한 어노테이션(`@`)을 사용한다.

---

Q. 다음에서 블랙박스 테스트 기법인 것을 3가지 골라 쓰시오.

> ㉢ Boundary Value Analysis, ㉣ Equivalence Partitioning, ㉤ Cause-Effect Graph
> 

[보 기]

㉠ Cause-Decision Graph

㉡ Statement Coverage

㉢ Boundary Value Analysis

㉣ Equivalence Partitioning

㉤ Cause-Effect Graph

㉥ Decision Coverage

㉦ Base Path Coverage

㉧ Base Path Testing

---

Q. 다음 소스 코드에 입력값이 5가 들어왔을 때 출력값을 쓰시오.

> 120
> 

```c
#include <stdio.h>
int fn(int a) {
	if(a <= 1) return 1;
	return a * fn(a-1);
}

void main() {
	int a;
	scanf("%d", &a);
	printf("%d", fn(a));
}
```

- 재귀 함수

---

**Q. 밑줄 친 곳에 연산자 이용해 정수를 역순으로 출력하는 프로그램을 완성하시오. 예를 들어 1234의 역순은 4321이고, 1230 처럼 0으로 끝나는 정수는 고려하지 않는다.**

> **> 또는 !=**, %, /
> 

```c
#include <stdio.h>
void main() {
	int number = 1234;
	int div = 10;
	int result = 0;
	
	while(number  ①  0) {
		result = result * div;
		result = result + number  ②  div;
		number = number  ③  div;
	}
	
	printf("%d", result);
}
```

- 반복문을 실행할 때마다 맨 뒷자리 수를 result에 더해주고, number의 맨 마지막 자리는 없애고, result는 10배씩 곱해서 역수를 구한다.
- 반복문이 0보다 크거나 0이 아닐 때까지 반복해야 하기 때문에 >나 !=를 사용한다.
- number의 맨 뒷자리 수를 result에 더해주어야 하기 때문에 % 연산자를 사용한다.
- number의 맨 뒷자리 수를 제거해야 하므로 / 연산자를 사용한다.(정수와 정수를 나누면 결과가 정숫값이 되어야 하므로 소수점은 버림처리 된다.)

---

Q. 정보보호 관리체계의 영문 약자는 무엇인가?

> ISMS(Information Security Management System)
> 

- `정보보호 관리체계(ISMS)`란 조직의 주요 정보자산을 보호하기 위하여 정보보호 관리 절차와 과정을 체계적으로 수립하여 지속적으로 관리하고 운영하기 위한 종합적인 체계이다.
- `정보보호 관리체계(ISMS) 인증`이란 인증 신청인의 정보보호 관련 일련의 조치와 활동이 인증기준에 적합함을 인터넷진흥원 또는 인증기관이 증명하는 것을 말한다.
- `정보보호 및 개인정보보호 관리체계(ISMS-P) 인증`이란 인증 신청인의 정보보호 및 개인정보보호를 위한 일련의 조치와 활동이 인증기준에 적합함을 한국인터넷진흥원(이하 “인터넷진흥원”이라 한다) 또는 인증기관이 증명하는 것을 말한다.

---

Q. 다음은 키에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 유일성, 최소성
> 
- 슈퍼 키는 ( ① )의 속성을 갖는다.
- 후보 키는 ( ① )와/과 ( ② )의 속성을 갖는다.

- 키의 특성으로는 식별자에 의해 엔티티 타입 내에 모든 엔티티들이 유일하게 구분되는 유일성, 최소한의 속성으로 식별자로 구성된 최소성이 있다.
- 키의 종류는 기본 키, 대체 키, 후보 키, 슈퍼 키, 외래 키 등이 있다.
    - 기본 키(Primary Key)
        - 후보 키 중에서 선택받아 테이블의 튜플들을 고유하게 식별하는 키
    - 대체 키(Alternate Key)
        - 후보 키 중에서 기본 키로 선택되지 않은 키
    - 후보 키(Candidate Key)
        - **유일성과 최소성을 모두 만족**하는 키
    - 슈퍼 키(Super Key)
        - 유일성은 만족하지만, 최소성은 만족하지 못하는 키
    - 외래 키(Foreign Key)
        - 한 릴레이션의 컬럼이 다른 릴레이션의 기본 키로 이용되는 키

---

Q. 공격 대상이 방문할 가능성이 있는 합법적 웹사이트를 미리 감염시켜 놓고, 피해자가 방문했을 때 피해자의 컴퓨터에 악성 프로그램을 배포하는 공격기법을 보기에서 골라서 쓰시오.

> ㉢ Watering hole
> 

[보기]

㉠ Pharming

㉡ Drive by Download

㉢ Watering Hole

㉣ Business SCAM

㉤ Phishing

㉥ Cyber Kill Chain

㉦ Ransomware

- 공격 대상이 방문할 가능성이 있는 **합법적 웹사이트를 미리 감염**시켜 놓고, 피해자가 방문했을 때 피해자의 컴퓨터에 악성 프로그램을 배포하는 공격기법을 보기에서 골라서 쓰시오.
- 파밍(Pharming)
    - 인터넷 주소창에 방문하고자 하는 사이트 URL을 입력하였을 때 가짜 사이트(fake site)로 이동시키는 공격기법
- 드라이브 바이 다운로드(Drive by Download)
    - 악의적인 해커가 불특정 웹 서버와 웹페이지에 악성 스크립트를 설치하고, 불특정 사용자 접속 시 사용자 동의 없이 실행되어 의도된 서버(멀웨어 서버)로 연결하여 감염시키는 공격 기법
- 비지니스 스캠(Business SCAM)
    - 기업 이메일 계정 도용하여 무역 거래 대금 가로채는 사이버 범죄
- 피싱(Phishing)
    - 소셜 네트워크에서 악의적인 사용자가 지인 또는 특정 유명인으로 가장하여 불특정 다수의 정보를 탈취하는 공격기법
- 사이버 킬체인(Cyber Kill Chain)
    - 록히드 마틴의 사이버 킬체인은 공격형 방위시스템으로 지능적, 지속적 사이버 공격에 대해 7단계 프로세스별 공격 분석 및 대응을 체계화한 APT 공격 방어 분석 모델
- 랜섬웨어(Ransomware)
    - 악성코드의 한 종류로 감염된 시스템의 파일들(문서, 사진, 동영상 등)을 암호화하여 복호화할 수 없도록 하고, 피해자로 하여금 암호화된 파일을 인질처럼 잡고 몸값을 요구하는 악성 소프트웨어

---

Q. 다음 소스 코드가 실행될 때 출력값을 적으시오.

> 29
> 

```c
#include <stdio.h>
int isPrime(int number) {
	int i;
	for(i=2; i<number; i++) {
		if(number % i == 0) return 0;
	}
	return 1;
}

void main() {
	int number = 13195, max_div=0; i;
	for(i=2; i<number; i++)
		if(isPrime(i) == 1 && number % i == 0)
			max_div = i;
		pirntf("%d", max_div);
}
```

[소수이면서 13195의 소인수(13195를 나눴을 때 나머지가 0인 약수 중 소수인 수)]인 가장 큰 값을 찾는 문제]

- isPrime 함수는 소수인지 판별해주는 사용자 정의함수
- 입력받은 숫자가 i랑 나누어 떨어지면 0을 반환
- number가 2부터 number-1까지 한 번도 안 나누어 떨어지면 1을 반환(소수)
- i는 2부터 13194까지 반복하는데, i가 소수이면서 13195와 i를 나눴을 때 나누어 떨어지는 수 i를 max_div에 저장
- 반복문을 완료하면 i가 소수이면서 13195와 i를 나눴을 때 나누어 떨어지는 수 중 가장 큰 값이 max_div에 저장됨
- number % i는 13195를 i로 나눴을 때 나머지가 없는 수이므로 i가 13195의 약수를 찾아야 한다.

![이미지](/assets/img/exam/previous/2022(1)_16.png)

- 13195 = 5x7x13x29이기 때무에 29가 가장 큰 소수이므로 max_div는 29가 되어 29를 출력한다.

---

Q. 다음은 소프트웨어 개발 프로세스 중 V 모델에 대한 그림이다. ① ~ ④까지 들어갈 테스트를 쓰시오.

> 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트
> 

![이미지](/assets/img/exam/previous/2022(1)_17.png)

- 소프트웨어 개발 프로세스 중 V 모델에서 사용되는 테스트는 다음과 같다.
    
    
    | 테스트 레벨 종류 | 설명 |
    | --- | --- |
    | 단위 테스트 | 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춘 테스트 |
    | 통합 테스트 | 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호 작용을 검증하는 테스트 |
    | 시스템 테스트 | 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 테스트 |
    | 인수 테스트 | 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 |