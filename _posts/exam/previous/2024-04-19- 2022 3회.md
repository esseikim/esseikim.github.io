---
categories: [정보처리기사, 기출문제]
---

Q. 다음은 C언어 코드이다. 실행 결과를 쓰시오.

![이미지](/assets/img/exam/previous/2022(3)_0.png)

```c
#include <stdio.h>

int clac(int w, int h, int j, int i) {
	if(i>=0 && i<h && j>=0 && j<w)
		ruturn 1;
	return 0;
}

int main() {
	int field[4][4] = { {0,1,0,1}, {0,0,0,1}, {1,1,1,0}, {0,1,1,1} };
	int mines[4][4] = { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0} };
	int w = 4, h = 4;
	int i, j, k, l;
	
	for(l=0; l<h; l++) {
		for(k=0; k<w; k++) {
			if(field[l][k] == 0)
				continue;
			
			for(i=l-1; k<=1+1; i++) {
				for(j=k-1; j<=k+1; j++) {
					if(calc(w, h, j, i) == 1) {
						mines[i][j] += 1;
					}
				}
			}
		}
	}
	for(l=0; l<h; l++) {
		for(k=0; k<w; i++) {
			printf("%d", mines[l][k]);
		}
		printf("\n");
	}
	return 0;
}

```

- 이 코드는 지뢰 찾기 게임에서 주로 사용되는 탐색 알고리즘 패턴이다.
- 주어진 2차원 그리드에서 각 셀 주변을 탐색하고, 특정 조건(여기서는 지뢰가 아닌 경우)에 따라 주변 셀에 대한 처리를 수행하는 패턴이다.
- 이 코드의 경우, 탐색은 다음과 같은 단계로 이루어진다.
1. 모든 셀을 순회한다.
2. 각 셀이 지뢰가 아니라면(값이 0이 아니라면), 그 셀의 주변 8개 셀을 다시 탐색한다.
3. 주변 셀 중 유효한 범위 내의 셀에 대해 `clac` 함수를 호출하여 해당 셀이 유효한 범위 내에 있는지 확인한다.
4. 만약 주변 셀에 지뢰가 없다면(`field` 배열 값이 1), 해당 지뢰의 수를 `minus` 배열에 누적한다. 

---

Q. 올바른 관계대수 기호를 쓰시오.

> **∪,** X,  ▷◁,  -, π
> 
- (): 합집합
- () 카티션 프로덕트
- (): 조인
- (): 차집합
- (): 프로젝트

- 관계대수 연산자의 종류에는 일반 집합 연산자와 순수 관계 연산자가 있고 연산자의 종류, 기호, 표현은 다음과 같다.
- 일반 집합 연산자
    
    
    | 연산자 | 기호 | 표현 | 설명 |
    | --- | --- | --- | --- |
    | 합집합(Union) | ∪ | R∪S | 합병 가능한 두 릴레이션 R과 S의 합집합 |
    | 교집합(Intersection) | ∩ | R∩S | 릴레이션 R과 S에 속하는 모든 튜플로 결과 릴레이션 구성 |
    | 차집합(Difference) | - | R-S | R에 존재하고 S에 미 존재하는 튜플로 결과 릴레이션 구성 |
    | 카티션 프로덕트(CARTESIAN Product) | X | RXS | R과 S에 속한 모든 튜플을 연결해 만들어진 새로운 튜플로 릴레이션 구성 |
    
    ![이미지](/assets/img/exam/previous/2022(3)_1.png)
    
    ![이미지](/assets/img/exam/previous/2022(3)_2.png)
    
    ![이미지](/assets/img/exam/previous/2022(3)_3.png)
    
    

![이미지](/assets/img/exam/previous/2022(3)_5.png)

- 순수 관계 연산자

| 연산자 | 기호 | 표현 | 설명 |
| --- | --- | --- | --- |
| 셀렉트(Select) | σ | σ조건(R) | 릴레이션 R에서 조건을 만족하는 튜플 반환 |
| 프로젝트(Project) | π | π속성리스트(R) | 릴레이션 R에서 주어진 속성들의 값으로만 구성된 튜플 반환 |
| 조인(Join) | ▷◁ | R▷◁S | 공통 속성을 이용해 R과 S의 튜플들을 연결해 만들어진 튜플 반환 |
| 디비전(Division) | ÷ | R÷S | 릴레이션 S의 모든 튜플과 관련 있는 R의 튜플 반환 |

![이미지](/assets/img/exam/previous/2022(3)_6.png)

![이미지](/assets/img/exam/previous/2022(3)_7.png)

![이미지](/assets/img/exam/previous/2022(3)_8.png)

![이미지](/assets/img/exam/previous/2022(3)_9.png)

---

Q. 다음은 디자인 패턴에 대한 설명이다. () 안에 들어갈 디자인 패턴의 유형을 쓰시오.

> 브릿지(Bridge), 옵저버(Observer
> 
- ( ① ) 패턴은 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴이다.
- ( ② ) 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대 다의 의존성을 가지며 상호 작용하는 객체 사이에서는 가능하면 느슨하게  결합하는 디자인 패턴이다.

---

Q. 다음은 JAVA 언어 코드이다. 실행 결과를 쓰시오.

> 24513
> 

```java
class Soojebi {
	public static void main(String[] args) {
		int[] result = new int[5];
		int[] arr = {79, 34, 10, 99, 50};
		for(int i = 0; i < 5; i++) {
			result[i] = 1;
			for(int j = 0; j < 5; j++) {
				if(arr[i] < arr[j]) result[i]++;
			}
		}
		for(int k=0; k<5; k++) {
			System.out.print(result[k]);
		}
	}
}
```

- 정수형 배열로 5칸의 공간을 갖는 result를 선언하고 [79, 34, 10, 99, 50] 값을 갖는 정수형 배열 arr을 선언한다.
- 이중 for 문의 구조에서 result[i]의 초깃값은 1이며, arr 배열에 자기 자신보다 큰 수의 개수를 찾으면 result[i]의 값을 1씩 늘려간다.
- 이중 for 문이 종료되고 새롭게 for 문이 실행되며, result 배열에 가장 마지막으로 저장된 값인 24513을 출력한다.

---

Q. 192.168.1.0/24인 IP 주소를 FLSM 방식으로 3개의 Subnet으로 분할할 때 두 번째 Subnet의 브로드캐스트 IP 주소(10진수)를 쓰시오.

> 192.168.1.127
> 

- 192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 3개의 subnet으로 나누고, 두 번째 subnet의 브로드캐스트 IP 주소를 계산하려면 다음과 같이 계산해야 한다.
- 10진수 192.168.1.0을 2진수로 바꾸면 다음과 같다.

![이미지](/assets/img/exam/previous/2022(3)_10.png)

① 서브넷을 위한 bit 수 결정

- Host ID의 상위 n개의 bit를 이용하여 2^n개의 서브넷으로 분할한다.(2^n ≥ 서브넷 개수)
- 3개의 subnet으로 나누기 때문에 2^n ≥ 3을 만족하는 n은 2가 된다.
- n이 2이면 서브넷 마스크 중 25번째 비트 ~ 26번째 비트(2비트)는 subnet을 위해 사용한다.

![이미지](/assets/img/exam/previous/2022(3)_11.png)

② 서브넷 ID를 변경하여 유효 서브넷 ID 계산

- 서브넷 ID를 2진수로 모두 0이 채워진 값부터 모두 1이 채워진 값까지 1씩 증가시킨다.

![이미지](/assets/img/exam/previous/2022(3)_12.png)

③ 호스트 ID를 변경하여 사용 가능한 IP주소를 계산

- 호스트 ID를 2진수로 모두 0이 채워진 값은 네트워크 주소이고, 모두 1이 채워진 값은 브로드캐스트 주소이다.(단, IP Subnet Zero일 경우 모두 0으로 채워진 값을 사용할 수 있다.)
- 호스트 ID를 2진수로 모두 0이 채워진 값에서 1 큰 값부터 모두 1이 채워진 값에서 1 작은 값까지 1씩 증가시킨다.
- 2번째 서브넷은 11000000.10101000.00000001.01000000이고, 여기에서 호스트 ID 부분을 모두 1로 채운 값이 브로드캐스트 주소가 된다.
- 11000000.100101000.00000001.01111111을 10진수로 바꾸면 192.169.1.127이다.

---

Q. 다음의 테스트 기법은 무엇인지 [보기]에서 쓰시오.

> ㉦ Boundary Value Analysis
> 
- 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법이다.
- 예를 들어 0, 60, 80, 100으로 등가 분할 후 테스트데이터는 -1, 0, 59, 60, 61, 79, 80, 81, 99, 100이다.

[보기]

㉠ Equivalence Partitioning

㉡ Decision Table

㉢ State Transition

㉣ Use Case

㉤ Classification Tree Method

㉥ Cause-Effect Graph

㉦ Boundary Value Analysis

- 경곗값 분석 테스트(Boundary Value Analysis Testing)은 등가분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법이다.
- 동등 분할 테스트(Equivalence Partitioning Testing)
    - 입력 데이터의 영역을 유사한 도메인별로 유횻값/무횻값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트하는 기법
- 결정 테이블 테스트(Decision Table Testing)
    - 요구사항의 논리와 발생 조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법
- 상태 전이 테스트(State Transition Testing)
    - 테스트 대상∙시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법
- 유스케이스 테스트(Use Case Testing)
    - 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법
- 분류 트리 테스트(Classification Tree Method Testing)
    - SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법
- 원인-결과 그래프 테스트(Cause-Effect Graph Testing)
    - 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법

---

Q. 직원 테이블과 부서 테이블이 다음과 같을 때 다음 쿼리를 수행한 결과를 쓰시오.

> 3, 4
> 

[부서] 테이블

| 부서코드 | 부서명 |
| --- | --- |
| 10 | 기획부 |
| 20 | 영업부 |
| 30 | 디자인부 |

[직원] 테이블

| 부서코드 | 직원코드 | 부서원 |
| --- | --- | --- |
| 10 | 1 | 홍길동 |
| 10 | 2 | 장길산 |
| 20 | 3 | 임꺽정 |
| 20 | 4 | 김철수 |
| 20 | 5 | 이영희 |
| 30 | 6 | 이순신 |
| 30 | 7 | 안중근 |

[조건]

- [부서] 테이블 생성할 시 부서코드는 PRIMARY KEY로 선언되어 있고 CASCADE 함수를 사용
- [직원] 테이블의 부서코드는 [부서] 테이블의 부서코드를 FOREIGN KEY로 참조함

[쿼리]

```sql
① SELECT COUNT(DISTINCT 부서코드) FROM 직원;

② DELETE FROM 부서 WHERE 부서코드='20';
	SELECT COUNT(DISTINCT 직원코드) FROM 직원;
```

---

Q. () 안에 들어갈 용어를 쓰시오.

> 사회공학(Social Engineering), 다크 데이터(Dark data)
> 
- ( ① )은/는 사람들의 심리와 행동 양식을 교묘하게 이용해서 원하는 정보를 얻는 공격 기법이다.
- ( ② )은/는 정보를 수집한 후, 저장만 하고 분석에 활용하고 있지 않은 다량의 데이터이다.

- 사회공학(Social Engineering)
    - 사람들의 심리와 행동 양식을 교묘하게 이용해서 원하는 정보를 얻는 기법
    - 컴퓨터 보안에 있어서, 인간 상호작용의 깊은 신뢰를 바탕으로 사람들을 속여서 정상 보안 절차를 깨뜨리기 위한 비기술적 시스템 침입 수단
    - 사례로는 상대방의 자만심이나 권한을 이용하는 공격 및 도청 등이 있음
- 다크 데이터(Dark data)
    - 수집된 후 저장은 되어 있지만, 분석에 활용되지는 않는 다량의 데이터

---

**Q. 다음은 파이썬 코드이다. 실행 결과를 쓰시오.**

> [101, 102, 103, 104, 105]
> 

```python
l = [1, 2, 3, 4, 5]
l = list[map(lambda num : num + 100, l)]
print(l)
```

- 리스트 l은 1, 2, 3, 4, 5로 초기화된다.
- 파이썬 **map 함수**에서 첫 번째 매개변수에는 **함수**, 두 번째 매개변수에는 **리스트를 지정**하여 반복을 수행한다. 첫 번째 매개변수에는 lambda 함수를 전달할 수도 있다. lambda 함수는 함수 이름 없이 동작하는 함수로 아래와 같이 작성한다.
    
    ```python
    lambda 매개변수 : 표현식
    ```
    
- num : num + 100에서 매개변수인 왼쪽 num의 값으로 리스트 l의 값이 순차적으로 전달되며, 이 값은 오른쪽 num + 100에 전달되어 연산한다. 1 + 100, 2 + 100, 3 +100, 4 + 100, 5 + 100이 실행되어 101, 102, 103, 104, 105가 계산된다.
- list 함수 매개변수에 101, 102, 103, 104, 105가 전달되며, 리스트로 반환한 결과를 l에 대입한다. print 함수에서 리스트 l을 출력한다.

---

Q. 다음이 설명하는 보안 장비는 무엇인가?

> SIEM(Security Information and Event Management)
> 

다양한 보안 장비와 서버, 네트워크 장비 등으로부터 보안 로그와 이벤트 정보를 수집한 후 정보 간의 연관성을 분석하여 위협 상황을 인지하고, 침해사고에 신속하게 대응하는 보안 관제 솔루션(Solution)이다. 특히, 기업에서 생성되는 테라바이트(terabyte)급의 정형∙비정형 데이터와 방화벽, 안티바이러스 시스템, 서버, 네트워크 장비 등으로부터 수집한 다양한 데이터 등을 빅데이터 기반의 로그 분석을 통하여 보안의 위협 징후를 빠르게 판단・대응할 수 있도록 해주는 보안 관제 솔루션이다.

- SIEM(Security Information and Event Management)
    - 다양한 보안장비와 서버, 네트워크 장비 등으로부터 보안 로그와 이벤트 정보를 수집한 후 정보 간의 연관성을 분석하여 위협 상황을 인지하고, 침해사고에 신속하게 대응하는 보안 관제 솔루션
    - 기업에서 생성되는 테라바이트급의 정형∙비정형 데이터와 방화벽, 안티바이러스 시스템, 서버, 네트워크 장비 등으로부터 수집한 다양한 데이터 등을 빅데이터 기반의 로그 분석을 통하여 보안의 위협 징후를 빠르게 판단・대응할 수 있도록 해주는 보안 관제 솔루션
- ESM(Enterprise Security Management)
    - 방화벽(Firewall), 침입 탐지 시스템(IDS), UTM, 가상 사설망 등의 여러 보안 시스템으로부터 발생한 각종 이벤트 및 로그를 통합해서 관리, 분석, 대응하는 전사적 통합 보안 관리 시스템
    - ESM은 서로 다른 기종의 보안 장비들을 통합 관리하는 기능과 네트워크 자원 현황의 보안 모니터링 기능이 있고, 주로 이벤트 위주의 단시간 위협 분석 및 DBMS 기반의 보안 관리 솔루션

---

Q. 다음은 형상 관리에 대한 설명이다. () 안에 들어갈 형상 관리 도구를 보기에서 고르시오.

> SVN, CVS, Git
> 
- ( ① ): 중앙집중형 클라이언트-서버 방식으로 하나의 서버에서 소스를 쉽고, 유용하게 관리할 수 있게 도와주는 도구로 저장소를 만들어 그곳에 소스를 저장해서 소스 중복이나 여러 문제를 해결하기 위한 도구
- ( ② ): 가장 오래된 형상 관리 도구 중의 하나로서 중앙집중형 서버 저장소를 두고 클라이언트가 접속해서 버전 관리를 실행하는 형상 관리 도구로 파일 단위로 변경 사항 관리가 가능한 도구
- ( ③ ): 로컬 저장소와 원격 저장소로 분리되어 분산 저장하는 도구로 빠른 속도에 중점을 둔 분산형 버전 관리 시스템이며, 대형 프로젝트에서 효과적이고 유용한 도구

- 소프트웨어 형상 관리도구에는 SVN, CVS, Git 등이 있다.
    - CVS(Concurrent Versions System)
        - 가장 오래된 형상 관리 도구 중의 하나로서 중앙 집중형 서버 저장소를 두고 클라이언트가 접속해서 버전 관리를 실행하는 형상 관리 도구
        - 파일 단위 변경사항 관리가 가능하고 다수의 인원이 동시에 범용적인 운영체제로 접근이 가능한 형상 관리 도구
    - SVN(Subversion)
        - 중앙집중형 클라이언트-서버 방식으로 하나의 서버에서 소스를 쉽고 유용하게 관리할 수 있게 도와주는 도구
        - 저장소를 만들어 그곳에 소스를 저장해서 소스 중복이나 여러 문제를 해결하기 위한 도구로 바이너리 파일관리 및 롤백 기능을 지원
    - Git
        - 로컬 저장소와 원격 저장소로 분리되어 분산 저장하는 도구
        - 빠른 속도에 중점을 둔 분산형 버전 관리 시스템이며, 대형 프로젝트에서 효과적이고 유용함
        - 커밋(Commit) 동작은 로컬 저장소에서 이루어지고, 푸시(Push)라는 동작은 원격 저장소에 반영됨

---

Q. 학생(STUDENT) 테이블에 정보과 학생 50명, 전기과 학생 100명, 전산과 학생 50명에 관한 데이터가 있다고 했을 때, 다음에 주어지는 SQL문을 각각 실행시켰을 때 튜플 수는 각각 몇 개인가?(단, DEPT는 학과 컬럼명이다.)

> 200, 3, 1
> 
- 정보과 = 50명
- 전기과 = 100명
- 전산과 = 50명

```sql
SELECT DEPT FROM 학생;
SELECT DISTINCT DEPT FROM 학생;
SELECT COUNT(DISTINCT DEPT) FROM 학생 WHERE DEPT = '전산과';
```

- 단순 SELECT(조건검색)의 경우 전체 테이블의 튜플을 검색하기 때문에 200건(=50+100+50)이 조회된다.
- DISTINCT(중복제거)의 경우 동일한 튜플을 제거하고 검색하기 때문에 ‘정보과’ 1건, ‘전기과’ 1건, ‘전산과’ 1건으로 총 3건이 조회된다.
- GROUP BY가 없을 경우 전체 테이블에서의 튜플 개수를 COUNT를 통해 출력하기 때문에 출력값을 표현한 1개가 튜플이다.

---

Q. 다음은 C언어 코드이다. 실행 결과를 쓰시오.

> 2
> 

```c
#include <stdio.h>
void main() {
	int i, j, k, s;
	int el = 0;
	for(i=6; i<=30; i++) {
		s=0;
		k=i/2;
		for(j=1; j<=k; j++) {
			if(i%j == 0) {
				s=s+j;
			}
		}
		if(s==i) {
			el++;
		}
	}
	printf("%d", el);
}
```

- 완전수 - 6, 28, 496, 8128, …

---

Q. 다음 주요 IT 기술에 대한 용어 설명이다. () 안에 들어갈 용어를 보기에서 골라서 쓰시오.

> 트러스트존(Trustzone), 타이포스쿼팅(Typosquatting)
> 
- ( ① )은/는 프로세서(Processor) 안에 독립적인 보안구역을 따로 두어 중요한 정보를 보호하는 ARM 사에서 개발한 보안 기술로 프로세서(Processor) 안에 독립적인 보안구역을 따로 두어 중요한 정보를 보호하는 하드웨어 기반의 보안 기술이다.
- ( ② )은/는 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 일로, URL 하이재킹(Hijacking)이라고도 부른다.

[보기]

㉠ 트러스트존(Trustzone)

㉡ 타이포스쿼팅(Typosquatting)

㉢ 키로거 공격(Key Logger Attack)

㉣ 레이스 컨디션 공격(Race Condition Attack)

㉤ APT 공격(Advanced Persistent Attack)

㉥ 공급망 공격(Supply Chain Attack)

㉦ 악성 봇(Malicious Bot)

㉧ 사이버 킬체인(Cyber Kill Chain)

㉨ 랜섬웨어(Ransomware)

---

Q. 다음에서 설명하는 용어를 쓰시오.

> SSO(Single Sign-On)
> 
- 커버로스에서 사용되는 기술로 한 번의 인증 과정으로 여러 컴퓨터상의 자원을 이용할 수 있도록 해주는 인증 기술

- SSO(Single Sign On)
    - 커버로스에서 사용되는 기술로 한 번의 인증 과정으로 여러 컴퓨터상의 자원을 이용할 수 있도록 해주는 인증 기술
- 커버로스(Kerberos)
    - 1980년대 중반 MIT의 Athena 프로젝트의 일환으로 개발되었으며 클라이언트/서버 모델에서 동작하고 대칭키 암호기법에 바탕을 둔 프로토콜
    - 보안이 되지 않는 네트워크에서 통신하는 노드가 보안 방식으로 다른 노드에 대해 식별할 수 있게 허용하는 “티켓”(Ticket) 기반으로 동작하는 컴퓨터 네트워크 인증 암호화 프로토콜

---

Q. 다음은 프로세스 스케줄링에 대한 설명이다. () 안에 들어갈 스케줄링 기법을 쓰시오.

> SJF, RR, SRT
> 
- ( ① ): 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원을 점유하는 스케줄링 기법
- ( ② ): 프로세스 같은 크기의 CPU 시간을 할당(시간 할당량), 프로세스가 할당된 시간 내에 처리 완료를 못하면 준비 큐 리스트의 가장 뒤에 보내지고, CPU는 대기 중인 다음 프로세스로 넘어가는 스케줄링 기법
- ( ③ ): 가장 짧은 시간이 소요되는 프로세스를 먼저 수행, 남은 처리시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점되는 스케줄링 기법으로 비선점 방식의 스케줄링 기법에 선점 방식을 도입한 방법

- SJF(Shortest Job First)
    - 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원을 점유하는 스케줄링 기법
    - CPU 요구시간이 긴 작업과 짧은 작업 간의 불평등이 심하여, CPU 요구시간이 긴 프로세스는 기아 현상 발생
- 라운드 로빈(RR; Round Robin)
    - 프로세스는 같은 크기의 CPU 시간을 할당(시간 할당량), 프로세스가 할당된 시간 내에 처리 완료를 못하면 준비 큐 리스트의 가장 뒤로 보내지고, CPU는 대기 중인 다음 프로세스로 넘어가는 스케줄링 기법
- SRT(Shortest Remaining Time First)
    - 가장 짧은 시간이 소요되는 프로세스를 먼저 수행, 남은 처리시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 프로세스가 선점되는 스케줄링 기법으로 비선점 방식의 스케줄링 기법에 선점 방식을 도입한 기법
    - 짧은 수행시간 프로세스를 우선 수행

---

Q. 다음 UML에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 관계, 클래스, 인터페이스
> 
- ( ① ): UML의 구성 요소 중 사물의 의미를 확장하고 명확히 하는 요소로 사물과 사물을 연결하여 표현하는 요소
- ( ② ): 공통의 속성, 연산(메서드), 관계, 의미를 공유하는 객체들의 집합
- ( ③ ): 기능을 모아놓은 클래스로 추상 메서드와 상수만을 포함하는 추상 클래스로 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 역할을 하는 클래스

---

Q. 다음은 E-R 다이어그램이다. () 안에 들어갈 구성요소를 E-R 다이어그램의 보기에서 고르시오.

> ㉡, ㉦, ㉤, ㉥, ㉣
> 

![이미지](/assets/img/exam/previous/2022(3)_13.png)

- ( ① ): 개체 집합의 단일 속성을 나타낸다.
- ( ② ): 관계 집합의 속성을 나타낸다.
- ( ③ ): 개체 집합과 속성을 이어준다.
- ( ④ ): 개체 집합과관계 집합을 이어준다.
- ( ⑤ ): 관계 집합을 나타낸다.

- 개체-관계(E-R) 다이어그램의 기호는 다음과 같다.

![이미지](/assets/img/exam/previous/2022(3)_14.png)

---

Q. 다음은 JAVA 언어 코드이다. 실행 결과를 쓰시오.

> 0123
> 

```java
public class Soojebi {
	static int[] MakeArray() {
		int[] tempArr = new int[4];
		for(int i=0; i<tempArr.length; i++) {
			tempArr[i] = i;
		}
		return tempArr;
	}
	public static void main(String[] args) {
		int[] intArr;
		intArr = MakeArray();
		
		for(int i=0; i<intArr.length; i++) {
			System.out.print(intArr[i]);
		}
	}
}
```

---

Q. 다음은 JAVA 언어 코드이다. 실행 결과를 쓰시오.

> 993
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int a = 0;
		for(int i=1; i<999; i++) {
			if(i%3 == 0 & i%2 != 0) 
				a = i;
		}
		System.out.print(a);
	}
}
```

- 정수형 변수 a를 0으로 초기화한다.
- for 문을 통해 i가 1부터 998까지 반복되며, if 문을 통해 i의 값이 3으로 나누어 떨어지고, 2로 나누어 떨어지지 않는 결과에 대해서만 a의 값에 대입한다.
- 마지막으로 위 조건을 만족하는 a값 993을 출력한다.


<br>
**참고 자료**

---

- <https://www.youtube.com/watch?v=vPDQ4BpfymI>
- [https://inpa.tistory.com/entry/DB-📚-관계-대수-관계-해석-SQL-🕵️-정리 - 관계대수 연산자](https://inpa.tistory.com/entry/DB-%F0%9F%93%9A-%EA%B4%80%EA%B3%84-%EB%8C%80%EC%88%98-%EA%B4%80%EA%B3%84-%ED%95%B4%EC%84%9D-SQL-%F0%9F%95%B5%EF%B8%8F-%EC%A0%95%EB%A6%AC)