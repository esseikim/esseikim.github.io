---
categories: [정보처리기사, 모의고사 문제 풀이]
---

Q. 교육 과정, 학습 및 개발 프로그램을 관리하고, 기록하고, 추적하며, 종합 보고서를 만들기 위해 활용하는 소프트웨어 애플리케이션을 무엇이라 하는가?

> LMS(Learning Management System)
> 

- LMS는 교육 과정의 전반적인 관리기능뿐만 아니라, 교육에 필요한 콘텐츠 생성 및 관리, 커뮤니케이션 기능도 포함한다.

---

Q. 기존의 IP 주소 대신 Data의 이름을 활용하여 정보(콘텐츠)의 효율적인 검색 및 배포를 목적으로 하는 인터넷 기술로, IP 주소 대신 콘텐츠의 Name을 기반으로 정보를 획득하는 기술은 무엇인가?

> NDN(Named Data Network)
> 

- 콘텐츠 기반 네트워킹, 데이터 중심 네트워킹 또는 정보 중심 네트워킹과 동일한 개념으로 인터넷에서 콘텐츠 자체의 정보와 라우터 기능만을 이용하여 목적지로 데이터를 전송하는 기술을 말한다.
- 사용자의 요청에 따라 빠른 정보 전달이 가능한 네트워크로 콘텐츠 종류에 따라 식별자 체계를 계층적으로 만들어 정보를 식별한다.

---

Q. 다음은 애플리케이션에 대한 DDoS 공격이다. () 안에 들어갈 용어를 쓰시오.

> HUK DoS, Hash DoS
> 

- ( ① )은/는 공격자가 공격 대상 웹 사이트 웹 페이지 주소(URL)을 지속적으로 변경하면서 다량으로 GET 요청을 발생시키는 서비스 거부 공격으로 임계치 기반의 디도스 대응 장비를 우회하기 위해서 주소(URL)를 지속적으로 변경시켜서 공격한다.
- ( ② )은/는 웹 서버는 클라이언트 HTTP 요청을 통해 전달되는 파라미터(매개 정보)를 효율적으로 저장하고 검색하기 위한 자료구조로 해시 테이블을 주로 사용하고, 공격자는 이러한 특성을 악용하여 조작된 많은 수의 파라미터를 POST 방식으로 웹 서버로 전달하여 다수의 해시 충돌(Collision)을 발생시켜서 자원을 소모시키는 서비스 거부 공격이다.

- 애플리케이션에 대한 DDoS 공격은 다음과 같다.
    
    
    | 공격 기법 | 설명 |
    | --- | --- |
    | HUK DoS | 공격자가 공격 대상 웹 사이트 웹 페이지 주소(URL)를 지속적으로 변경하면서 다량으로 GET 요청을 발생시키는 서비스 거부 공격으로 임계치 기반의 디도스 대응 장비를 우회하기 위해서 주소(URL)를 지속적으로 변경시켜서 공격 |
    | Hash DoS | 웹 서버는 클라이언트 HTTP 요청을 통해 전달되는 파라미터(매개 정보)를 효율적으로 저장하고 검색하기 위한 자료구조로 해시 테이블을 주로 사용하고, 공격자는 이러한 특성을 악용하여 조작된 많은 수의 파라미터를 POST 방식으로 웹 서버로 전달하여 다수의 해시 충돌(Collision)을 발생시켜서 자원을 소모시키는 서비스 거부 공격 |

---

Q. 병행 제어 기법 중 트랜잭션의 타임 스탬프와 접근하려는 데이터의 타임 스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법을 무엇이라고 하는가?

> 다중 버전 동시성 제어(MVCC; Multi Version Concurrency Control)
> 

- 병행 제어 기법의 종류는 다음과 같다.
    - 로킹(Locking)
        - 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
        - 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock(잠금)을 요청해서 Lock이 허락되어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법
        - 주요 데이터의 액세스를 상호 배타적으로 함
        - 로킹 기법은 **교착 상태(Dead lock)**가 발생할 수 있다는 한계가 있음
        - 교착 상태란, 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태를 말함
        - 하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 오직 읽기(read)만 하는 경우에는 동시에 접근해도 문제가 없기 때문에 이런 경우에 효율적이지 못함
        - 로킹의 특징은 다음과 같음
            - 데이터베이스, 파일, 레코드, 필드, 테이블 등은 로킹 단위가 될 수 있음
            - 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
            - 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아짐, 병행 제어 기법 간단해짐
            - 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 로킹 오버헤드가 증가하지만 병행성 수준이 높아짐, 데이터 베이스 공유도 증가
            - 로킹단위를 작게하여 활용도를 최대화해야 함
    - **2단계 로킹 규약**
        - 각 트랜잭션의 **lock과 unlock 요청**을 **2단계로 실시**하는 방식
        - 단계는 확장 단계(Growing phase)와 축소 단계(shrinking phase)로 나뉨
        - 이를 통해 직렬성을 보장하는 대표적인 로킹 규약이지만 여전히 lock 연산으로 인한 교착상태를 예방할 수는 없다는 단점이 있음
        - **확장 단계(Growing phase)**: 새로운 lock 연산만을 수행할 수 있고, unlock 연산은 수행할 수 없는 단계
        - **축소 단계(Shrinking phase)**: unlock 연산을 수행할 수 있고, lock연산은 수행할 수 없는 단계
    - 낙관적 검증=최적 병행수행(Optimistic Concurrency Control**,** 검증 기법, 확인 기법, 낙관적 기법)
        - 트랜잭션이 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법
        - 병행수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read Only) 트랜잭션일 경우, 트랜잭션 간의 충돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법
        - 수행 도중에는 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신하고, 트랜잭션이 종료되고 난 후에 직렬화를 검증하여 검증되면 데이터베이스에 한 번에 반영하는 방식
    - 타임 스탬프 순서(Time Stamp Ordering)
        - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
        - 직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중에서 가장 보편적인 방법임
    - 다중버전 동시성 제어(MVCC; Multi Version Concurrency Control)
        - 트랜잭션의 타임 스탬프와 접근하려는 데이터 타임 스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법
        - 한 데이터에 대해 여러 버전의 값을 유지하며 관리하는 방식
        - 타임 스탬프의 개념을 이용하며, 다중 버전 타임 스탬프 기법이라고도 함
        - 타임 스태프 기법은 트랜잭션 및 데이터들이 이용될 때의 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때 마다의 버전을 부여하여 관리함
        - 여러 버전의 타임스탬프를 비교하여 스케줄상 직렬 가능성이 보장되는 타임스탬프를 선택
        - 충돌이 발생할 경우 연쇄 복귀가 발생할 수 있는 단점이 있음

---

Q. 다음은 [행생] 테이블이다. [행성] 테이블에서 거리가 5보다 크거나 같으면서 무게가 10 이상인 튜플을 삭제하는 쿼리를 작성하시오.

```sql
DELETE 
FROM 행성 WHERE 거리 >= 5 AND 무게 >= 10;
```

[행성]

| 행성명 | 거리 | 무게 |
| --- | --- | --- |
| 수성 | 0.39 | 0.0553 |
| 금성 | 0.72 | 0.815 |
| 지구 | 1 | 1 |
| 화성 | 1.52 | 0.107 |
| 목성 | 5.20 | 317.83 |
| 토성 | 9.54 | 95.16 |
| 천왕성 | 19.23 | 14.5 |
| 해왕성 | 30.06 | 17.135 |

- DELETE는 데이터의 내용을 삭제할 때 사용하는 명령어이다.
- DELETE 명령어 문법은 다음과 같다.
    
    ```sql
    DELETE 
    FROM 테이블명
    WHERE 조건;
    ```
    
    - 모든 레코드를 삭제할 때는 WHERE절 없이 DELETE만 사용
    - 레코드를 삭제해도 테이블 구조는 남아 있어서 디스크에서 테이블을 완전히 삭제하는 DROP 명령과는 다름

---

Q. **다음은 파이썬 코드이다. 출력 결과를 쓰시오.**

> 30
> 

```python
sum=0
a = [1, 2, 3, 4, 5]
b = [2, 3, 4, 5, 6]
c = **[x*y for x in a for y in b]**
for i in c[:7]:
	sum += i

print(sum)
```

- sum은 0으로 초기화한다.
- 리스트 a는 [1, 2, 3, 4, 5]로 초기화하고 b는 [2, 3, 4, 5, 6]으로 초기화한다.
- c는 리스트 내포로 [x*y for x in a for y in b]는 아래와 같이 계산된다.(**a와 b의 각 원소를 곱한 값을 리스트 c의 원소로 대입**)
    
    
    | a | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 3 | 3 | 3 | 3 | 3 | 4 | 4 | 4 | 4 | 4 | 5 | 5 | 5 | 5 | 5 |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    | b | 2 | 3 | 4 | 5 | 6 | 2 | 3 | 4 | 5 | 6 | 2 | 3 | 4 | 5 | 6 | 2 | 3 | 4 | 5 | 6 | 2 | 3 | 4 | 5 | 6 |
    | c | 2 | 3 | 4 | 5 | 6 | 4 | 6 | 8 | 10 | 12 | 6 | 9 | 12 | 15 | 18 | 8 | 12 | 16 | 20 | 24 | 10 | 15 | 20 | 25 | 30 |

- 마지막으로 for 반복문은 리스트 c의 원소(2, 3, 4, 5, 6, 4, 6)의 합계를 계산한다.
- sum += i 부분에서는 i 값과 sum 값을 더한 후 sum에 대입한다.
- 다음과 같이 for 반복문에서 계산이 된다.
    
    
    | c | c[0] | c[1] | c[2] | c[3] | c[4] | c[5] | c[6] |
    | i | 2 | 3 | 4 | 5 | 6 | 4 | 6 |
    | sum | 2 | 5 | 9 | 14 | 20 | 24 | 30 |

---

Q. 소프트웨어 생명주기에서 시스템 명세 단계에서 정의한 기능을 실제 수행할 수 있도록 수행 방법을 논리적으로 결정하는 단계는 무엇인가?

> 설계 단계
> 

- 소프트웨어 생명주기 모델 프로세스는 다음과 같다.
    
    
    | 프로세스 | 설명 |
    | --- | --- |
    | 요구사항 분석 | 다양한 이해관계자의 상충할 수도 있는 요구사항을 고려하여 새로운 제품이나 변경된 제품에 부합하는 요구와 조건을 결정화는 단계 |
    | 설계 | 시스템 명세 단계에서 정의한 기능을 실제 수행할 수 있도록 수행 방법을 논리적으로 결정하는 단계 |
    | 구현 | 설계 단계에서 논리적으로 결정한 문제 해결 방법을 특정 프로그래밍 언어를 사용하여 실제 프로그램을 작성하는 단계 |
    | 테스트 | 시스템이 정해진 요구를 만족하는지, 예상과 실제 결과가 어떤 차이를 보이는지 검사하고 평가하는 단계 |
    | 유지보수  | 시스템이 인수되고 설치된 후 일어나는 모든 활동을 포함하는 단계 |

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 85
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int[] a = new int[10];
		int sum=100;
		for(int i=0; i<a.length; i++) {
			a[i] = i+1;
		}
		for(int i=0; i<a.length; i++) {
			if(i%3==1) {
				sum -= a[i];
			}
		}
		System.out.print(sum);
	}
	
}
```

---

Q. 논리적 데이터 모델링 중 논리적 구조가 트리 형태로 구성된 모델로 상하 관계가 존재하며, 1:N 관계만 허용하는 데이터 모델은 무엇인가?

> 계층 데이터 모델
> 

- 논리적 데이터 모델링 종류에는 관계 데이터 모델, 계층 데이터 모델, 네트워크 데이터 모델이 있다.
    - 관계 데이터 모델
        - 논리적 구조가 2차원 테이블 형태로 구성된 모델
        - 기본 키(PK)와 이를 참조하는 외래 키(FK)로 관계 표현
        - 1:1, 1:N, N:M 관계를 자유롭게 표현
    - 계층 데이터 모델
        - 논리적 구조가 트리 형태로 구성된 모델
        - 상하 관계 존재(부모 개체-자식 개체)
        - 1:N 관계만 허용
    - 네트워트 데이터 모델
        - 논리적 구조가 그래프 형태로 구성된 모델
        - CODASYL DBTG

- 데이터 모델
    - 현실 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델
    - 표시해야할 요소: 논리적 데이터 구조, 연산, 제약조건
- 절차
    - 개념적 데이터 모델 → 논리적 데이터 모델 → 물리적 데이터 모델
- **개념적 데이터 모델**
    - 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 **개념적 구조 도출**
    - DB 종류와 관계 없음
    - 주요 산출물: 개체 관계 다이어그램(**ERD**)
- **논리적 데이터 모델**
    - 업무의 모습을 모델링 표기법으로 **형상화하여 사람이 이해하기 쉽게 표현**
    - **목표 DBMS에 맞는 스키마 설계**
    - **정규화** 수행
- **물리적 데이터 모델**
    - 특정 DBMS 특성 및 성능을 고려하여 **물리적인 스키마 생성**
    - 테이블, 인덱스, 뷰, 파티션 등 객체 생성
    - 성능 측면에서 **반정규화** 수행

- 논리 데이터 모델 검증
    - 논리 데이터 모델링 개념
        - 개념 모델로부터 업무 영역의 **업무 데이터 및 규칙을 구체적으로 표현**한 모델
    - 논리적 데이터 모델링 종류
        - **관계 데이터 모델**
            - E.F.Codd 박사가 제안
            - 2차원 테이블 형태
            - 기본 키와 외래 키로 표현
            - 1:1, 1:N, N:M 관계
        - **계층 데이터 모델**
            - 트리 형태
            - 상하 관계 존재(부모-자식)
            - 1:N 관계만
        - **네트워크 데이터 모델**
            - 그래프 형태
            - CODASYL DBTG 모델
            - 상위, 하위 레코드 사이에 N:M(다대다) 관계

- 관계형 데이터 모델
    - 관계형 데이터 모델은 1970년에 IBM에서 근무하던 코드(E. F. Codd)에 의해 처음 제안되었다.
    - 이 모델은 관계형 데이터베이스를 구성하는 개체(Entity)나 관계(Relationship)를 모두 릴레이션(Relation)이라는 표(Table)로 표현한다.
    - 관계형 데이터 모델은 간결하고 보기 편리하여, 다른 데이터베이스로의 변환도 용이하다.
    - 그러나 성능 면에서는 다소 떨어질 수 있다. 한 가지 데이터만 조회하려 해도 릴레이션 전체를 사용해야 하기 때문이다. 이러한 단점을 보완하기 위해 NoSQL(non SQL 또는 non Relational)이라고 하는 관계가 없는 비 관계형 데이터베이스가 등장했다. 이러한 NoSQL 데이터베이스는 관계형 데이터베이스의 제약을 벗어나 더 효율적인 데이터 저장 및 처리를 제공한다.
    - 관계형 데이터베이스 릴레이션(Relation) 구조
        - 릴레이션(Relation): 테이블
        - 튜플(Tuple)
            - 릴레이션을 구성하는 각각의 행
            - 속성의 모임으로 구성
            - 파일 구조에서 레코드와 같은 의미
            - 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응수 라고도 함
            - <학생> 릴레이션에서 카디널리티는 4이다.
        - 속성(Attribute)
            - 데이터베이스를 구성하는 가장 작은 논리적 단위
            - 파일 구조에서 데이터 항목 또는 데이터 필드에 해당
            - 개체의 특성을 기술
            - 속성의 수를 디그리(Degree) 또는 차수라고 함
            - <학생> 릴레이션에서 차수(디그리)는 5이다.
        - 카디널리티(Cardinality): 튜플의 수
        - 차수(Degree): 속성의 수
        - 스키마(Schema): 제약조건 등 정보 담고 있는 기본적인 DB의 구조
        - 인스턴스(Instance): 스키마에 따라 실제 저장된 데이터의 집합
        - 도메인(Domain)
            - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합
            - 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는 데에도 이용
            - <학생>릴레이션의 '학년' 도메인은 1~4이다.
        
        ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(1).png)
        
- 관계 대수
    - 관계형 데이터베이스에서 원하는 정보와 그것을 어떻게 유도하는가 기술하는 절차적 정형언어
    - 연산자 종류
        - 일반 집합 연산자
            - 합집합(∪)
            - 교집합(∩)
            - 차집합(－)
            - 카티션 프로덕트(×): 모든 튜플을 연결하여 릴레이션 구성
        - 순수 관계 연산자
            - 셀렉트(σ): 조건 만족하는 튜플 반환
            - 프로젝트(π): 주어진 속성 값으로만 구성된 튜플 반환
            - 조인(⋈): 공통 속성을 이용해 두 릴레이션의 튜플 연결
            - 디비전(÷): R÷S일때, S 튜플과 관련있는 R 튜플 반환
- 관계 해석
    - 튜플 관계 해석과 도메인 관계 해석을 하는 비절차적 언어
    - 프레디킷 해석에 기반한 언어이며 비절차적 언어

- 개체 관계 다이어그램(ERD; Entity-Relationship Diagram)
    - E-R 다이어그램은 E-R 모델을 표현하기 위한 것인데 E-R 모델은 개체 타입(Entity Type)과 각 타입 간의 관계 타입(Relationship Type)을 이용해 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해 가장 널리 사용되고 있는 모델이다.
    - 피터 첸 표기법(Peter Chen Notation)은 1976년 피터 첸(Peter Chen)이 개발한 표기법이다.
        - 개체: □
        - 관계: ◇
        - 속성: ○
        - 다중 값 속성: ◎
        - 개체-속성 연결 : ―
    
    ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(2).png)
    
    ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(3).png)
    

---

Q. **[학생] 테이블에 ‘성별’이라는 이름의 컬럼을 추가하시오. 단 CHAR(1) 데이터 타입을 갖고 ‘M’, ‘F’ 값만 들어갈 수 있도록 제약조건을 추가하시오.**

```sql
ALTER TABLE 학생 ADD 성별 CHAR(1) CHECK(성별 IN('M', 'F'));
```

```sql
ALTER TABLE 학생 ADD 성별 CHAR(1) CHECK(성별 = 'M' OR 성별 = 'F');
```

- ALTER TABLE은 테이블을 수정하는 명령이다.
- ALTER TABLE에서 컬럼을 추가하기 위해서는 ADD라는 키워드를 쓰고 문법은 다음과 같다.
    
    ```sql
    ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건];
    ```
    
- 추가로 제약조건은 다음과 같다.
    - PRIMARY KEY
        - 테이블의 기본 키를 정의
        - 유일하게 테이블의 각 행을 식별
    - FOREIGN KEY
        - 외래 키를 정의
        - 참조 대상을 테이블(컬럼명)로 명시
        - 열과 참조된 테이블의 열 사이의 외래 키 관계를 적용하고 설정
    - UNIQUE
        - 테이블 내에서 얻은 유일한 값을 갖도록 하는 제약조건
    - NOT NULL
        - 해당 컬럼은 NULL 값을 포함하지 않도록 하는 제약조건
    - CHECK
        - 개발자가 정의하는 조건
        - 참(TRUE)이어야 하는 조건을 지정
    - DEFAULT
        - 데이터를 INSERT 할 때 해당 컬럼의 값을 넣지 않는 경우 기본값으로 설정해주는 제약조건

---

Q. 다음은 C언어 코드이다. 밑줄에 들어갈 코드를 쓰시오.

> &num
> 

```c
#include <stdio.h>
void main() {
	int num = 10;
	int *pnum =      ;
	num--;
	printf("%d", *pnum);
}
```

[출력 결과]

```c
9
```

- 정수형 변수 num은 10으로 선언과 동시에 초기화된다.
- 정수형 포인터 변수 pnum은 선언과 동시에 num의 주솟값을 대입한다.
- num 변수값을 1 감소시킨다.
- 화면에 pnum 값6이 가리키는 값인 num 값 9를 출력한다.

---

Q. 네트워크를 경유하는 프로세스 간 통신의 접속점으로 클라이언트와 서버 프로그램 사이에 데이터를 송수신할 수 있는 기술은 무엇인가?

> 소켓(Socket)
> 

- 소켓은 IP address와 Port 넘버가 합쳐진, 네트워크상에서 서버 프로그램과 클라이언트 프로그램이 통신할 수 있도록 해주는 교환 기술이다.
- 서버와 클라이언트 간 소켓 연결 방식은 다음과 같다.
    
    ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(4).png)
    
- 서버 소켓과 클라이언트 소켓을 만듦(socket())
- 서버 소켓은 로컬 IP를 가지고 포트를 열고(bind()), 클라이언트는 연결을 기다림(listen())
- 클라이언트 소켓은 IP 주소를 이용해 목적지 호스트를 찾아내고 포트를 이용해 통신 접속점을 찾아내서 연결을 만듦(connect())
- 서버 소켓이 연결을 수락하면(accept()), 포트를 이용해 데이터를 주고받음(send(), recv())

---

Q. SW 개발 보안의 3대 요소 중 무결성이란 무엇인지 서술하시오. 

> 무결성이란 정당한 방법을 따르지 않고서는 데이터가 변경될 수 없으며, 데이터의 정확성 및 완전성과 고의로 변경되거나 훼손 또는 파괴되지 않음을 보장하는 특성이다.
> 

- SW 개발 보안의 3대 요소는 다음과 같다.
    
    
    | 요소 | 설명 |
    | --- | --- |
    | 기밀성(Confidentiality) | 인가되지 않은 개인 혹은 시스템 접근에 따른 정보 공개 및 노출을 차단하는 특성 |
    | 무결성(Integrity) | 정당한 방법을 따르지 않고서는 데이터가 변경될 수 없으며, 데이터의 정확성 및 완전성과 고의/악의로 변경되거나 훼손 또는 파괴되지 않음을 보장하는 특성 |
    | 가용성(Availability) | 권한을 가진 사용자나 애플리케이션이 원하는 서비스를 지속해서 사용할 수 있도록 보장하는 특성 |

---

Q. 리뷰의 유형 중 인스펙션(Inspection)이 무엇인지 서술하시오.

> 인스펙션은 소프트웨어 요구, 설계, 원시코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 문제를 식별하고 문젱에 대한 올바른 해결을 찾아내는 형식적인 검토 기법이다.
> 

- 리뷰의 유형은 다음과 같다.
    - 인스펙션(Inspection)
        - 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 문제를 식별하고 문제에 대한 올바른 해결을 찾아내는 형식적인 검토 기법
    - 관리 리뷰(Management Review)
        - 프로젝트 진행 상황에 대한 전반적인 검토를 바탕으로 범위, 일정, 인력 등에 대한 통제 및 의사결정을 지원하는 리뷰
    - 기술 리뷰(Technical Review)
        - 정의된 계획 및 명세를 준수하고 있는지에 대한 검토를 수행하는 리뷰
        - 변경사항이 적절하게 구현되었는지를 평가하고, 여러 대안을 추천하거나 대안을 검토
        - 대표 엔지니어가 주재하며 경우에 따라서 관리자도 참가 가능
    - 워크스루(Work Throughs)
        - 검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 문제 식별, 대안 조사, 개선 활동, 학습 기회를 제공하는 가장 비형식적인 검토 기법
    - 동료 검토(Peer Review)
        - 2~3명이 진행하는 리뷰의 형태로 요구사항 명세서 작성자가 요구사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행하는 검토 기법

---

Q. 다음은 IT 업무 프로세스 관련 용어이다. () 안에 공통으로 들어갈 용어를 쓰시오.

> SLA(Service Level Agreement)
> 

고객과 서비스 제공자 간 계약인 ()의 품질 수준을 만족시키기 위한 모든 기법을 지칭하는 것으로 ()의 내용에는 서비스 수준을 측정할 수 있는 세부 서비스 요소(SLO; Service Level Object)들이 포함된다.

- IT 업무 프로세스 관련 용어는 다음과 같다.
    - ITSM(IT Service Management)
        - 정보시스템 사용자가 만족할 수 있는 서비스를 제공하고 지속적인 관리를 통해 서비스의 품질을 유지 및 증진시키기 위한 일련의 활동. 즉 기업 내의 기존 정보통신 관리 역할을 서비스 관점으로 바꿔서 고객 중심의 IT 서비스를 관리하는 기법
    - SLA(Service Level Agreement)
        - 고객과 서비스 제공자 간 계약인 서비스 수준 관리
        - 서비스 수준을 측정할 수 있는 세부 서비스 요소(SLO; Service4 Level Object)들이 포함됨
        - SLA(서비스 수준 계약)는 가동 시간, 대응 및 책임과 같은 측정 가능한 메트릭에 대한 공급자와 고객 간의 계약이다.
        - 이 계약은 보통 회사의 신규 비즈니스와 법무 팀이 작성하며, 고객과의 약속 및 그 약속을 이행하지 못했을 때의 결과를 나타낸다. 일반적으로 결과에는 재정적 불이익, 서비스 크레딧 또는 라이선스 연장이 포함된다.
            - **SLO**(서비스 수준 목표)는 가동 시간 또는 대응 시간과 같은 특정 메트릭에 대한 SLA 내의 계약이다. SLA가 여러분과 고객 간의 공식적인 계약이라면, SLO는 해당 고객에게 하는 개별적인 약속이다. SLO는 고객의 기대치를 설정하고 IT 및 DevOps 팀에게 어떤 목표를 달성하고 측정해야 하는지 알려준다.
            - **SLI**(서비스 수준 지표)는 SLO(서비스 수준 목표) 준수를 측정한다.
        
        ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(5).png)
        

---

Q. 다음은 [상품]과 [가격] 테이블이다. [상품]과 [가격] 테이블을 조인하여 [결과] 테이블처럼 나오도록 쿼리를 작성하시오.

```sql
SELECT A.상품코드 AS 상품코드, A.상품명 AS 상품명, B.상품가격 AS 상품가격
FROM 상품 A
LEFT [OUTER] JOIN 가격 B
ON A.상품코드 = B.상품코드;
```

[상품]

| 상품코드 | 상품명 |
| --- | --- |
| 100 | 딸기 |
| 101 | 망고 |
| 102 | 홍시 |
| 103 | 단감 |
| 106 | 망고스틴 |
| 107 | 포도 |

[가격]

| 상품코드 | 상품가격 |
| --- | --- |
| 100 | 7000 |
| 101 | 10000 |
| 103 | 3000 |
| 106 | 15000 |

| 상품코드 | 상품명 | 상품가격 |
| --- | --- | --- |
| 100 | 딸기 | 7000 |
| 101 | 망고 | 10000 |
| 102 | 홍시 | NULL |
| 103 | 단감 | 3000 |
| 106 | 망고스틴 | 15000 |
| 107 | 포도 | NULL |

- 외부 조인의 종류로는 왼쪽 외부 조인, 오른쪽 외부 조인, 완전 외부 조인이 있다.
    
    
    | 종류 | 설명 |
    | --- | --- |
    | 왼쪽 외부 조인(Left Outer Join) | 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터 추출 |
    | 오른쪽 외부 조인(Right Outer Join) | 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출 |
    | 완전 외부 조인(Full Outer Join) | 양쪽의 모든 데이터를 추출 |
- 왼쪽 테이블인 [상품] 테이블의 ‘상품코드’에 해당하는 값이 오른쪽 테이블인[가격] 테이블에 있을 경우 값을 조인하고, 그렇지 않으면 NULL 값으로 되어있는 것을 보면 왼쪽 외부 조인(Left Outer Join)임을 알 수 있다.
- 왼쪽 외부 조인 문법은 다음과 같다.
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2
    FROM 테이블1 A
    LEFT [OUTER] JOIN 테이블2 B
    ON 조인조건
    [WHERE 검색조건];
    ```
    

---

Q. 행운권 번호 추첨 시스템에 대한 테스트를 진행 중이다. 행운권 번호를 1부터 28까지 입력할 수 있을 때, 경곗값 분석 테스트를 수행하기 위한 입력 값을 쓰시오.(단, 입력 값이 4개가 나와야 한다.)

> 0 1 28 29
> 

- 입력값이 4개가 나와야 한다는 조건이 있기 때문에 경계를 포함해서 4개의 입력값을 도출한다.
- 경곗값 선택 방법은 다음과 같다.
    - 2-value
        - 경계에 있는 값
        - 바로 위, 아래 중 하나의 값
        - 경계가 유효하면 유효하지 않은 값, 유효하지 않으면 유효한 값 선택
    - 3-value
        - 경계에 있는 값
        - 경계 바로 위의 값
        - 경계 바로 아래의 값

---

Q. 다음은 시스템 보안 공격과 대응방안에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 스택 버퍼 오버플로우(Stack Buffer Overflow) 공격, 스택가드(Stackguard) 활용, 스택쉴드(Stack Shield) 활용
> 

( ① )은/는 스택 영역에 할당된 버퍼 크기를 초과하는 양의 데이터(실행 가능 코드)를 입력하여 복귀 주소를 변경하고 공격자가 원하는 임의의 코드를 실행하는 공격기법이다. ( ① ) 기법에 대응방안에는 ( ② )와/과 ( ③ )이/가 있다. 먼저 ( ② )은/는 카나리(Canary)라고 불리는 무결성 체크용 값을 복귀 주소와 변수 사이에 삽입해 두고, 버퍼 오버플로우 발생 시 카나리 값을 체크, 변할 경우 복귀 주소를 호출하지 않는 방식으로 대응하는 기법이고, ( ③ )은/는 함수 시작 시 복귀 주소를 Global RET라는 특수 스택에 저장해 두고, 함수 종료 시 저장된 값과 스택의 RET 값을 비교해 다를 경우 오버플로로 간주하고 프로그램 실행을 중단하는 기법이다.

- 시스템 보안 공격 중 스택 버퍼 오버플로우 공격과 대응 기법인 스택가드 방법, 스택쉴드 방법에 대한 내용은 다음과 같다.
    - 스택 버퍼 오버플로우(Stack Buffer Overflow) 공격
        - 스택 영역에 할당된 버퍼 크기를 초과하는 양의 데이터(실행 가능 코드)를 입력하여 복귀 주소를 변경하고 공격자가 원하는 임의의 코드를 실행하는 공격 기법
        - 스택은 함수 처리를 위해 **지역변수 및 매개변수가 위치하는 메모리 영역**을 말한다. 스택에 할당된 버퍼들이 문자열 계산 등에 의해 정의된 버퍼의 한계치를 넘는 경우 버퍼 오버플로우가 발생하여 **복귀주소(Return Address)를 변경**하고 공격자가 원하는 임의 코드를 실행한다.
    - 힙(Heap) 버퍼 오버플로우
        - 힙은 사용자가 **동적으로 할당하는 메모리 영역**(malloc()등의 메모리 할당 함수 이용)이다. 힙에 할당된 버퍼들에 문자열 등이 저장되어 질 때, 최초 정의된 힙의 메모리 사이즈를 초과하여 문자열 등이 저장되는 경우 버퍼 오버플로우가 발생하여 **데이터와 함수 주소 등을 변경**하여 공격자가 원하는 임의 코드를 실행한다.
    - 스택가드(Stackguard) 활용
        - 카나리(Canary)라고 불리는 무결성 체크용 값을 복귀주소와 변수 사이에 삽입해두고, 버퍼 오버플로우 발생 시 카나리 값을 체크, 변할 경우 복귀 주소를 호출하지 않는 방식으로 대응하는 기법
    - 스택쉴드(Stack Shield) 활용
        - 함수 시작 시 복귀 주소를 Global RET라는 특수 스택에 저장해 두고, 함수 종료 시 저장된 값과 스택의 RET 값을 비교해 다를 경우 오버플로우로 간주하고 프로그램 실행을 중단하는 기법
    - **ASLR(Address Space Layout Randomization)**: 메모리 공격을 방어하기 위해 주소 공간 배치를 난수화 하는 기법이다. 실행 시 마다 메모리 주소를 변경시켜 악성코드에 의한 특정주소 호출을 방지한다.
    
    ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(6).png)
    

![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(7).png)

![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(8).png)

- 아래는 각 레지스터의 역할에 대한 설명이다.
    - **RET(Return Address)**: 호출된 함수에서 호출한 함수로 복귀하는 역할을 한다. 함수가 호출될 때마다 호출된 함수의 반환 주소가 스택에 저장되며, 이 반환 주소를 통해 호출한 함수로 다시 돌아간다. 스택의 RET 부분을 원하는 명령이 있는 곳의 메모리 주소로 덮어쓰면, 프로그램의 흐름을 조작하여 원하는 명령을 실행시킬 수 있다.
    - **SFP(Saved Frame Pointer)**: 현재 함수의 호출 프레임에 이전 함수의 프레임 포인터 값을 저장한다. 이전 함수의 프레임 포인터 값을 저장하여 스택 프레임을 올바르게 복원할 수 있도록 한다. RBP 값을 스택에 저장
    - **RBP(Extended Base Pointer)**: 현재 스택 프레임의 베이스를 가리키는 포인터이다. 함수 내에서 지역 변수 및 매개 변수에 접근하기 위해 사용된다. 고급 수준의 프로그래밍에서 스택에 있는 함수 매개 변수 및 지역 변수를 참조하는 데 사용된다.
    - **RSP(Extended Stack Pointer)**: 현재 스택의 맨 위 주소를 가리키는 포인터이다. 스택 프레임의 상단 주소를 나타내며, 스택에 데이터를 푸시(push)하거나 팝(pop)할 때 사용된다.
    - EBP와 ESP는 각각 베이스 포인터와 현재의 스택 포인터를 나타내며, 함수 내부의 지역 변수 및 매개 변수에 접근하는 데 사용된다.

---

Q. 다음은 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식인 아키텍처 패턴(Patterns)의 유형에 대한 설명이다. () 안에 들어갈 유형을 쓰시오.

> 레이어 패턴(Layered Pattern), 파이프-필터(Pipe-Filter Pattern)
> 
- ( ① )은/는 각각의 서브 시스템들이 계층 구조를 이루며 서로 마주 보는 두 개의 계층 사이에만 상호 작용이 이루어지는 패턴이다.
- ( ② )은/는 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴으로 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복하는 패턴이다.

- 소프트웨어 아키텍처 패턴 유형은 다음과 같다.
    - 계층화 패턴(Layered Pattern)
        - 시스템을 계층(Layer)으로 구분하여 구성하는 패턴
        - 각 하위 모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공
        - 서로 마주 보는 두 개의 계층 사이에서만 상호작용이 이루어짐
        
        ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(9).png)
        
    - 클라이언트-서버 패턴(Client-Server Pattern)
        - 하나의 서버와 다수의 클라이언트로 구성된 패턴
        - 사용자가 클라이언트를 통해서 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스를 제공
        - 서버는 계속 클라이언트로부터 요청을 대기
        
        ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(10).png)
        
    - 파이프-필터 패턴(Pipe-Filter Pattern)
        - 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴
        - 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복
        - 필터 컴포넌트는 재사용성이 좋고, 추가가 쉽기 때문에 확장이 용이
        
        ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(11).png)
        
    - 모델-뷰-컨트롤러 패턴(MVC; Model Veiw Controller Pattern)
        - MVC 패턴이라고도 하는 이 패턴은 대화형 애플리케이션을 모델, 뷰, 컨트롤러 3개의 서브 시스템으로 구조화하는 패턴
            - 모델(Model): 핵심 기능과 데이터 보관
            - 뷰(View): 사용자에게 정보 표시(하나 이상의 뷰가 정의될 수 있음)
            - 컨트롤러(Controller): 사용자로부터 요청을 입력받아 처리
        - 각 부분이 별도의 컴포넌트로 분리되어 있어서 서로 영향을 받지 않고 개발 작업 수행 가능
        - 컴포넌트를 분리하며 코드의 효율적인 재사용을 가능하게 하고, 여러 개의 뷰가 있어야 하는 대화형 애플리케이션 구축에 적합
        
        ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(12).png)
        
    - 브로커 패턴(Broker Pattern)
        - 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호작용이 가능한 패턴
        - 브로커 컴포넌트는 컴포넡트 간의 통신을조정하는 역할 수행
        - 서버는 자신의 기능들(서비스 및 특성)을 브로커에 넘겨주며(Publish), 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 리다이렉션(Redirection) 함
        
        ![이미지](/assets/img/exam/23/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_23%ED%9A%8C(13).png)
        

---

Q. **다음은 자바 코드이다. 출력 결과를 쓰시오.**

> 246
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4, 5};
		int[] temp = {1, 2, 4, 6, 8};
		int idx=0;
		boolean flag;
		
		for(int i=0; i<arr.length; i++) {
			flag = false;
			if(arr[i] == temp[i]) {
				flag = true;
			}
			
			if(!flag) {
				temp[idx++] = arr[i];
				System.out.print(**temp[idx]**);
			}
		}
	}
}
```

- 정수형 배열 arr은 선언과 동시에 1, 2, 3,4, 5로 초기화하고 정수형 배열 temp는 1, 2, 4, 6, 8로 초기화한다.
- 정수형 변수 idx는 0으로 초기화하고 boolean 변수 flag는 선언만 한다.
- for 반복문은 i 값이 0부터 arr.length인 5까지 1씩 증가하면서 반복한다.
- flag에 false를 대입하고 if 문에서 arr[i] 값과 temp[i] 값이 같은 경우에는 flag에 true를 대입한다.
- 만약 **flag가 참이 아닌 경우** **temp[idx]에 arr[i] 값을 대입하고** **idx 값을 1 증가**시킨다.


<br>
**참고 자료**

---

- [https://www.atlassian.com/ko/incident-management/kpis/sla-vs-slo-vs-sli - SLA, SLO, SLI](https://www.atlassian.com/ko/incident-management/kpis/sla-vs-slo-vs-sli)
- [https://velog.io/@noob3er/스택-버퍼오버플로우Stack-buffer-overflow - 스택 버퍼 오버플로우, 힙 버퍼 오버플로우](https://velog.io/@noob3er/%EC%8A%A4%ED%83%9D-%EB%B2%84%ED%8D%BC%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C%EC%9A%B0Stack-buffer-overflow)
- [https://yechoi.tistory.com/10 - RBP](https://yechoi.tistory.com/10)
- [https://velog.io/@suea724/정보처리기사-실기-3.-데이터-입출력-구현1 - ERD](https://velog.io/@suea724/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-3.-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EA%B5%AC%ED%98%841)
- [https://devinus.tistory.com/24 - ERD](https://devinus.tistory.com/24)