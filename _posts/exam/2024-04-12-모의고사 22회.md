---
categories: [정보처리기사, 모의고사 문제 풀이]
---

Q. 개인이 인터넷상에 남겨놓은 SNS 계정이나 커뮤니티 게시글, 쇼핑몰 후기 댓글 등을 통해 사용자를 추적할 수 있다고 붙여진 용어는?

> 디지털 발자국(Digital Footprint)
> 

- 디지털 발자국은 사람들이 PC나 모바일 기기, 인터넷을 사용하면서 남긴 흔적들을 말한다.
- 디지털 발자국은 데이터베이스에 축적되어 사생활을 드러내는 정보가 되어 이를 기반으로 특정 고객에 맞는 맞춤형 마케팅이 가능하다.

---

Q. 다음은 무선보안과 관련된 내용이다. () 안에 들어갈 올바른 용어를 쓰시오.

> VPN(Virtual Private Network)
> 

()은/는 인터넷과 같은 공중망을 사용하여 사설 네트워크를 구축하게 해주는 기술 혹은 통신망으로 두 개 이상의 물리적 네트워크(또는 장치) 사이의 인터넷을 통해 생성된 가상 네트워크이다. 

- 인터넷과 같은 공중망을 사용하여 사설 네트워크를 구축하게 해주는 기술 혹은 통신망으로 두 개 이상의 물리적 네트워크(또는 장치) 사이의 인터넷을 통해 생성된 가상 네트워크는 VPN이다.

---

Q. 다음이 설명하는 DRS(Disaster Recovery System)의 유형을 쓰시오.

> Warm Site
> 
- 재해복구센터에 주 센터와 동일한 수준의 자원을 보유하는 대신 중요성이 높은 자원만 부분적으로 재해복구 센터에 보유하고 있는 센터
- 데이터 백업 주기가 수 시간~1일
- 재해 발생 시 복구까지의 소요 시간(RTO)은 수일~수주가 소요됨

- DRS 유형은 다음과 같다.
    - Mirror Site
        - 주 센터와 데이터복구센터 모두 운영 상태로 실시간 동시 서비스가 가능한 재해복구센터
        - 재해 발생 시 복구까지의 소요 시간(RTO)은 즉시(이론적으로 0)
    - Hot Site
        - 주 센터와 동일한 수준의 자원을 대기 상태로 원격지에 보유하면서 동기, 비동기 방식의 미러링을 통하여 데이터의 최신 상태를 유지하고 있는 재해복구센터
        - 재해 발생 시 복구까지의 소요 시간(RTO)은 4시간 이내
    - Warm Site
        - Hot Site와 유사하나 재해복구센터에 주 센터와 동일한 수준의 자원을 보유하는 대신 중요성이 높은 자원만 부분적으로 재해복구센터에 보유하고 있는 센터
        - 데이터 백업 주기가 수 시간~1일
        - 재해 발생 시 복구까지의 소요 시간(RTO)은 수일~수주
    - Cold Site
        - 데이터만 원격지에 보관하고, 재해 시 데이터를 근간으로 필요 자원을 조달하여 복구할 수 있는 재해복구센터
        - 재해 발생 시 복구까지의 소요 시간(RTO)은 수주~수개월
        - 구축 비용이 저렴하나 복구 소요 시간이 길고 신뢰성이 낮음

---

Q. 다음 () 안에 들어갈 올바른 용어를 쓰시오.

> 관계 대수, 관계 해석
> 

( ① )은/는 원하는 정보가 무엇인가를 정의하고 원하는 정보를 유도하기 위한 과정을 정의한 절차적 언어이고, ( ② )은/는 원하는 정보가 무엇인지만을 정의하는 비절차적인 언어이다.

- 관계 대수와 관계 해석의 개념은 다음과 같다.
    
    
    | 구분 | 설명 |
    | --- | --- |
    | 관계 대수 | 원하는 정보가 무엇인가를 정의하고 원하는 정보를 유도하기 위한 과정을 정의한 절차적 언어 |
    | 관계 해석 | 원하는 정보가 무엇인지만을 정의하는 비절차적인 언어 |

- **관계대수(Relational Algebra)**
    1. 관계형 데이터베이스에서 원하는 정보와 그 정보를 **검색**하기 위해서 **어떻게 유도하는가를 기술하는 절차적인 언어**
    2. 주어진 **릴레이션 조작**을 위한 **연산의 집합**
    3. 관계대수는 **릴레이션**을 처리하기 위해 **연산자와 연산규칙을 제공**
    4. **피연산자, 연산 결과**가 모두 **릴레이션**
    5. **질의에 대한 해**를 구하기 위해 수행해야 할 **연산의 순서를 명시**
    6. **순수 관계 연산자**와 **일반 집합 연산자으로 구분됨**

- SELECT 이름 FROM 학생 WHERE 학과='교육';
    
    ![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(1).png)
    
    - `()` 테이블, `σ` 조건, `π` 속성(필드)를 가져옴

```
순수 관계 연산자
- select σ 시그마 → 수평단절, 행을 다 가져옴
- project π 파이 → 수직단절, 열을 다 가져옴
- join ▷◁ → 공통 속성을 이용해 두개의 릴레이션 튜플을 연결 → 새로운 릴레이션
- division ÷ → 릴S의 모든 튜플과 관련있는 릴R의 튜플반환
	       R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산

일반 집합 연산자
- UNION 합집합
- INTERSECTION 교집합
- DIFFERENCE 차집합
- CARTESIAN PRODUCT 교차곱
```

- **관계해석(Relational Calculus)**
    1. 관계 데이터 모델의 제안자인 **코드**가 **수학**에 가까운 **기반**을 두고 관계 데이터베이스를 위해 제안하여 탄생하였다.
    2. 관계해석은 관계 데이터의 연산을 표현하는 방법으로, **원하는 정보를 정의**할 때는 **계산 수식을 사용**한다.
    3. 관계해석은 **원하는 정보**가 **무엇**이라는 것**만 정의**하는 **비절차적** 특성을 지님
    4. **튜플 관계해석과 도메인 관계해석**이 있음
    5. 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력면에서 동등하며 **관계대수로 표현한 식**은 **관계해석으로 표현**할 수 있다.
    6. **질의어**로 **표현**

![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(2).png)

- `∨`: 원자식 간 또는(OR)
- `∧`: 원자식 간 그리고(AND)
- `ㄱ`: 원자식에 대해 부정(NOT)
- `∀`: 모든 것에 대하여(**For All**), **모든 가능한** 튜플
- `∃`: 존재한다(There exists), **어떤 튜플 하나라도** 존재

---

Q. 다음은 [학생] 테이블 스키마에 대한 명세이다. ‘이름인덱스’라는 이름의 복합 인덱스를 생성하는 쿼리를 작성하시오. (성명, 성별 순으로 복합 인덱스를 생성해야 한다.)

```sql
CREATE INDEX 이름인덱스 ON 학생(성명, 성별); 
```

[학생]

| 속성명 | 데이터타입 |
| --- | --- |
| 학번 | INTEGER |
| 성명 | VARCHAR(10) |
| 성별 | CHAR(1) |

- CREATE INDEX는 인덱스를 생성하는 명령이다.
- UNIQUE는 생략 가능하고, 인덱스 걸린 컬럼에 중복 값을 허용하지 않는다.
- 복수 컬럼을 인덱스로 걸 수 있다.
- CREATE INDEX 문법은 다음과 같다.
    
    ```sql
    CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2, ...);
    ```
    

---

Q. 시스템 개발 시 위험을 최소화하기 위해 점진적으로 완벽한 시스템으로 개발해 나가는 소프트웨어 생명주기(SDLC) 모델은 무엇인가?

> 나선형 모델(Spiral Model)
> 

- 소프트웨어 생명주기 모델은 다음과 같다.
    - 폭포수 모델(Waterfall Model)
        - 소프트웨어 개발 시 각 단계를 확실히 마무리 지은 후에 다음 단계로 넘어가는 모델
        - 선형 순차적 모형으로 고전적 생명주기 모형이라고도 함
    - 프로토타이핑 모델(Prototyping Model)
        - 고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델
    - 나선형 모델(Spiral Model)
        - 시스템 개발 시 위험을 최소화하기 위해 점진적으로 완벽한 시스템으로 개발해 나가는 모델
        - 계획 및 정의(수립) → 위험 분석 → 개발 및 검증 → 고객 평가의 절차를 가짐
    - 반복적 모델(Iteration Model)
        - 구축대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점증 완성시키는 모델

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 3.50
> 

```c
#include <stdio.h>
void main() {
	int i, j;
	int arr[3][2] = { {1, 2}, {3, 4}, {5, 6} };
	int sum = 0;
	
	for(i=0; i<3; i++) {
		for(j=0; j<2; j++) {
			sum += arr[i][j];
		}
	}
	printf("%.2f", (float)sum/(3*2));
}
```

- for 반복문에서 사용할 변수 i, j를 선언한다.
- 정수형 변수 sum을 선언하고 0으로 초기화한다.
- 값을 저장할 정수형 변수 arr 배열을 3행 2열로 선언하고 1, 2, 3, 4, 5, 6으로 초기화한다.
- 2중 for 반복문에서 a[i][j] 값을 sum 변수에 누적 합을 대입한다.
- for 반복문이 종료되고 (float)sum(3*2) 값을 화면에 출력한다. sum 값은 21인데 (float)가 있으므로 실숫값인 21.0을 정숫값 6으로 나누면 실숫값인 3.5가 된다. %.2f는 소수점 2번째자리까지 출력이므로 3.50이 화면에 출력된다.

---

Q. 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다는 데이터베이스의 특성은 무엇인지 쓰시오.

> 동시 공용(Concurrent Sharing)
> 

- 데이터베이스 특성은 다음과 같다.
    - 실시간 접근성(Real-Time Accessibility)
        - 쿼리에 대하여 실시간 응답이 가능해야 함
    - 계속적인 변화(Continuous Evolution)
        - 새로운 데이터의 삽입(Insert), 삭제(Delete), 갱신(Update)으로 항상 최신의 데이터를 유지함
    - 동시 공용(Concurrent Sharing)
        - 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 함
    - 내용 참조(Content Reference)
        - 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라, 사용자가 요구하는 데이터 내용으로 데이터르 랒음

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> 10
> 

```python
def soojebi(a, b):
	if a < b:
		a, b = b, a
	if a % b == 0:
		return b
	else:
		return soojebi(b, a%b)
	
print(soojebi(30, 20))	
```

- 파이썬 최대공약수 예제이다.
- soojebi 함수는 a와 b를 파라미터로 전달받는다. 만약 a가 b보다 작으면 **a와 b의 값을 서로 바꾼다**.
- 만약 a%b가 0과 같으면 b를 리턴하고 아닐 경우 자기 자신인 soojebi 함수를 재호출하여 계산한다.
- soojebi 함수 호출 시 파라미터는 b와 a%b 값을 전달한다.
    
    
    | a | b | a%b |
    | --- | --- | --- |
    | 30 | 20 | 10 |
    | 20 | 10 | 0 |
- soojebi(30, 20)은 soojebi(20, 30%20)을 리턴하고, soojebi(20, 30%20)은 10을 리턴하므로 print(soojebi(30, 20))은 print(10)이 되어 10을 출력한다.

---

Q. 정규화 단계 중 BCNF의 개념을 간략히 서술하시오.

> BCNF는 모든 결정자가 후보 키가 되도록 하여 결정자 함수 종속성을 제거하는 단계이다.
> 

- 데이터베이스 정규화 단계는 다음과 같다.
    
    
    | 단계 | 조건 |
    | --- | --- |
    | 1정규형(1NF) | 원잣값으로 구성 |
    | 2정규형(2NF) | 부분 함수 종속 제거(완전 함수적 종속 관계) |
    | 3정규형(3NF) | 이행함수 종속 제거 |
    | 보이스-코드 정규형(BCNF) | 결정자 후보 키가 아닌 함수 종속 제거 |
    | 4정규형(4NF) | 다치(다중 값) 종속 제거 |
    | 5정규형(5NF) | 조인 종속 제거 |

---

Q. 다음은 [상품]과 [가격] 테이블이다. [상품]과 [가격] 테이블을 조인하여 [결과] 테이블처럼 나오도록 쿼리를 작성하시오.

```sql
SELECT A.상품코드 AS 상품코드, A.상품명 AS 상품명, B.상품가격 AS 상품가격
FROM 상품 A
[INNER] JOIN 가격 B
ON A.상품코드 = B.상품코드;
```

[상품]

| 상품코드 | 상품명 |
| --- | --- |
| 100 | 딸기 |
| 101 | 망고 |
| 102 | 홍시 |
| 103 | 단감 |
| 106 | 망고스틴 |
| 107 | 포도 |

[결과]

| 상품코드 | 상품가격 |
| --- | --- |
| 100 | 7000 |
| 101 | 10000 |
| 103 | 3000 |
| 106 | 15000 |
| 108 | 2000 |

[결과]

| 상품코드 | 상품명 | 상품가격 |
| --- | --- | --- |
| 100 | 딸기 | 7000 |
| 101 | 망고 | 10000 |
| 103 | 단감 | 3000 |
| 106 | 망고스틴 | 15000 |

- 공통 존재 컬럼의 값이 같은 경우를 추출하는 조인을 내부 조인이라고 한다.
- 내부 조인의 문법은 다음과 같다.
    
    ```sql
    SELECT A.컬럼1, A.컬럼2, ..., B.컬럼1, B.컬럼2, ...
    FROM 테이블1 A
    [INNER] JOIN 테이블2 B
    ON 조인조건
    [WHERE 검색조건];
    ```
    

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 30
> 

```java
public class Soojebi {
	public static void main(String[] args) {
		int a = 10;
		int b = a + 10;
		int c = b * 2;
		if(a + b == 30 && b + c == 60) {
			System.out.printf("%d\n", a + b);
		}
		else {
			System.out.printf("%d\n", b + c); 
		}
	}
}
```

- 논리연산 예제이다.
- a는 10, b는 a의 10과 10을 더하여 20, c에는 b의 20에 2를 곱한 40이 저장된다.
- if 문에서는 a와 b를 더한 값이 30과 같고, b와 c를 더한 값이 60과 같으면 a와 b를 더한 값을 출력하며, 그렇지 않을 경우 b와 c를 더한 값을 출력하는데, a와 b를 더한 값이 30과 같고, b와 c를 더한 값이 60과 같으므로 a와 b를 더한 30이 출력된다.

---

Q. 병행 제어(Concurrency Control) 개념에 대해 서술하시오.

> 병행 제어는 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법이다.
> 

- 병행 제어의 목적은 다음과 같다.
    - 데이터베이스의 공유를 최대화
    - 시스템 활용도를 최대화
    - 데이터베이스의 일관성 유지
    - 사용자에 대한 응답시간을 최소화

- **병행제어 기법**
    - 여러 개의 트랜잭션이 실행될 때 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않고 다른 트랜잭션에 영향을 주지 않으면서 트랜잭션을 제어하는 것을 의미

- 데이터베이스에서 병행제어의 목적  ← 일관성, 무결성 유지
    - 여러 사용자들의 데이터베이스 공동 사용을 최대화(공유 최대화)
    - 사용자의 응답 시간 최소화
    - 데이터베이스 시스템의 활용도 최대화
    - 단위 시간당 트랜잭션 처리 건수 최대화
    - 데이터베이스의 일관성 유지
    
- 병행수행의 문제점
    - 병행제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 갱신 분실, 비완료 의존성, 모순성, 연쇄 복귀 등의 문제점이 발생함
    - 갱신 분실(Lost Update): 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상
        
        ![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(3).png)
        
    - 비완료 의존성(Uncommitted Dependency), 임시 갱신: 하나의 트랜잭션 수행이 실패한 후 회복(Recovery의 결과: 100)되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상, 더티리드(더러운 값을 읽어옴)
        
        ![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(4).png)
        
    - 모순성(Inconsistency), 불일치 분석(Inconsistent Analysis): 두 개의 트랜잭션이 병행수행될 때 원치 않는 자료를 이용함으로써 발생하는 문제임
        - 하나의 트랜잭션이 여러 데이터 갱신 연산을 수행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져옴으로써 데이터의 불일치가 발생하는 것
        
        ![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(5).png)
        
    - 연쇄 복귀(Cascading Rollback):  병행수행되던 트랜잭션들 중 어느 하나에 문제가 생겨 Rollback하는 경우 다른 트랜잭션도 함께 Rollback되는 현상
        
        ![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(6).png)
        
    
- 병행제어 기법의 종류
    - 로킹(Locking)
        - 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock(잠금)을 요청해서 Lock이 허락되어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법
        - 주요 데이터의 액세스를 상호 배타적으로 함
        - 같은 자원을 엑세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
        - 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법
        - 로킹 기법은 **교착 상태(Dead lock)**가 발생할 수 있다는 한계가 있음
        - **교착 상태란, 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태**를 말함
        - 하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 오직 읽기(read)만 하는 경우에는 동시에 접근해도 문제가 없기 때문에 이런 경우에 효율적이지 못함
    - **2단계 로킹 규약**
        - 각 트랜잭션의 **lock과 unlock 요청**을 **2단계로 실시**하는 방식
        - 단계는 확장 단계(Growing phase)와 축소 단계(shrinking phase)로 나뉨
        - 이를 통해 직렬성을 보장하는 대표적인 로킹 규약이지만 여전히 lock 연산으로 인한 교착상태를 예방할 수는 없다는 단점이 있음
        - **확장 단계(Growing phase)**: 새로운 lock 연산만을 수행할 수 있고, unlock 연산은 수행할 수 없는 단계
        - **축소 단계(Shrinking phase)**: unlock 연산을 수행할 수 있고, lock연산은 수행할 수 없는 단계
    - 타임 스탬프 순서(Time Stamp Ordering)
        - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
        - 직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중에서 가장 보편적인 방법임
    - 최적 병행수행(Optimistic Concurrency Control**,** 검증 기법,  확인 기법, 낙관적 기법)
        - 병행수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read Only) 트랜잭션일 경우, 트랜잭션 간의 충돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법
        - 트랜잭션 수행 동안은 어떠한 검사를 하지 않고, 트랜잭션이 종료된 이후에 일괄적으로 검사하는 방식
        - 수행 도중에는 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신하고, 트랜잭션이 종료되고 난 후에 직렬화를 검증하여 검증되면 데이터베이스에 한 번에 반영하는 방식
    - 다중 버전 기법(Multi-version Concurrency Control)
        - 한 데이터에 대해 여러 버전의 값을 유지하며 관리하는 방식
        - 타임 스탬프의 개념을 이용하며, 다중 버전 타임 스탬프 기법이라고도 함
        - 타임 스태프 기법은 트랜잭션 및 데이터들이 이용될 때의 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때 마다의 버전을 부여하여 관리함
        - 여러 버전의 타임스탬프를 비교하여 스케줄상 직렬 가능성이 보장되는 타임스탬프를 선택
        - 충돌이 발생할 경우 연쇄 복귀가 발생할 수 있는 단점이 있음
    - 로킹 단위(Locking Granularity)
        - 로킹 단위는 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미함
        - 데이터베이스, 파일, 레코드, 필드, 테이블 등이 로킹 단위가 될 수 있음
        - 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아짐, 병행 제어 기법 간단해짐
        - 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 수준이 높아짐, 데이터 베이스 공유도 증가
        - 로킹단위를 작게하여 활용도를 최대화해야 함

---

Q. 다음이 설명하는 소프트웨어 테스트 유형은 무엇인지 쓰시오.

> 화이트박스 테스트(White-Box Test)
> 
- 코드 분석과 프로그램 구조에 대한 지식을 바탕으로 문제가 발생할 가능성이 있는 모듈 내부를 테스트하는 방법
- 내부 소스 코드의 동작을 개발자가 추적할 수 있기 때문에 동작의 유효성뿐만 아니라 실행되는 과정을 확인 가능
- 구조 기반 테스트, 코드 기반 테스트, 로직 기반 테스트, 글래스 박스 테스트라고 불림

- 화이트박스 테스트는 각 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트이다.
- 화이트박스 테스트의 유형은 다음과 같다.
    - 구문 커버리지=문장 커버리지(Statement Coverage)
        - 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지
        - 조건문 결과와 관계없이 구문 실행 개수로 계산
    - 결정 커버리지=선택 커버리지(Decision Coverage)=분기 커버리지(Branch Coverage)
        - (각 분기의) 결정 포인트 내의 전체 조건식이 적어도 한 번은 참(T)과 거짓(F)의 결과를 수행하는 테스트 커버리지
        - 구분 커버리지를 포함
    - 조건 커버리지(Condition Coverage)
        - (각 분기의) 결정 포인트 내의 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 테스트 커버리지
        - 구문 커버리지를 포함
    - 조건/결정 커버리지(Condition/Decision Coverage)
        - 전체 조건식뿐만 아니라 개별 조건식도 참 한 번, 거짓 한 번 결과가 되도록 수행하는 테스트 커버리지
    - 변경 조건/결정 커버리지(Modified Condition/Decision Coverage)
        - 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지
    - 다중 조건 커버리지(Multiple Condition Coverage)
        - 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지
    - 기본 경로 커버리지=경로 커버리지(Base Path Coverage)
        - 수행 가능한 모든 경로를 테스트하는 기법
    - 제어 흐름 테스트, 조건 테스트(Control Flow Testing)
        - 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법
    - 데이터 흐름 테스트(Data Flow Testing)
        - 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트하는 기법
    - 루프 테스트(Loop Testing)
        - 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시하는 테스트 기법

---

Q. 다음 중 [정처기]테이블에서 미응시자를 파악하려고 한다. 필기 점수가 NULL이거나 0점인 ‘수험자명’을 출력하는 쿼리를 작성하시오.

```sql
SELECT 수험자명
FROM 정처기
WHERE 필기 IS NULL OR 필기 = **0**;
```

[정처기]

| 수험자명 | 필기 | 실기 |
| --- | --- | --- |
| 엑소 | 0 | NULL |
| BTS | NULL | 100 |
| 세븐틴 | NULL | NULL |
| 비투비 | 80 | 70 |

[결과]

| 수험자명 |
| --- |
| 엑소 |
| BTS |
| 세븐틴 |

- WHERE절 조건에서는 비교, 범위, 집합, 패턴, NULL, 복합조건이 있고, NULL인 값을 찾을 때는 IS NULL 문법을 사용한다.
- IS NULL 문법은 다음과 같다.
    
    ```sql
    컬럼 IS NULL
    ```
    
- 조건1과 조건2 둘 중 하나를 만족하는 데이터 조회하는 복합조건일 경우에는 OR를 이용한다.
    
    ```sql
    조건1 OR 조건2
    ```
    

---

Q. EAI는 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션이다. EAI는 다양한 구성요소가 있는데, 그중 ( ① )은/는 시스템 상호 간 데이터가 전송될 때, 데이터 포맷과 코드를 변환하는 솔루션이고, ( ② )은/는 비동기 메시지를 사용하는 다른 응용 프로그램 사이에서 데이터를 송수신하는 기술이다. () 안에 들어갈 구성요소를 쓰시오.

> 브로커(Broker), 메시지 큐(Message Queue)
> 

- EAI 구성요소는 다음과 같다.
    - EAI 플랫폼(EAI Platform)
        - 이기종 시스템 간 애플리케이션 상호 운영
        - 데이터의 신뢰성 있는 전송을 위한 메시지 큐와 트랜잭션 미들웨어 기능수행
        - 대규모 사용자 환경 지원을 위한 유연성과 확장성 보장
        - 데이터의 안전한 전달 기능, 미들웨어 기능, 실행환경 제공
    - 어댑터(Adapter)
        - 다양한 패키지 애플리케이션 및 기업에서 자체적으로 개발한 애플리케이션을 연결하는 EAI의 핵심 장치로 데이터 입출력 도구
        - 이기종 애플리케이션의 접점 역할, Interface 담당
    - 브로커(Broker)
        - 시스템 상호 간 데이터가 전송될 때, 데이터 포맷과 코드를 변환하는 솔루션
        - 데이터간의 Mapping, 메타데이터 구조, 포맷 자동변환
    - 메시지 큐(Message Queue)
        - 비동기 메시지를 사용하는 다른 응용 프로그램 사이에서 데이터를 송수신하는 기술
    - 비지니스 워크플로우(Business Workflow)
        - 미리 정의된 기업의 비지니스 Workflow에 따라 업무를 처리하는 기능
        - 비즈니스 프로세스 자동화, 프로세스 감시 및 최적화

![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(7).png)

- ESB(Enterprise Service Bus)
    - 애플리케이션 간 표준 기반의 인터페이스를 제공하는 솔루션
    - 메시지 기반으로 느슨한 결합 형태의 표준 인터페이스 통신을 지원하는 미들웨어, 버스형, 외부와 연동
    - 기업 안팎에 있는 모든 시스템 환경을 연동하는 미들 웨어
    - 구성요소 → REST(JSON 구조의 이동)
        - SOAP: 실제 통신 프로토콜
        - UDDI: 도서관
        - WSDL: 설명서, XML(eXtensible Markup Language)

![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(8).png)

---

Q. 최근 무선 단말기의 폭발적인 증가로 다양한 무선 기술들이 발전하고 있다. 다음은 다양한 무선 기술에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 스몰 셀(Small Cell), 애드 혹 네트워크(Ad-hoc Network)
> 

기존의 높은 전송 파워와 넓은 커버리지를 갖는 매크로 셀(Macro Cell)과 달리 낮은 전송 파워와 좁은 커버리지를 가지는 소형 기지국으로 안테나당 10W급 이하의 소출력 기지국 장비나 피코 셀, 펨토 셀 등을 통칭하는 용어는 ( ① )(이)라고 한다. 또한 ( ② )은/는 고정된 기반 망의 도움 없이 이동 노드 간에 자율적으로 구성되는 망으로서, 네트워크에 자율성과 융통성을 부여한 네트워크로 Peer-to-Peer 통신, 다중 홉, 이동 노드 간 동적 네트워크를 구성할 수 있는 특징이 있다.

- 무선 관련 기술은 다음과 같다.
    
    
    | 기술 | 설명 |
    | --- | --- |
    | 스몰 셀(Small Cell) | 기존의 높은 전송 파워와 넓은 커버리지를 갖는 매크로 셀(Macro Cell)과 달리 낮은 전송 파워와 좁은 커버리지를 갖는 소형 기지국으로 안테나당 10W급 이하의 소출력 기지국 장비나 피코 셀, 펨토 셀 등을 통칭하는 용어 |
    | 애드 혹 네트워크(Ad-hoc Network) | 고정된 기반 망의 도움 없이 이동 노드 간에 자율적으로 구성되는 망으로서, 네트워크에 자율성과 융통성을 부여한 네트워크로 Peer-to-Peer 통신, 다중 홉, 이동 노드 간 동적 네트워크를 구성할 수 있는 네트워크 |

---

Q. 조인의 대상 범위가 넓을 경우 발생하는 임의 접근(Random Access)을 줄이기 위한 경우나 연결고리에 마땅한 인덱스가 존재하지 않을 경우 해결하기 위한 조인 방식으로 양쪽 테이블의 정렬한 결과를 차례로 검색하면서 연결고리 형태로 합병하는 방식의 물리적 조인은 무엇인가?

> 정렬 병합 조인(Sort-Merge Join)
> 

- 물리적 조인에는 중첩 반복 조인, 정렬 합병 조인, 해시 조인이 있다.
    - 조인의 대상 범위가 넓을 경우 발생하는 임의의 접근(Random Access)을 줄이기 위한 경우나 연결고리에 마땅한 인덱스가 존재하지 않은 경우 해결하기 위한 조인 방식으로 양쪽 테이블의 정렬한 결과를 차례로 검색하면서 연결고리 형태로 합병하는 방식의 물리적 조인은 합병 조인이다.

---

Q. 다음이 설명하는 고가용성 유형은 무엇인가?

> Concurrent Access(동시적 접근) 방식
> 

시스템 전체가 Active 한 상태로 동작하다가 한 시스템 장애 시 다른 시스템으로 Fail Over 하지 않고, 여러 개의 시스템이 동시에 업무를 나누어 병렬 처리하는 방식

- 고가용성 유형은 다음과 같다.
    - Hot Standby(상시 대기 방식)
        - **가동시스템과 백업시스템**으로 구성
        - 평상시에는 **대기 상태를 유지하다가 장애 시 전환**
        
        ![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(9).png)
        
    - Mutual Take-Over(상호 인수)
        - 2개의 시스템이 **각각의 고유한 가동 업무 서비스 수행**하다가 한 서버 장애 발생 시 상대 시스템의 자원을 페일 오버하여 동시에 2개의 업무를 수행하는 방식
        
        ![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(10).png)
        
    - Concurrent Access(동시적 접근)
        - 여러 개의 시스템이 동시에 업무를 나누어 병렬처리하는 방식
        - HA에 참여하는 시스템 전체가 Active한 상태로 업무를 수행
        - 한 시스템에 장애가 발생하여도 다른 시스템으로 Fail Over하지 않고 가용성을 보장
        
        ![이미지](/assets/img/exam/22/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_22%ED%9A%8C(11).png)
        

---

Q. 일방향 암호 종류에는 키를 사용하는 메시지 인증 코드로 메시지의 무결성과 송신자의 인증을 보장하는 ( ① )와/과 키를 사용하지 않는 변경 감지 코드로 메시지의 무결성을 보장하는 ( ② )이/가 있다. () 안에 들어갈 용어를 쓰시오.

> MAC(Message Authentication Code), MDC(Modification Detection Code)
> 

- 일방향 암호인 MAC과 MDC의 특징은 다음과 같다.
    
    
    | 항목 | 특징 |
    | --- | --- |
    | MAC(Message Authentication Code) | 키를 사용하는 메시지 인증 코드로 메시지의 무결성과 송신자의 인증을 보장 |
    | MDC(Modification Detection Code) | 키를 사용하지 않는 변경 감지 코드로 메시지의 무결성을 보장 |


<br>
**참고 자료**

---

- [https://m.blog.naver.com/igenius21c/222028640997 - EAI와 ESB의 비교](https://m.blog.naver.com/igenius21c/222028640997)
- [https://velog.io/@do_ng_iill/EAIEnterprise-Application-Integration-정리 -  EAI 구성요소(Message Bus 방식)](https://velog.io/@do_ng_iill/EAIEnterprise-Application-Integration-%EC%A0%95%EB%A6%AC)