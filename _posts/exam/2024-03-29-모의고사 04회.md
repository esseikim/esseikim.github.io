---
categories: [Certificate, "[정보처리기사] 모의고사(01~35회)"]
---

Q. ()은/는 데이터 웨어하우스나 데이터마트 같은 시스템과 상호 연관되는 정보 시스템이다. 데이터 웨어하우스가 데이터를 저장하고 관리한다면 ()은/는 데이터 웨어하우스의 데이터를 전략적인 정보로 변환시켜서 의사결정을 지원하는 역할을 한다. () 안에 공통적으로 들어갈 가장 적합한 용어를 쓰시오.

> 온라인 분석 처리(Online Analytical Processing; OLAP)
> 

- 데이터 웨어하우스의 데이터를 전략적인 정보로 변환시켜서 의사결정을 지원하는 역할을 하는 시스템은 OLAP이다.

---

Q. 인터넷과 같은 분산 환경에서 리소스에 대한 정보와 자원 사이의 관계-의미 정보를 기계(컴퓨터)가 처리할 수 있는 ( ② ) 형태로 표현하고, 이를 자동화된 기계(컴퓨터)가 처리하도록 하는 지능형 웹은 ( ➀ )이다. ( ② )은/는 실세계에 존재하는 개념과 개념들의 속성, 그리고 개념 간의 관계 정보를 컴퓨터가 이해할 수 있도록 서술해 놓은 개념화 명세서이다. () 안에 공통적으로 들어갈 가장 적합한 용어를 쓰시오.

> 시멘틱 웹(Semantic Web), 온톨로지(Ontology)
> 

- 시멘틱 웹(Semantic Web)과 온톨로지(Ontology)는 다음과 같다.
    
    
    | 기술 | 설명 |
    | --- | --- |
    | 시맨틱 웹(Semantic Web) | 인터넷과 같은 분산 환경에서 리소스에 대한 정보와 자원 사이의 관계-의미 정보를 기계(컴퓨터)가 처리할 수 있는 온톨로지 형태로 표현하고, 이를 자동화된 기계(컴퓨터)가 처리하도록 하는 지능형 웹 |
    | 온톨로지(Ontology) | 실세계에 존재하는 모든 개념과 개념들의 속성, 그리고 개념 간의 관계 정보를 컴퓨터가 이해할 수 있도록 서술해 놓은 개념화 명세서 |

---

Q. 선점형 스케줄링 알고리즘 유형 중 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU 시간 할당량을 부여하는 기법으로 FCFS(FIFO)와 라운드 로빈 스케줄링 기법을 혼합한 알고리즘을 무엇이라고 하는가?

> 다단계 피드백 큐(MLFQ; Multi Level Feedback Queue)
> 

- 다단계 피드백 큐는 FCFS(FIFO)와 라운드 로빈 스케줄링 기법을 혼합한 것으로, 새로운 프로세스는 높은 순위, 프로세스의 실행시간이 길어질수록 점점 낮은 우선순위 큐로 이동하고 마지막 단계는 라운드 로빈 방식을 적용한 알고리즘이다.

---

Q. 다음이 설명하는 자료 사전의 기호를 쓰시오.

> `=`
> 
- 자료의 정의로서 ‘~으로 구성되어(is Composed of) 있다.’는 것을 나타냄
- 정의는 주석을 사용하여 의미를 기술하며, 자료흐름과 자료 저장소에 대한 구성 내역을 설명하고, 자료 원소에 대하여 값이나 단위를 나타냄

- 자료 사전 기호는 다음과 같다.
    - `=`
        - 자료의 정의로서 ‘~으로 구성되어(is Composed of) 있다.’는 것을 나타냄
        - 정의는 주석을 사용하여 의미를 기술하며, 자료 흐름과 자료저장소에 대한 구성 내역을 설명하고, 자료 원소에 대하여 값이나 단위를 나타냄
    - `+`
        - 자료의 연결(and, along with)을 나타냄
    - `()`
        - 자료 생략 가능함을 나타냄
    - `{}`
        - 자료의 반복을 나타냄
        - 반복 횟수를 기록하는데 `{}`에서 좌측에는 최소 반복 횟수를 기록하고, 우측에는 최대 반복 횟수를 기록
        - 반복 횟수를 기록하지 않을 때는 디폴트(Default)로 최소는 0, 최대는 무한대를 나타냄
    - `[]`
        - 자료의 선택을 나타냄
    - `**`
        - 자료의 설명을 나타냄
        - 주석(Comment)

---

Q. SOOJEBI_SYS에게 STUDENT 테이블에 대한 모든 권한을 부여하고 다른 사람에게도 권한을 부여할 수 있는 권한을 부여하는 DCL을 작성하시오.

```sql
GRANT ALL ON STUDENT TO SOOJEBI_SYS WITH GRANT OPTION;
```

- 데이터베이스 관리자(DBA; Database Administor)가 사용자에게 데이터베이스에 대한 권한을 부여하는 명령어이다. **[그온투]**
    
    ```sql
    GRANT 권한 ON 테이블 TO 사용자 [WITH 권한 옵션];
    ```
    
    - 관리자가 사용자에게 테이블 권한을 부여
    - WITH GRANT OPTION은 사용자가 권한을 받고 난 후 다른 사람들과 권한을 나누어 가질 수 있는 옵션

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> 25
> 

```python
i=0
sum=0
while i<10:
	i=i+1
	if i%2 == 0:
		continue
	sum = sum + i

print(sum)
```

- while 반복문은 i가 10보다 작을 때까지 반복한다.
- i는 0이기 때문에 i=i+1에서 i 값이 1 증가되어 1이 된다.
- if 문에서 i%2가 0이면 continue가 실행된다. i가 1이면 2로 나눈 나머지가 1이므로 if문을 실행이 되지 않는다. sum=sum+i;에서는 i는 1, sum=0이 되므로 sum은 1이 된다. 이후 while문에서 다음 반복을 수행한다.

| i | i+1 | i%2 | sum | continue |
| --- | --- | --- | --- | --- |
| 0 | 1 | 1 | 0 | x |
| 1 | 2 | 0 | 1 | 실행 |
| 2 | 3 | 1 | 4 | x |
| 3 | 4 | 0 |  | 실행 |
| 4 | 5 | 1 | 9 | x |
| 5 | 6 | 0 |  | 실행 |
| 6 | 7 | 1 | 16 | x |
| 7 | 8 | 0 |  | 실행 |
| 8 | 9 | 1 | 25 | x |
| 9 | 10 | 0 |  | 실행 |

---

Q. 다음은 소프트웨어 모듈에 대한 설명이다. 어떤 용어에 대한 설명인지 쓰시오.

> 결합도(Coupling)
> 
- 모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성이다.
- 소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도이다.

- 결합도는 모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성을 의미한다. 결합도가 낮을수록 품질이 좋아진다.
- 결합도의 유형은 다음과 같다.**[내공외제스자]**
    - 내용 결합도(Content Coupling)
        - 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도
    - 공통 결합도(Common Coupling)
        - 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도
    - 외부 결합도(External Coupling)
        - 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 경우의 결합도
    - 제어 결합도(Control Coupling)
        - 단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우의 결합도
    - 스탬프 결합도(Stamp Coupling)
        - 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도
    - 자료 결합도(Data Coupling)
        - 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호작용이 일어나는 경우의 결합도
    
    ![스크린샷 2024-03-29 오후 7.10.54.png](/assets/img/exam/04/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_04%ED%9A%8C(0).png)
    

---

Q. 병행 제어 기법 중 트랜잭션이 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법은 무엇인가?

> 낙관적 검증(Optimistic Validation) 기법
> 

- 병행 제어 기법은 다음과 같다. **[로낙타다]**
    - 로킹(Locking)
        - 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
        - 로킹의 특징은 다음과 같다.
            - 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
            - 로킹 단위가 작아지면 데이터베이스 공유도가 증가
            - 로킹 단위가 작아지면 로킹 오버헤드가 증가
            - 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
    - 낙관적 검증(Optimistic Validation)
        - 트랜잭션이 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법
    - 타임 스탬프 순서(Time Stamp Ordering)
        - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을수행하는 기법
    - 다중버전 동시성 제어(MVCC; Multi Version Concurrency Control)
        - 트랜잭션의 타임 스탬프와 접근하려는 데이터의 타임 스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법

---

Q. 다음 중 [직원] 테이블에서 부서별 급여의 합계를 구하는 쿼리를 작성하시오.

```sql
SELECT 부서, SUM(급여) AS 급여합계
FROM 직원
GROUP BY 부서;
```

- GROUP BY절은 속성값을 그룹으로 분류하고자 할 때 사용한다.
- GROUP BY절의 속성값에 해당하는 값들끼리 그룹을 형성하고, SUM(급여)를 통해서 그룹별 합계를 구할 수 있다.

---

Q. 2001년 미국 표준 기술 연구소(NIST)에서 발표한 블록 암호화 알고리즘으로 블록 크기는 128비트이며, 키 길이에 따라 128비트, 192비트, 256비트로 나눠지고, 라운드 수는 10, 12, 14라운드로 분류되며, 한 라운드는 SubBytes, ShiftRows, MixColumns, AddRoundKey의 4가지 계층으로 구성되는 대칭 키 암호화 알고리즘은 무엇인가? 

> AES(Advanced Encryption Standard)
> 

- 대칭 키 암호화 알고리즘은 다음과 같다.
    - DES(Data Encryption Standard)
        - 1975년 미국의 연방 표준국(NIST)에서 발표한 대칭 키 기반의 블록 암호화 알고리즘
        - 블록 크기는 64bit, 키 길이는 56bit인 페이스텔(Feistel) 구조
        - DES를 3번 적용하여 보안을 더욱 강화한 3 DES(Triple DES)도 활용됨
    - SEED
        - 1999년 국내 한국인터넷진흥원(KISA)이 개발한 블록 암호화 알고리즘
        - 128bit 비밀키로부터 생성된 16개의 64bit 라운드 키를 사용하여 총 16회의 라운드를 거쳐 128bit의 평문 블록을 128bit 암호문 블록으로 암호화하여 출력 하는 방식
        - 블록 크기는 128bit이며, 키 길이에 따라 128bit, 256bit로 분류
    - AES(Advanced Encryption Standard)
        - 2001년 미국 표준 기술 연구소(NIST)에서 발표한 블록 암호화 알고리즘
        - DES의 개인 키에 대한 전사적 공격이 가능해지고, 3 DES의  성능문제를 극복하기 위해 개발
        - 블록 크기는 128bit이며 키 길이에 따라 128bit, 192bit, 256bit로 분류
        - AES의 라운드 수는 10, 12, 14 라운드로 분류되며, 한 라운드는 SubBytes, ShiftRows, MixColumns, AddRoundKey의 4가지 계층으로 구성
    - ARIA(Academy, Research Institute, Agency)
        - 2004년 국가정보원과 산학연구협회가 개발한 블록 암호화 알고리즘
        - ARIA는 학계(Academy), 연구기관(Research Institute), 정부(Agency)의 영문 앞글자로 구성
        - 블록 크기는 128bit이며, 키 길이에 따라 128bit, 192bit, 256bit로 분류
        - ARIA는 경량 환경 및 하드웨어에서의 효율성 향상을 위해 개발되었으며, ARIA가 사용하는 대부분의 연산은 XOR과 같은 단순한 바이트 단위 연산으로 구성
    - IDEA(International Data Encryption Algorithm)
        - DES를 대체하기 위해 스위스 연방 기술 기관에서 개발한 블록 암호화 알고리즘
        - 128bit의 키를 사용하여 64bit의 평문을 8라운드에 거쳐 64bit의 암호문을 만듦
    - LFSR(Linear Feedback Shift register)
        - 시프트 레지스터의 일종으로, 레지스터에 입력되는 값이 이전 상태 값들의 선형 함수로 계산되는 구조로 되어 있는 스트림 암호화 알고리즘
        - LFSR에 사용되는 선형 함수는 주로 배타적 논리합(XOR)이고, LFSR의 초기 비트 값은 시드(Seed)라고 함

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 33
> 

```java
public class Soojebi {
	static int func(int n) {
		return n*9;
	}
	static int func(int a, int b) {
		return a*b;
	}
	
	public static void main(String[] args) {
		System.out.printf("%x", func(5)+func(2, 3));
	}
}

```

- func는 파라미터가 1개일 경우에는 9를 곱해서 리턴한다.
- func는 파라미터가 2개일 경우에는 두 개를 서로 곱한 값을 리턴한다.
- System.out.printf는 메서드에서 func(5)와 func(2, 3)을 더한 값을 16진수로 출력한다.
- func(5)는 45이고, func(2, 3)은 6이므로 51이 된다. 51을 16진수로 변환하여 33이 화면에 출력된다.

---

Q. OSI 7계층에서 송수신 프로세스 간의 연결 및 신뢰성 있는 통신을 보장하며, 데이터 분할, 재조립, 흐름 제어, 오류 제어, 혼잡 제어 등의 기능을 수행하는 계층은 무엇인가?

> 전송 계층(Transport Layer)
> 

- OSI 7계층의 특징은 다음과 같다. **[아파서 티내다, 피나다][물데네전세표응]**
    - 응용 계층(Application Layer)
        - 사용자와 네트워크 간 응용서비스 연결, 데이터 생성
        - 프로토콜: HTTP, FTP
        - 전송단위: 데이터(Data)
        - 장비: 호스트(PC 등)
    - 표현 계층(Presentation Layer)
        - 데이터 형식 결정, 부호 교환, 암∙복호화
        - 프로토콜: JPEG, MPEG
        - 전송단위: 데이터(Data)
        - 장비: 호스트(PC 등)
    - 세션 계층(Session Layer)
        - 송수신 간의 논리적인 연결
        - 연결 접속, 동기 제어
        - 프로토콜: RPC, NetBIOS
        - 전송단위: 데이터(Data)
        - 장비: 호스트(PC 등)
    - 전송 계층(Transport Layer)
        - 송수신 프로세스 간의 연결
        - 신뢰성 있는 통신 보장
        - 데이터 분할, 재조립, 흐름 제어, 오류 제어, 혼잡 제어
        - 프로토콜: TCP, UDP
        - 전송단위: 세그먼트(Segment)
        - 장비: L4 스위치
    - 네트워크 계층(Network Layer)
        - 단말기 간 데이터 전송을 위한 최적화된 경로 제공
        - 프로토콜: IP, ICMP
        - 전송단위: 패킷(Packet)
        - 장비: 라우터
    - 데이터링크 계층(Data Link Layer)
        - 인접 시스템 간 데이터 전송, 전송 오류 제어
        - 동기화, 오류 제어, 흐름 제어, 회선 제어
        - 프로토콜: HDLC, PPP
        - 전송단위: 프레임(Frame)
        - 장비: 브리지, 스위치
    - 물리 계층(Physical Layer)
        - 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
        - 프로토콜: RS-232C
        - 전송단위: 비트(Bit)
        - 장비: 허브, 리피터

---

Q. 다음과 같이 위쪽 릴레이션을 아래쪽 릴레이션으로 정규화를 하였을 때 어떤 정규화 작업을 한 것인가? 

> 1차 정규형(1NF)
> 

| 국가 | 도시 |
| --- | --- |
| 대한민국 | 서울, 부산 |
| 미국 | 워싱턴, 뉴욕 |
| 중국 | 베이징 |

| 국가 | 도시 |
| --- | --- |
| 대한민국 | 서울 |
| 대한민국 | 부산 |
| 미국 | 워싱턴 |
| 미국 | 뉴욕 |
| 중국 | 베이징 |

- 도메인은 하나의 값이어야 1정규형을 만족하는데, {서울, 부산}과 같이 한 도메인에 여러 개의 값이 있는 경우 1정규형을 만족하지 않는다.
- {서울}. {부산}과 같이 한 도메인에 한 개의 값이 있는 경우 1정규형을 만족한다.
- 데이터베이스 정규화 단계는 다음과 같다.

| 단계 | 조건 |
| --- | --- |
| 1차 정규형(1NF) | 원자값으로 구성 |
| 2차 정규형(2NF) | 부분 함수 종속 제거(완전 함수적 종속 관계) |
| 3차 정규형(3NF) | 이행 함수 종속 제거 |
| 보이스-코드 정규형(BCNF) | 결정자 함수이면서 후보 키가 아닌 것 제거 |
| 4차 정규형(4NF) | 다치(다중 값) 종속성 제거 |
| 5차 정규형(5NF) | 조인 종속성 제거 |

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> name : 정보처리기사price : 10,000원
> 

```java
class Book {
	String name = "수험서"
	void getPrice(String name) {
		System.out.print("name : " + name );
	}
}
class Price extends Book {
	String price = "10,000원";
	void getPrice(String name) {
		super.getPrice(name);
		System.out.print("price : " + price);
	}
}
class Soojebi {
	public static void main(String[] args){
		Book b = new Price();
		b.getPrice("정보처리기사");
	}
}
```

- Book 클래스와 price 클래스는 상속 관계이다.
- Book 클래스는 멤버 변수로 name을 가지며 멤버 메서드로 getPrice가 있다.
- Price 클래스는 멤버 변수로 price를 가지며 멤버 메서드로 getPrice가 있다.
- Book 클래스의 getPrice와 Price 클래스의 getPrice는 파라미터와 리턴 타입이 동일한 형태로 오버라이드 되어있다.
- main 메서드에서 객체를 생성하고 Price 클래스의 getPrice를 호출하여 화면에 ‘price : 10,000원’을 출력한다.

---

Q. 다음은 [학생] 테이블이다. 다음 쿼리를 수행한 후에 레코드의 개수를 구하시오.

> 6
> 

[학생]

| 학번 | 이름 | 학년 |
| --- | --- | --- |
| 200101 | 블랙핑크 | 1 |
| 200102 | 마마무 | 3 |
| 200103 | 에이핑크 | 2 |
| 200104 | 아이들 | 3 |
| 200105 | 트와이스 | 4 |
| 200106 | 아이즈원 | 3 |
| 200107 | 오마이걸 | 2 |
| 200108 | 러블리즈 | 3 |
| 200109 | ITZY | 2 |

[쿼리]

```sql
SELECT 학번 FROM 학생 WHERE 학년 >= '3'
UNION ALL
SELECT 학번 FROM 학생 WHERE 학년 >= '4'
```

- 집합 연산자는 테이블을 집합 개념으로 보고, 두 테이블 연산에 집합 연산자를 사용하는 방식이다.
- 집합 연산자는 여러 질의 결과를 연결하여 하나로 결합하는 방식을 사용한다.(집합 연산자는 2개 이상의 질의 결과를 하나의 결과로 만들어 준다.)
- 집합 연산자
    - UNION: 중복 행이 제거된 쿼리 결과를 반환하는 집합 연산자
        
        ![스크린샷 2024-03-29 오후 7.10.54.png](/assets/img/exam/04/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_04%ED%9A%8C(1).png)
        
    - UNION ALL: 중복 행이 제거되지 않은 쿼리 결과를 반환하는 집합 연산자
        
        ![스크린샷 2024-03-29 오후 7.10.54.png](/assets/img/exam/04/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_04%ED%9A%8C(2).png)
        
    - INTERSECT: 두 쿼리 결과에 공통적으로 존재하는 결과를 반환하는 집합 연산자
        
        ![스크린샷 2024-03-29 오후 7.10.54.png](/assets/img/exam/04/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_04%ED%9A%8C(3).png)
        
    - MINUS: 첫 쿼리에 있고, 두 번째 쿼리에는 없는 결과를 반환하는 집합 연산자
        
        ![스크린샷 2024-03-29 오후 7.10.54.png](/assets/img/exam/04/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_04%ED%9A%8C(4).png)
        

- SELECT 학번 FROM 학생 WHERE 학년 >= ‘3’의 결과는 다음과 같다.
    
    
    | 학번 |
    | --- |
    | 200102 |
    | 200104 |
    | 200105 |
    | 200106 |
    | 200108 |

- SELECT 학번 FROM 학생 WHERE 학년 >= ‘4’의 결과는 다음과 같다.
    
    
    | 학번 |
    | --- |
    | 200105 |

- 두 테이블을 UNION ALL 하게 되면 다음과 같다.
    
    
    | 학번 |
    | --- |
    | 200102 |
    | 200104 |
    | 200105 |
    | 200106 |
    | 200108 |
    | 200105 |

---

Q. 일정관리 모델 종류 중에서 ( ① )은/는 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 기법으로 모든 자원 제약사항을 배제한 상태로 프로젝트의 시작과 끝을 나타내는 노드(Node)와 노드 간을 연결을 통해 공정을 계산하기 위한 액티비티(Activity) 표기법이고, ( ② )은/는 일의 순서를 계획적으로 정리하기 위한 수렴 기법으로 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법이다. () 안에 들어갈 올바른 용어를 쓰시오.

> 주 공정법(CPM; Critical Path Method), PERT(Program Evaluation and Review Technique)
> 

- 일정관리 모델의 종류는 다음과 같다.
    - 주 공정법(CPM; Critical Path Method)
        - 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 기법
        - 모든 자원 제약사항을 배제한 상태로 프로젝트의 시작과 끝을 나타내는 노드(Node)와 노드 간을 연결을 통해 공정을 계산하기 위한 액티비티(Activitiy) 표기법
    - PERT(Program Evaluation and Review Technique)
        - 일의 순서를 계획적으로 정리하기 위한 수렴 기법으로 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법
    - 중요 연쇄 프로젝트 관리(CCPM; Critical Chain Project Management)
        - 주 공정 연쇄법으로 자원제약사항을 고려하여 일정을 작성하는 기법

---

Q. 링크 상태(Link State) 라우팅 기반 메트릭(Metric) 정보를 한 지역(Area) 내 모든 라우터에 변경이 발생했을 때만 보내고(Flooding), 라우팅 테이블을 구성/계산하는데 다익스트라(Dijkstra) 알고리즘 사용하는 내부 라우팅 프로토콜은 무엇인가?

> OSPF(Open Shortest Path First)
> 

- 대표적인 라우팅 프로토콜인 RIP와 OSPF, BGP의 특징은 다음과 같다.
    - RIP(Routing Information Protocol)
        - AS(Autonomous System, 자치 시스템, 자율 시스템) 내에서 사용하는 거리 벡터 알고리즘에 기초하여 개발된 내부 라우팅 프로토콜
        - 거리 벡터 라우팅 기반 메트릭(Metric) 정보를 인접 라우터와 주기적으로 교환하여 라우팅 테이블을 갱신하고 라우팅 테이블을 구성/계산하는 데 Bellman-Ford 알고리즘을 사용하는 내부 라우팅 프로토콜
        - 최대 홉 수(Hop Count)를 15개로 제한
        - 사용 포트로는 UDP를 사용(UDP 포트 번호 520 사용)
        - 30초마다 전체 라우팅 정보를 브로드캐스팅
    - OSPF(Open Shortest Path First)
        - 규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선하기 위해 자신을 기준으로 링크 상태 알고리즘을 적용하여 최단 경로를 찾는 라우팅 프로토콜
        - 링크 상태 라우팅 기반 메트릭(Metric) 정보를 한 지역(Area) 내 모든 라우터에 변경이 발생했을 때만 보내(Flooding)고 라우팅 테이블을 구성/계산하는 데 다익스트라(Dijkstra) 알고리즘을 사용하는 내부 라우팅 프로토콜
        - 최소 지연, 최대 처리량 등 관리자가 라우팅 메트릭 지정
        - AS를 지역(Area)으로 나누어 라우팅을 효과적으로 관리 가능
        - 홉 카운트에 제한이 없음
    - BGP(Border Gateway Protocol)
        - 자치 시스템(AS) 상호 간(Inter-AS 또는 Inter-Domain)에 경로 정보를 교환하기 위한 라우팅 프로토콜
        - 변경 발생 시 대상까지의 가장 짧은 경로를 경로 벡터(Path Vector) 알고리즘을 통해 선정하고, TCP 연결(port 179)을 통해 자치 시스템(AS)으로 라우팅 정보를 신뢰성 있게 전달
        - ISP(인터넷 서비스 제공자, Internet Service Provider는 인터넷에 접속하는 수단을 제공하는 주체) 사업자들 상호 간에 주로 사용되는 라우팅 프로토콜
        - 순환을 피할 수 있도록 목적지까지 가는 경로 정보를 제공
        - 라우팅 비용(CPU 부하)이 크고, 라우팅 테이블의 크기가 커서 메모리 사용량이 많음

---

Q. 다음은 트랜잭션 연산에 대한 설명이다. () 안에 들어갈 명령어를 쓰시오.

> 커밋(Commit), 롤백(Rollback)
> 
- ( ① ): 하나의 트랜잭션이 성공적으로 끝나고, 데이터베이스가 일관성 있는 상태에 있거나 하나의 트랜잭션이 끝났을 때 사용하는 연산
- ( ② ): 하나의 트랜잭션이 비정상적으로 종료되어 트랜잭션의 원자성이 깨질 경우 처음부터 다시 시작하거나, 부분적으로 연산을 취소하는 연산

- 트랜잭션 연산에는 Commit과 Rollback이 있고, 이 명령어들에 의해 원자성을 보장받는다.
    
    
    | 연산 | 설명 |
    | --- | --- |
    | 커밋(Commit) | 하나의 트랜잭션이 성공적으로 끝나고, 데이터베이스가 일관성 있는 상태에 있거나 하나의 트랜잭션이 끝났을 때 사용하는 연산 |
    | 롤백(Rollback) | 하나의 트랜잭션이 비정상적으로 종료되어 트랜잭션 원자성이 깨질 경우 처음부터 다시 시작하거나, 부분적으로 연산을 취소하는 연산 |

---

Q. 다음은 입력 데이터 검증 및 표현 취약점에 대한 설명이다. () 안에 들어갈 공격 기법을 쓰시오.

> XSS(Cross Site Scripting), SQL 삽입(Injection)
> 
- ( ① )은/는 검증되지 않은 외부 입력 데이터가 포함된 웹 페이지가 전송되는 경우, 사용자가 해당 웹 페이지를 열람함으로써 웹 페이지에 포함된 부적절한 스크립트가 실행되는 공격 기법이고, ( ② )은/는 응용 프로그램의 보안 취약점을 이용해서 악의적인 SQL 구문을 삽입, 실행시켜서 데이터베이스(DB)의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격 기법이다.

- 입력 데이터 검증 및 표현 **취약점**에 대한 설명은 다음과 같다.
    - XSS(Cross Site Scripting)
        - 검증되지 않은 외부 입력 데이터가 포함된 웹 페이지가 전송되는 경우, 사용자가 해당 웹 페이지를 열람함으로써 웹 페이지에 포함된 부적절한 스크립트가 실행되는 공격
        - 대책
            - 특수문자 등록을 방지하기 위해 특수 문자 필터링
            - HTML 태그 사용 금지(특히, < 문자 사용 시 &lt로 변환처리)
            - 자바스크립트로 시작하는 문자열은 모두 문자열 변환처리
    - 사이트 간 요청 위조(CSRF; Cross Site Request Forgery)
        - 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격
        - 대책
            - 입력화면 폼을 작성 시 GET 방식보다 POST 방식 사용
            - 입력 폼과 입력처리 프로그램에서 세션별 CSRF 토큰을 사용하여 검검
            - 중요기능의 경우 재인증을 통해 안전하게 실제 요청 여부를 확인하도록 구현
    - SQL 삽입(Injection)
        - 응용 프로그램의 보안 취약점을 이용해서 악의적인 SQL 구문을 삽입, 실행시켜서 데이터베이스(DB)의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격
        - 대책
            - 바인딩 매개변수 방식 적용하여 사전에 변수 타입을 명시적으로 지정
            - 사용자로부터 입력될 수 있는 모든 값을 체크하여 필터링
            - Servlet Filter 기능 적용(Java에서만 적용)

---

Q. 다음은 C언어 코드이다. 실행 결과를 쓰시오.

```c
#include <stdio.h>
int Soojebi(int num) {
	int i;
	for(i=2; i<num; i++) {
		if(num % i == 0)
			return 0;
	}
	return 1;
}

void main() {
	int num=10, cnt=0; i;
	for(i=2; i<num; i++)
		cnt += Soojebi(i);
	printf("%d\n", cnt);
}
```

- Soojebi 함수는 파라미터로 num을 전달한다.
- 정수형 변수 i를 선언한다.
- for 반복문은 2부터 num보다 작을 때까지 i 값이 1씩 증가한다. 만약 num이 i로 나눈 나머지가 0이면 0을 리턴한다.
- for 반복문이 종료되면 1을 리턴한다.
- main 함수에서 정수형 변수 num을 10으로 초기화, cnt는 0으로 초기화한다.
- for 반복문을 위해 정수형 변수 i를 선언한다.
- for 반복문은 i 값을 2로 초기화하고 num보다 작을 때까지 i 값을 1씩 증가시킨다. Soojebi 함수를 호출한 결과를 cnt에 더한 값을 cnt에 대입한다.
- cnt를 화면에 출력한다.

| i | cnt | Soojebi(i) |
| --- | --- | --- |
| 2 | 1 | Soojebi(2) = 1 |
| 3 | 2 | Soojebi(3) = 1 |
| 4 | 2 | Soojebi(4) = 0 |
| 5 | 3 | Soojebi(5) = 1 |
| 6 | 3 | Soojebi(6) = 0 |
| 7 | 4 | Soojebi(7) = 1 |
| 8 | 4 | Soojebi(8) = 0 |
| 9 | 4 | Soojebi(9) = 1 |