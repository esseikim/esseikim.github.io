---
categories: [정보처리기사, 모의고사 문제 풀이]
---

Q. 다음은 보안 관련 용어에 대한 설명이다. () 안에 공통적으로 들어갈 용어는 무엇인가?

> 제로데이 공격(Zero-Day Attack)
> 

()은/는 보안 취약점이 발견되어 널리 공표되기 전에 해당 취약점을 악용하여 이루어지는 보안 공격이다. 공격의 신속성을 의미하는 것으로, 일반적으로 컴퓨터에서 취약점이 발견되면 제작자나 개발자가 취약점을 보완하는 패치를 배포하고 사용자가 이를 다운받아 대처하지만, ()은/는 대응책이 공표되기도 전에 공격이 이루어지기 때문에 대처 방법이 없다.

---

Q. 링크의 설정과 유지 및 종료를 담당하며 네트워크 계층에 데이터를 전달하고, 물리 계층에서 발생할 수 있는 오류를 탐지하고 수정하는 기능을 제공하는 데이터 링크(Data Link Layer)에 대한 설명이다. () 안에 올바른 용어를 쓰시오.

> 회선 제어, 흐름 제어, 오류 제어
> 
- ( ① )은/는 두 개의 스테이션이 동시에 신호를 전송하는 경우 신호 간 충돌이 발생하지 않도록 제어하는 기술로 ENQ/ACK 기법과 풀링 기법이 있다.
- ( ② )은/는 전송 스테이션으로 하여금 전송 데이터의 양을 제한하기 위해서 사용되는 기술로 정지-대기 기법과 슬라이딩 윈도 기법이 있다.
- ( ③ )은/는 OSI 7 Layer의 하위의 두 계층 사이에서 데이터의 전송 오류를 검출하여 복구하는 기술로 해밍 코드와 같은 전진 오류 수정(FEC) 기법과 체크섬, CRC, ARQ과 같은 후진 오류 수정(BEC) 기법이 있다.

- **오류 검출 정정**
    - 오류 검출은 전달자가 수신자에게 전달하는 동안 노이즈나 다른 장애로 인하여 생긴 오류를 감지하는 것이다.
        - 오류 검출 구조
            - [반복 부호](https://ko.wikipedia.org/w/index.php?title=%EB%B0%98%EB%B3%B5_%EB%B6%80%ED%98%B8_(%EC%A0%95%EB%B3%B4)&action=edit&redlink=1)
            - [패리티 비트](https://ko.wikipedia.org/wiki/%ED%8C%A8%EB%A6%AC%ED%8B%B0_%EB%B9%84%ED%8A%B8)
            - [체크섬](https://ko.wikipedia.org/wiki/%EC%B2%B4%ED%81%AC%EC%84%AC)
            - [순환 중복 검사](https://ko.wikipedia.org/wiki/%EC%88%9C%ED%99%98_%EC%A4%91%EB%B3%B5_%EA%B2%80%EC%82%AC)(CRC)
            - [암호학적 해시 함수](https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%95%99%EC%A0%81_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98)
            - [전방 오류 정정](https://ko.wikipedia.org/w/index.php?title=%EC%A0%84%EB%B0%A9_%EC%98%A4%EB%A5%98_%EC%A0%95%EC%A0%95&action=edit&redlink=1)
    - 오류 정정은 오류를 감지하고 원본 데이터를 다시 구축하는 것이다.
        - 오류 정정 구조
            - 자동 반복 요청(ARQ, BEC라고도 함): 수신되는 모든 데이터 블록은 오류 정정을 사용하여 검사되며 검사가 실패하면 데이터 재전송을 다시 요청한다.
            - 전방 오류 정정 (FEC; Forward Error Correction): 보내는 사람이 전송에 앞서 오류 정정 코드를 사용하여 데이터를 인코딩한다.
            - 하이브리드 ARQ(하이브리드 자동 재송 요구, Hybrid Automatic Repeat Qequest): ARQ와 FEC 두 가지를 합쳐 놓은 방식이다.
    
- FEC (전진 오류 수정): 송신측이 전송할 문자나 프레임에 부가적 정보(Redundancy)를 첨가하여 전송하고, 수신측이 이 부가적 정보를 이용하여 에러검출 및 에러정정을 하는 방식 - 수신측이 에러 자체 정정
- BEC (후진 오류 수정): 에러 발생 데이터에 대해 송신측에 재전송(ARQ)을 요구
    - 자동 반복 요청(**ARQ**, Automatic Repeat reQuest)
        - 오류 발생 시 수신 측은 오류 발생을 송신 측에 통보하고, 송신 측은 오류 발생 블록을 재전송하는 모든 절차를 의미하는 것
            - **정지-대기(Stop and Wait) ARQ**
                - 송신 측에서 한 개의 블록을 전송한 후 수식 측으로부터 응답을 기다리는 방식
                    - ACK - 긍정 응답, NAK - 부정 응답
                        
                        ![이미지](/assets/img/exam/31/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_31%ED%9A%8C(1).png)
                        
                - 구현 방식이 가장 단순하지만, 전송 효율이 떨어짐
            - **연속(Continuous) ARQ**
                - 연속적으로 데이터 블록을 보내는 방식
                - **Go-Back-N ARQ**: 오류가 발생한 블록 이후의 모든 블록을 재전송하는 방식
                - 선택적 재전송(**Selective Repeat**) ARQ: 오류가 발생한 블록만 재전송하는 방식
            - **적응적(Adaptive) ARQ**
                - 블록 길이를 채널의 상태에 따라 그때 그때 동적으로 변경하는 방식으로, 전송 효율이 가장 좋다
                - 제어 회로가 복잡하고, 비용이 많이 들어 현재 거의 사용되지 않음
                
    
    > **오류제어 기법 특성 비교**
    > 
    > - 정지-대기 흐름 제어 구현
    >     - 정지대기 ARQ: 구조가 간단하여 구현이 용이, 비효율적
    > - 슬라이딩 윈도우 흐름 제어 구현
    >     - SR ARQ: 가장 효율적, 구조가 복잡하여 유지보수 비용이 많이 든다.
    >     - GBn ARQ: 비교적 구조가 간단, 효율성 향상, 널리 사용됨
    
- **순환 중복 검사(CRC**; Cyclic Redundancy Check)
    - 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식을 말한다.
    - 데이터를 전송하기 전에 주어진 데이터의 값에 따라 CRC 값을 계산하여 데이터에 붙여 전송하고, 데이터 전송이 끝난 후 받은 데이터의 값으로 다시 CRC 값을 계산하게 된다. 이어서 두 값을 비교하고, 이 두 값이 다르면 데이터 전송 과정에서 잡음 등에 의해 오류가 덧붙여 전송된 것임을 알 수 있다.
    - CRC는 이진법 기반의 하드웨어에서 구현하기 쉽고, 데이터 전송 과정에서 발생하는 흔한 오류들을 검출하는 데 탁월하다. 하지만 CRC의 구조 때문에 의도적으로 주어진 CRC 값을 갖는 다른 데이터를 만들기가 쉽고, 따라서 데이터 무결성을 검사하는 데는 사용될 수 없다. 이런 용도로는 [MD5](https://ko.wikipedia.org/wiki/MD5) 등의 함수들이 사용된다.
    - 순환 중복 검사(CRC)를 체크섬이라고 말하기도 한다. 엄밀히 말하면 체크섬은 나열된 데이터를 더하여 체크섬(데이터의 모든 수치를 더한 합) 숫자를 얻고, 정해진 비트수의 모듈라로 정해진 비트수로 재구성 한다. **체크섬**(checksum)은 [중복 검사](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%A5%98_%EC%A0%95%EC%A0%95_%EB%B6%80%ED%98%B8)의 한 형태로, 오류 정정을 통해, 공간(전자 통신)이나 시간(기억 장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법이다.

---

Q. 서버가 광섬유 채널(Fiber Channel)을 통하여 스토리지를 연결하는 기법으로 DAS 방식의 접속 한계성을 극복하여, n개의 서버가 m 개의 저장장치에 접속이 가능한 스토리지 기술은 무엇인가?

> SAN(Storage Area Network)
> 

- **Storage Area Network**
    - SAN은 서버가 광섬유 채널(Fiber Channel)을 통하여 스토리지를 연결하는 기법으로 DAS 방식의 접속 한계성을 극복하여, n 개의 서버가 m 개의 저장장치에 접속이 가능한 스토리지 기술이다.
    - 단일 NAS 구성으로는 한계가 생기는 경우 상위개념으로 주로 기업체나 관공서에서 제한적으로 사용하는 SAN(**S**torage **A**rea **N**etwork)이 있다. NAS는 서버역할의 기능과 스토리지가 한 시스템에 통합된 반면 SAN의 경우 서버와 스토리지가 분리되어 있으며 이를 통해 다수의 스토리지 서버를 광단자 네트워크(Fiber Channel) 나 독립된 고속 네트워크로 묶어 마치 하나의 디스크처럼 사용할 수 있게 해주는 SAN은 NAS보다 훨씬 더 안정적이며 빠른 속도와 탁월한 성능을 자랑하지만 발열과 소음, 설치 공간 문제도 만만치 않으며 가격 또한 NAS를 아득히 능가하는 것이 단점
- 네트워크 결합 스토리지(**NAS**; **Network Attached Storage**)
    - 다수의 저장장치(HDD나 SSD)를 연결한 개인용 파일서버로서, 네트워크(인터넷)로 접속하여 데이터에 접근하는 용도의 저장장치 시스템이다. 반대 개념은 컴퓨터에 직접 연결해서 쓰는 DAS(직접 결합 저장장치, **Direct Attached Storage**)로, 내장형 하드디스크나 eSATA 규격 외장 하드디스크가 여기에 해당된다. 이와 유사한 클라우드 스토리지는 개인이 서비스 제공자에게 정기적으로 일정 비용을 지불하고 서비스 제공자로부터 저장공간을 제공받아 사용하는 방식이라면, **나스는 개인이 독립적으로 구축, 사용하는 개인 데이터 저장소**이다.
    - 컴퓨터를 직접 연결하지 않고 근거리 통신 네트워크를 통해 데이터를 주고 받는다. 현대에 들어와 점차 보급화가 되고 있는 클라우드 스토리지 서비스와 유사하지만 여러 차이가 있다.

---

Q. 패스워드 크래킹(Password Cracking) 기법 중 시스템 또는 서비스의 ID와 패스워드를 크랙하기 위해서 ID와 패스워드가 될 가능성이 있는 단어를 파일로 만들어 놓고 이 파일의 단어를 대입하여 크랙하는 공격 기법을 무엇이라고 하는가?

> 사전(Dictionary) 크래킹
> 

- 패스워드 크래킹(Password Cracking) 기법은 다음과 같다.
    - 사전(Dictionary) 크래킹
        - 시스템 또는 서비스의 ID와 패스워드를 크랙하기 위해서 ID와 패스워드가 될 가능성이 있는 단어를 파일로 만들어 놓고 이 파일의 단어를 대입하여 크랙하는 공격 기법
    - 무차별(Brute Force) 크래킹
        - 패스워드로 사용될 수 있는 영문자(대소문자), 숫자, 특수문자 등을 무작위로 패스워드 자리에 대입하여 패스워드를 알아내는 기법

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

> 33
> 

```java
public class Soojebi {
	public static void main(String[] args) 
		int[] a = {1, 2, 3};
		int[] b = {2, 3, 4};
		int sum=0;
		
		for(int i=1; i<a.length; i++) {
			for(int j=0; j<b.lengh; j++) {
				sum += (a[i]+b[j]);
			}
		}
		System.out.print(sum);
	}
}
```

- 정수형 배열 a는 1, 2, 3으로 초기화하고 b는 2, 3, 4로 초기화한다.
- 2중 반복문에서는 오른쪽 sum 값과 a[i]와 b[j]를 더한 결과를 왼쪽 sum에 누적 합을 대입한다. 최종 결괏값 33을 화면에 출력한다.
    
    
    | i | j | sum = sum + a[i] + b[j] |
    | --- | --- | --- |
    | 1 | 0 | 4 |
    | 1 | 1 | 9 |
    | 1 | 2 | 15 |
    | 2 | 0 | 20 |
    | 2 | 1 | 26 |
    | 2 | 2 | 33 |

---

Q. 관리자가 사용자 이연희에게 ‘EMPLOYEE’ 테이블에 대해 데이터를 삽입, 수정할 수 있는 권한을 부여하는 쿼리를 작성하시오.

```sql
GRANT INSERT, UPDATE ON EMPLOYEE TO 이연희; 
```

- GRANT는 데이터베이스 관리자(DBA; Database Administrator)가 사용자에게 데이터베이스에 대한 권한을 부여하는 명령어이다
    
    ```sql
    GRANT 권한 ON 테이블 TO 사용자;
    ```
    
    - 관리자가 사용자에게 테이블에 대한 권한을 부여

---

Q. 보헴(Boehm)이 제안한 프로그램 규모에 따라 비용을 산정하는 방식으로, 규모에 따라 조직형, 반 분리형, 임베디드형으로 나뉘는 모형은 무엇인가?

> COCOMO(COnstructive COst MOdel)
> 

- COCOMO의 소프트웨어 개발 유형은 다음과 같다.
    - 조직형(Organic Mode)
        - 기관 내부에서 개발된 중 소규모의 소프트웨어로 일괄 자료 처리나 과학 기술 계산용, 비지니스 자료 처리 개발에 적용
        - 5만 라인 이하의 소프트웨어를 개발하는 유형
    - 반-분리형(Semi-Detached Mode)
        - 단순형과 임베디드형의 중간형
        - 트랜잭션 처리 시스템이나, 데이터베이스 관리 시스템, 컴파일러, 인터프리터와 같은 유틸 개발에 적용
        - 30만 라인 이하의 소프트웨어를 개발하는 유형
    - 임베디드형(Embedded Mode)
        - 초대형 규모의 트랜잭션 처리 시스템이나 운영체제, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적용
        - 30만 라인 이상의 소프트웨어를 개발하는 유형

---

Q. 소프트웨어 개발방법론 중 애자일(Agile) 방법론에 대해서 서술하시오.

> 애자일 방법론은 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론이다.
> 

- 소프트웨어 개발방법론의 종류는 다음과 같다.
    - 구조적 방법론(Structured Development)
        - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식의 방법론
        - 프로세스 중심의 하향식 방법론
        - 구조적 프로그래밍 표현을 위해 나씨-슈나이더만(Nassi-Shneiderman) 차트 사용
            - NS 차트 특징
                - 논리의 기술에 중점을 둔 도형식 표현 방법
                - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현
                - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합
    - 정보공학 방법론(Information Engineering Development)
        - 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
        - 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
    - 객체지향 방법론(Object-Oriented Development)
        - ‘객체’라는 기본 단위로 시스템을 분석 및 설계하는 방법론
        - 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용하는 방법론
        - 객체, 클래스, 메시지를 이용
    - 컴포넌트 기반 방법론(CBD; Component Based Development)
        - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
        - 개발 기간 단축으로 인한 생산성 향상
        - 새로운 기능 추가 쉬움(확장성)
        - 소프트웨어 재사용이 가능
    - 애자일 방법론(Agile Development)
        - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
        - 애자일은 개발 과정의 어려움을 극복하기 위해 적극적으로 모색한 방법론
    - 제품 계열 방법론(Product Line Development)
        - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
        - 임베디드 소프트웨어를 작성하는 데 유용한 방법론
        - 영역 공학과 응용 공학으로 구분
            - 영역 공학: 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역
            - 응용 공학: 제품 요구분석, 제품 설계, 제품을 구현하는 영역

---

Q. 소프트웨어 테스트의 원리 중 오류-부재의 궤변에 대해서 서술하시오.

> 오류-부재의 궤변은 요구사항을 충족시켜주지 못했다면, 결함이 없다고 해도 품질이 높다고 볼 수 없는 소프트웨어 테스트 원리이다.
> 

- 소프트웨어 테스트의 원리는 다음과 같다.
    - 결함 존재 증명
        - 테스트는 결함이 존재함을 밝히는 행동
        - 결함이 없다는 것을 증명할 수 없음
    - 완벽 테스팅은 불가능
        - 무한 경로(한 프로그램 내의 내부 조건은 무수히 많을 수 있음), 무한 입력 값(입력이 가질 수 잇는 모든 값의 조합이 무수히 많음)으로 인한 완벽한 테스트가 어렵다는 원리
    - 초기 집중
        - 개발 초기에 체계적인 분석 및 설계가 수행되면 테스팅 기간 단축, 재작업을 줄여 개발 기간을 단축 및 결함을 예방할 수 있다는 원리
        - SW 개발 초기 체계적인 분석 및 설계가 수행되지 못하면 그 결과가 프로젝트 후반에 영향을 미치게 되어 비용이 커진다는 요르돈 법칙 적용(Snowball Effect; 눈덩이 법칙)
    - 결합 집중
        - 적은 수의 모듈(20% 모듈)에서 대다수 결함(80% 결함)이 발견된다는 원리
        - 파레토 법칙(Pareto Principle)의 내용인 80 대 20 법칙 적용
    - 살충제 패러독스
        - 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못한다는 원리
    - 정황 의존성
        - 소프트웨어의 성격에 맞게 테스트를 수행해야 한다는 의미
    - 오류-부재의 궤변
        - 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없다는 원리

---

Q. 다음은 [급여] 테이블이다. 급여가 200 이상이고, 300 이하인 직원의 이름, 부서, 급여를 검색하는 SQL 문을 BETWEEN 키워드를 사용하여 작성하시오.

```sql
SELECT 이름, 부서, 급여
FROM 급여
WHERE 급여 BETWEEN 200 AND 300;
```

```sql
SELECT *
FROM 급여
WHERE 급여 BETWEEN 200 AND 300;
```

[급여]

| 이름 | 부서 | 급여 |
| --- | --- | --- |
| 선조 | 영업 | 300 |
| 광해군 | 마케팅 | 400 |
| 연산군 | 전산 | 200 |
| 정조 | 전산 | 500 |
| 고종 | 마케팅 | 100 |

[결과]

| 이름 | 부서 | 급여 |
| --- | --- | --- |
| 선조 | 영업 | 300 |
| 연산군 | 전산 | 200 |

---

Q. 다음은 UI 시나리오 문서의 작성 요건이다. () 안에 들어갈 UI 시나리오 문서의 작성 요건을 쓰시오.

> 완전성(Complete), 가독성(Readable), 수정 용이성(Modifiable)
> 
- ( ① ): UI 시나리오는 누락이 없어야 하고, 최대한 빠짐없이 가능한 한 상세하게 기술해야 한다.
- ( ② ): 문서를 쉽게 읽을 수 있어야 하고(문서 템플릿과 타이포그래피), 표준화된 템플릿을 작성하여 적용해야 한다.
- ( ③ ): 쉽게 변경 가능해야 하고, 수정 또는 개선 사항을 시나리오에 반영하는 데 있어 쉽게 적용할 수 있어야 한다.

- UI 시나리오 문서의 작성 요건은 다음과 같다.
    - 완전성(Complete)
        - UI 시나리오는 누락이 없어야 하고, 최대한 빠짐없이 가능한 한 상세하게 기술
        - 시스템 기능보다 사용자의 태스크에 초점을 맞춰 기술
    - 일관성(Consistent)
        - 서비스에 대한 목표, 시스템 및 사용자의 요구사항이 일관성이 있어야 하고, 모든 문서의 UI 스타일(Flow 또는 Layout)을 일관적으로 구성
    - 이해성(Understandable)
        - 처음 접하는 사람도 이해하기 쉽도록 구성하고 설명해야 하고, 이해하지 못하는 추상적인 표현이나 이해하기 어려운 용어는                                                                                                                 사용하지 않아야 함
    - 가독성(Readable)
        - 문서를 쉽게 읽을 수 있어야 하고(문서 템플릿과 타이포그래피), 표준화된 템플릿을 작성하여 적용
        - 버전은 넘버링 v1.0, v2.0 등과 같이 일관성 있게 하고, 시각적인 효과를 위한 하이라이팅은 일관성 있게 활용
    - 추적 용이성(Traceable)
        - 쉽게 추적이 가능해야 하고, 변경 사항들이 언제, 어디서, 어떤 부분들이, 왜 발생하였는지 추적이 쉬워야 함
    - 수정 용이성(Modifiable)
        - 쉽게 변경 가능해야 하고, 수정 또는 개선 사항을 시나리오에 반영하는 데 있어 쉽게 적용할 수 있어야 함
        - 동일한 수정 사항을 위해 여러 문서를 편집하지 않도록 함

---

Q. 다음은 자바 코드이다. 밑줄 친 곳에 들어갈 알맞은 키워드를 쓰시오.

> abstract
> 

```java
     class Animal {
	     void show();
  void key() {
	  System.out.print("animal:");
  }
}
class Dog extends Animal {
	void show() {
		System.out.print("dog");
	}
}
public class Soojebi {
	public static void main(String[] args) {
		Animal d = new Dog();
		d.show();
	}
}
```

- 추상 클래스로 선언을 하면 추상 메서드와 일반 메서드를 가질 수 있다.
- 추상 메서드는 선언만 하고 실제 구현은 상속받은 Dog 클래스에서 구현한다.
- abstract 키워드를 이용하여 추상 클래스와 추상 메서드를 선언할 수 있다.

---

Q. 다음 시스템 구조에서 G의 모듈의 팬인(Fan-In), 팬아웃(Fan-Out)을 구하시오.

> G = 3, G =2
> 

![이미지](/assets/img/exam/31/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_31%ED%9A%8C(2).png)

- 팬인(Fan-In)과 팬아웃(Fan-Out)의 개념 및 계산방법은 다음과 같다.
    - 팬인(Fan-In)
        - 어떤 모듈을 제어(호출)하는 모듈의 수
        - 모듈 자신을 기준으로 모듈에 들어오면 팬인(in)
        - 팬인이 높으면 재사용 측면에서 설계가 잘 되었지만, 단일 장애점 발생 가능
        - 팬인이 높으면 관리 비용 및 테스트 비용 증가
    - 팬 아웃(Fan-Out)
        - 어떤 모듈에 의해 제어(호출)되는 모듈의 수
        - 모듈 자신을 기준으로 모듈에서 나가면 팬아웃(out)
        - 팬아웃이 높을 경우는 불필요한 모듈 호출 여부 검토 필요
        - 팬아웃이 높을 경우는 단순화 여부 검토 필요
- 시스템 구조도 각 모듈은 다음과 같다.
    - 팬인(Fan-In): A=0 B=1 C=1 D=1 E=1 F=1 G=3 H=1 I=1 J=1
    - 팬아웃(Fan-Out): A=4 B=2 C=1 D=1 E=1 F=0 G=2 H=0 I=0 J=0

---

Q. 요구사항 수집기법 중 현실에 일어나는 장면을 설정하고 여러 사람이 각자 맡은 역을 연기함으로써 요구사항을 분석하고 수집하는 방법은 무엇인가?

> 롤 플레잉(Role Playing)
> 

- 요구사항 수집 주요 수집기법은 다음과 같다.
    - 델파이 기법(Delphi Method) - 하향식
        - 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 방법
    - 롤 플레잉(Role Playing)
        - 현실에 일어나는 장면을 설정하고 여러 사람이 각자가 맡은 역을 연기함으로써 요구사항을 분석하고 수집하는 방법
    - 워크숍(Workshop)
        - 단기간의 집중적인 노력을 통해 다양하고 전문적인 정보를 획득하고 공유하는 방법
    - 설문 조사(Survey)
        - 설문지 또는 여론조사 등을 이용해 간접적으로 정보를 수집하는 방법

---

Q. 다음중 [직원] 테이블에서 부서, 직책별 급여의 합계를 구하는 쿼리를 작성하시오.

```sql
SELECT 부서, 직책, SUM(급여) AS 급여합계
FROM 직원
GROUP BY 부서, 직책;
```

[직원]

| 이름 | 부서 | 직책 | 급여 |
| --- | --- | --- | --- |
| 워싱턴 | 영업 | 차장 | 600 |
| 링컨 | 영업 | 차장 | 500 |
| 루스벨트 | 영업 | 과장 | 400 |
| 트루면 | 전산 | 과장 | 200 |
| 아이젠하워 | 전산 | 사원 | 500 |
| 케네디 | 전산 | 사원 | 100 |

[결과]

| 부서 | 직책 | 급여합계 |
| --- | --- | --- |
| 영업 | 차장 | 1100 |
| 영업 | 과장 | 400 |
| 전산 | 과장 | 200 |
| 전산 | 사원 | 600 |

- GROUP BY절은 속성값을 그룹으로 분류하고자 할 때 사용한다.
- GROUP BY절의 속성값에 해당하는 값들끼리 그룹을 형성하고, SUM(급여)를 통해서 그룹별 합계를 구할 수 있다.

---

Q. 무선 기지국에 분산 클라우드 컴퓨팅 기술을 적용하여 서비스와 캐싱 콘텐츠를 이용자 단말에 가까이 전개함으로써 모바일 코어 망의 혼잡을 완화하는 기술은 무엇인가?

> MEC(Mobile Edge Computing/Cloud)
> 

- MEC는 무선 기지국에서 분산 클라우드 컴퓨팅 기술을 적용하여 서비스와 캐싱 콘텐츠를 이용자 단말에 가까이 전개함으로써 모바일 코어 망의 혼잡을 완화하는 기술이다.

- 기지국은 무선통신의 서비스를 위해 네트워크와 단말기를 연결하는 무선 통신설비이다. CDMA, GSM, WCDMA, LTE 등의 이동통신의 엑세스 네트워크와 휴대전화를 연결하는 기지국이 대표적이다.

---

Q. 블록체인 기술 중 거래의 안정성을 보장해주는 기술이자 모든 참여자가 데이터의 적합성을 판단하고 동의하는 과정을 합의 알고리즘이라고 한다. 합의 알고리즘 중 ( ① )은/는 확률적으로 해답이 어려운 문제를 가장 빨리 해결한 사람에게 블록을 만들 수 있도록 허가하는 합의 알고리즘이고, ( ② )은/는 화폐량을 더 많이 소유하고 있는 승인자가 우선하여 블록을 생성할 수 있는 알고리즘이다. () 안에 들어갈 용어를 쓰시오.

> PoW(Proof of Work), PoS(Proof of Stake)
> 

- 블록체인 합의 알고리즘은 다음과 같다.
- PoW(Proof of Work)
    - 확률적으로 해답이 어려운 문제를 가장 빨리 해결한 사람에게 블록을 만들 수 있도록 허가하는 합의 알고리즘
- PoS(Proof of Stake)
    - 이더리움이 채택할 예정인 알고리즘으로 PoW와 기본 방식은 동일하나 화폐량을 더 많이 소유하고 있는 승인자가 우선하여 블록을 생성할 수 있는 알고리즘
- PBFT(Partical Byzantine Fault Tolerance)
    - 참가자 중 1명이 Primary(리더)가 되어 자신을 포함한 모든 참가자에게 요청을 보내고, 그 요청에 대한 결과를 집계한 뒤 다수의 값을 사용해 블록을 확정하는 합의 알고리즘
    - PoW와 PoS의 단점인 파이널리티 불확실성과 성능 문제를 해결한 알고리즘

---

Q. 서비스라고 정의되는 분할된 애플리케이션 조각들을 Loosely-Coupled하게 연결해 하나의 완성된 Application을 구현하기 위한 아키텍처를 무엇이라고 하는가?

> 서비스 지향 아키텍처(SOA; Service Oriented Architecture)
> 

- SOA는 서비스라고 정의되는 분할된 애플리케이션 조각들을 Loosely-coupled 하게 연결해 하나의 완성된 Application을 구현하기 위한 아키텍처이다.

---

Q. 데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 기법은 무엇인가?

> CRUD 분석 또는 CRUD 매트릭스 분석
> 

- CRUD 분석은 프로세스와 데이터 사이에 관계 의존성을 CREATE, READ, UPDATE, DELETE 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석한다.
- 주로 CRUD 매트릭스를 통해 관계를 표현한다.

- 트랜잭션 분석 / CRUD 분석
- CRUD 분석은 프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것
- CRUD 분석을 통해 많은 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용할 수 있음, 많은 차가 몰리는 도로에 대해 확장 공사 혹은 신호체계(소통 원활) 구성
    - CRUD 매트릭스
        - 2차원 형태의 표로서, 행(ROW)에는 프로세스를, 열(Column)에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하여 프로세스와 데이터간의 관계를 분석하는 분석표임
        - CRUD 매트릭스를 통해 트랜잭션이 테이블에 수행하는 작업을 검증함
        - CRUD 매트릭스의 각 셀에는 Create, Read, Update, Delete의 앞 글자가 들어가며, 복수의 변화를 줄 때는 기본적으로 'C> D > U> R'의 우선순위를 적용하여 한 가지만 적지만, 활용 목적에 따라 모두 기록할 수 있다.
        - 예) '주문 변경 프로세스를 실행하려면 테이블의 데이터를 읽은(Read) 다음 수정(Update) 해야하므로 R(Read)과 U(Update)가 필요하지만 CRUD 매트릭스에는 우선순위가 높은 U'만 표시함
        - CRUD 매트릭스가 완성되었다면 C, R, U, D 중 어느 것도 적히지 않은 행이나 열, C나 R이 없는 열을 확인하여 불필요하거나 누락된 테이블 또는 프로세스를 찾는다
        
        ![이미지](/assets/img/exam/31/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_31%ED%9A%8C(3).png)
        

- 트랜잭션 분석
- 트랜잭션 분석은 CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB의 용량 산정 및 구조의 최적화를 목적으로함
- 트랜잭션 분석은 업무 개발 담당자가 수행함
- 트랜잭션 분석을 통해 프로세스가 과도하게 접근하는 테이블을 확인할 수 있으며, 이러한 집중 접근 테이블을 여러 디스크에 분산 배치함으로써 디스크 입•출력 향상을 통한 성능 향상을 가져올 수 있음
    - 트랜잭션 분석서는 단위 프로세스와 CRUD 매트릭스를 이용하여 작성하며, 구성 요소에는 단위 프로세스, CRUD 연산, 테이블명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등이 있음.
        - 단위 프로세스 : 업무를 발생시키는 가장 작은 단위의 프로세스
        - CRUD 연산 : 프로세스의 트랜잭션이 데이터베이스 테이블에 영향을 주는 C, R, U, D의 4가지 연산
        - 테이블명, 컬럼명 : 프로세스가 접근하는 데이터베이스의 테이블명을 기록함. 필요한 경우 테이블의 컬럼명을 적는다. 컬럼명을 적을 때는 마침표로 연결하여 '테이블.컬럼명'과 같이 적는다.
        - 테이블 참조 횟수 : 프로세스가 테이블을 참조하는 횟수
        - 트랜잭션 수 : 주기별로 수행되는 트랜잭션 횟수
        - 발생 주기 : 연, 분기, 월, 일, 시간 등 트랜잭션 횟수를 측정하기 위한 발생 주기
            
            ![이미지](/assets/img/exam/31/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_31%ED%9A%8C(4).png)
            

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 8
> 

```c
#include <stdio.h>
void main() {
	int ret = 4;
	
	switch(++ret) {
	case 5: ret+=2;
	case 3: ret++; break;
	case 4: ret++;
	default: ret*=2;
	}
	
	printf("%d\n", ret);
}

```

- 정수형 변수 ret는 4로 선언과 동시에 초기화한다.
- switch 조건에서 ++ret이므로 ret를 1 증가시킨 5가 되므로 case 5의 ret +=2가 실행된다. ret의 5와 2를 더한 7을 ret에 대입한다. break가 없으므로 그다음 case 3의 ret++가 실행이 되며, ret은 8이 되고 break 문을 만나 switch가 종료된다. ret를 printf 함수에서 화면에 출력한다.


<br>
**참고 자료**

---

- [https://ko.wikipedia.org/wiki/체크섬 - 체크섬](https://ko.wikipedia.org/wiki/%EC%B2%B4%ED%81%AC%EC%84%AC)
- [https://ko.wikipedia.org/wiki/순환_중복_검사 - CRC(순환 중복 검사)](https://ko.wikipedia.org/wiki/%EC%88%9C%ED%99%98_%EC%A4%91%EB%B3%B5_%EA%B2%80%EC%82%AC)
- [http://www.ktword.co.kr/test/view/view.php?no=693 - FEC, BEC](http://www.ktword.co.kr/test/view/view.php?no=693)
- [https://m.kin.naver.com/mobile/qna/detail.naver?d1id=1&dirId=1040101&docId=412577858&enc=utf8&kinsrch_src=m_nx_kin&qb=7LK07YGs7ISs&rank=1&search_sort=0&section=kin.qna_ency_cafe&spq=0#answer1 - 체크섬, CRC, MD5](https://m.kin.naver.com/mobile/qna/detail.naver?d1id=1&dirId=1040101&docId=412577858&enc=utf8&kinsrch_src=m_nx_kin&qb=7LK07YGs7ISs&rank=1&search_sort=0&section=kin.qna_ency_cafe&spq=0#answer1)
- [https://namu.wiki/w/NAS(저장장치) DAS, NAS, SAN](https://namu.wiki/w/NAS(%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98))
- [https://www.plinst.com/12 - Stake holder, PoS(Proof of Stake)](https://www.plinst.com/12)