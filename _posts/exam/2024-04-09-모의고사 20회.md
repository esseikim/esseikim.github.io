---
categories: [정보처리기사, 모의고사 문제 풀이]
---

Q. 소프트웨어의 개발(Development)과 운영(Operations)의 합성어로서, 소프트웨어 개발자와 정보기술 전문가 간의 소통, 협업 및 통합을 강조하는 개발 환경이나 문화를 말하는 용어는 무엇인가?

> 데브옵스(Devops)
> 

- 데브옵스는 소프트웨어 개발조직과 운영조직 간의 상호 의존적 대응이며, 조직이 소프트웨어 제품과 서비스를 빠른 시간에 개발 및 배포하는 것을 목적으로 한다.

---

Q. 다음은 보안 관련 용어이다. () 안에 공통으로 들어갈 용어를 쓰시오.

> 파밍(Pharming)
> 

()은/는 새로운 피싱 기법의 하나로, 사용자가 자신의 웹 브라우저에서 정확한 웹 페이지 주소를 입력해도 가짜 웹 페이지에 접속하게 하여 개인 정보를 훔치는 것을 말한다. ()의 예시로, 컴퓨터에 악성 코드를 설치하게 한 뒤 은행 사이트 접속 시 자신들이 개설해 놓은 사이트로 강제로 접속하게 한 뒤 보안카드 번호를 입력받아 돈을 빼간다.

- 피싱과 관련된 주요 용어는 다음과 같다.
    - 파밍(Pharming)
        - 새로운피싱 기법의 하나로, 사용자가 자신의 웹 브라우저에서 정확한 웹 페이지 주소를 입력해도 가짜 웹 페이지에 접속하게 하여 개인 정보를 훔치는 공격 기법
    - 스미싱(Smishing)
        - 문제 메시지를 이용하여 신뢰할 수 있는 사람 또는 기업이 보낸 것처럼 가장하여 개인 비밀정보를 요구하거나 휴대폰소액 결제를 유도하는 공격 기법
    - 큐싱(Qshing)
        - 스마트폰을 이용하여 금융 업무를 처리하는 사용자에게 인증 등이 필요한 것처럼 속여 QR 코드(Quick Response Code)를 통해 악성 앱을 내려 받도록 유도하여 금융 정보를 빼내는 공격 기법
    - 스피어 피싱(Spear Phishing)
        - 사회공학의 한 기법으로, 특정 대상을 선정한 후 그 대상에게 일반적인 이메일로 위장한 메일을 지속적으로 발송하여, 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도하여 사용자의 개인 정보를 탈취하는 공격 기법

---

Q. 다중화기(Multiplexer)는 하나의 회선을 통해 일정한 시간이나 주파수로 나누어서 전송하게 하는 장비이다. 다중화기 중 ( ① )은/는 회선의 대역폭을 일정 시간으로 분할하여 전송하는 방식이고, ( ② )은/는 하나의 주파수 대역폭을 다수의 작은 대역폭으로 분할하여 전송하는 방식이다. 또한 ( ③ )은/는 정해진 주파수 대역에 다수의 사용자가 서로 다른 코드를 사용함으로써 동일한 주파수로 동시에 다수가 접속해서 전송하는 방식이다. () 안에 들어갈 용어를 쓰시오.

> 시간 분할 다중화(TDM; Time Division Multiplexing), 주파수 분활 다중화(FDM; Frequency Division), 코드 분할 다중화(CDM; Code Division Multiplexing)
> 

- 다중화기의 종류는 다음과 같다.
    
    
    | 장비 구분 | 설명 |
    | --- | --- |
    | 시간 분할 다중화(TDM; Time Division Multiplexing) | 회선의 대역폭을 일정 시간으로 분할하여 전송하는 방식 |
    | 주파수 분할 다중화(FDM; Frequency Division Multiplexing) | 하나의 주파수 대역폭을 다수의 작은 대역폭으로 분할하여 전송하는 방식 |
    | 코드 분할 다중화(CDM; Code Division Multiplexing) | 정해진 주파수 대역에 다수의 사용자가 서로 다른 코드를 사용함으로써 동일한 주파수로 동시에 다수가 접속해서 전송하는 방식 |

---

Q. 딥러닝(Deep Learning)의 주요 알고리즘 중 ( ① )은/는 필터에 의한 컨볼루션과 서브 샘플링 과정을 반복하는 비지도 학습으로 입력 데이터의 특징을 극대화하면서 차원을 축소하는 딥러닝 알고리즘이고, ( ② )은/는 연속된 데이터상에서 이전 순서의 은닉 노드의 값을 저장한 이후, 다음 순서의 입력 데이터로 학습할 때 이전의 값을 이용, 연속적인 정보의 흐름을 학습에 이용하는 딥러닝 알고리즘이다. () 안에 들어갈 용어를 쓰시오.

> 합성곱 신경망(CNN; Convolution Neural Network), 순환 신경망(RNN; Recurrent Neural Network)
> 

- 딥러닝 주요 알고리즘은 다음과 같다.
    
    
    | 알고리즘 | 설명 |
    | --- | --- |
    | 합성곱 신경망(CNN; Convolution Neural Network) | 필터에 의한 컨볼루션과 서브 샘플링 과정을 반복하는 비지도 학습으로 입력 데이터의 특징을 극대화하면서 차원을 축소하는 딥러닝 알고리즘 |
    | 순환 신경망(RNN; Recurrent Neural Network) | 연속된 데이터상에서 이전 순서의 은닉 노드의 값을 저장한 이후, 다음순서의 입력 데이터로 학습할 대 이전의 값을 이용, 연속적인 정보의 흐름을 학습에 이용하는 딥러닝 알고리즘 |

- 합성곱 또는 콘벌루션(convolution)은 하나의 함수와 또 다른 함수를 반전 이동한 값을 곱한 다음, 구간에 대해 적분하여 새로운 함수를 구하는 수학 연산자

---

Q. 다음 [학생] 테이블에 대해 쿼리를 실행한 결과이다. [결과] 테이블에 들어갈 값을 쓰시오.

> 5
> 

[학생]

| 학번 | 이름 | 학년 |
| --- | --- | --- |
| 202101 | 윤봉길 | 1 |
| 202102 | 안중근 | 3 |
| 202103 | 이순신 | 2 |
| 202104 | 홍범도 | 3 |
| 202105 | 김좌진 | 4 |
| 202106 | 유관순 | 3 |
| 202107 | 이봉창 | 2 |

[쿼리]

```sql
SELECT COUNT(*) 
FROM 학생
WHERE 학년 >= 3 OR 학번 >= 202106;
```

[결과]

| COUNT(*) |
| --- |
|  |

- 학생 테이블에서 3학년 이상(SELECT * FROM 학생 WHERE 학년 >= 3;)인 쿼리 결과는 다음과 같다.
    
    
    | 학번 | 이름 | 학년 |
    | --- | --- | --- |
    | 200102 | 안중근 | 3 |
    | 200104 | 홍범도 | 3 |
    | 200105 | 김좌진 | 4 |
    | 200106 | 유관순 | 3 |

- 학생 테이블에서 학번이 202106 이상(SELECT * 학생 WHERE 학번 >= 202106;)인 쿼리 결과는 다음과 같다.
    
    
    | 학번 | 이름 | 학년 |
    | --- | --- | --- |
    | 200106 | 유관순 | 3 |
    | 200107 | 이봉창 | 2 |

- 학생 테이블에서 3학년 이상이거나 학번이 202106 이상인 결과(WHERE 학년 >= 3 OR 학번 >= 202106;)는 다음과 같다.
    
    
    | 학번 | 이름 | 학년 |
    | --- | --- | --- |
    | 200102 | 안중근 | 3 |
    | 200104 | 홍범도 | 3 |
    | 200105 | 김좌진 | 4 |
    | 200106 | 유관순 | 3 |
    | 202107 | 이봉창 | 2 |

- COUNT(*)를 하면 레코드의 개수가 5이므로 결과는 다음과 같다.
    
    
    | COUNT(*) |
    | --- |
    | 5 |

---

Q. 다음의 C언어 출력 결과를 쓰시오.

[풀이 추가 예정]

```c
#include <stdio.h>
#include <math.h>

void number(int *a) {
	int i;
	for(i=0; i<5; ) {
		a[i] = i+2+i*2;
		if(a[i] > 1) i++;
	}
}

int checkN(int data) {
	// sqrt(X)는 X에 대한 양의 제곱근을 반환
	int i=(int)sqrt(data);
	int j=2;
	
	while(j <= i) {
		if(data % j == 0)
			return 0;
		j++;
	}
	
	return 1;
}

void main() {
	int s[5];
	int i;
	
	number(s);
	for(i=0; i<5; i++) {
		printf("%d", checkN(s[i]));
	}
}
```

---

Q. 블랙박스 테스트 기법의 유형 중 경곗값 분석 테스트(Boundary Value Analysis Testing)에 대해서 서술하시오.

> 경곗값 분석 테스트는 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법이다.
> 

- 블랙박스 테스트의 유형은 다음과 같다.
    - 동등분할 테스트 = 동치분할 테스트, 균등 분할 테스트, 동치 클래스 분해 테스트(Equivalence Partitioning Testing)
        - 입력 데이터의 영역을 유사한 도메인별로 유효 값/무효 값을을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트하는 기법
    - 경곗값 분석 테스트 = 한곗값 테스트, Boundary Value Analysis Testing
        - 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법
        - 최솟값 바로 위, 최대치 바로 아래 등 입력값의 극한 한계를 테스트하는 기법
    - 원인-결과 그래프 테스트(Cause-Effect Graphing Testing)
        - 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법
    - 비교 테스트(Comparison Testing)
        - 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해 보는 테스트 기법
    - 오류 추정 테스트(Error Guessing Testing)
        - 개발자가 범할 수 있는 실수를 추정하고 이에 따른 결함이 검출되도록 테스트 케이스를 설계하여 테스트하는 기법
        - 특정 테스트 대상이 주어지면 테스터의 경험과 직관을 바탕으로 개발자가 범할 수 있는 실수들을 나열하고, 해당 실수에 따른 결함을 노출하는 테스트로 다른 블랙박스 테스트 기법을 보완할 때 사용하는 기법
    - 결정 테이블 테스트(Decision Table Testing)
        - 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법
    - 상태 전이 테스트(State Transition Testing)
        - 테스트 대상∙시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법
    - 유스케이스 테스트(Use Case Testing)
        - 시스템이 실제 사용되는 유스케이스로 모델링 되어있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법
    - 분류 트리 테스트(Classification Tree Method Testing)
        - SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법
    - 페어와이즈 테스트(Pairwise Testing)
        - 테스트 데이터값 간에 최소한 한 번씩은 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 기법

---

Q. 결함 생명주기 별 결함 상태에서 Open된 결함을 곧바로 수정하지 않고 다른 릴리스에서 해결하기로 연기된 상태를 무엇이라 하는가?

> 결함 조치 보류(Deferred)
> 

- 결함 생명주기별 결함 상태는 다음과 같다.
    - 결함 등록(Open)
        - 테스터가 테스트 절차를 실행하여 발견한 결함을 분석 후 구체화, 고립화, 일반화한 결함으로서 보고된 상태
    - 결함 검토(Reviewed)
        - Open된 결함의 처리 방안을 검토하는 상태
    - 결함 할당(Assigned)
        - 결함을 수정할 개발자가 결정되고, 그 개발자에게 결함 해결이 요구된 상태
    - 결함 수정(Resolved)
        - 개발자가 자신에게 할당된 수정 사항에 대한 해결을 처리한 상태
    - 결함 확인(Verified)
        - 개발자의 결함 처리가 합당한지, 정확한지 검증이 완료된 상태
    - 결함 종료(Closed)
        - 수정된 사항에 대하여 정확한 수정이 이루어졌다고 판단되어 종료된 상태
    - 결함 재등록(Reopen)
        - 결함이 정확하게 수정되지 않아서 다시 수정을 요구하는 상태
    - 결함 조치 보류(Deferred)
        - Open된 결함을 곧바로 수정하지 않고 다음 릴리스에서 해결하기로 연기된 상태
        - Deferred된 결함은 적절한 시점에 Reopen되어 결함 처리가 시작될 수 있음

- 데이터베이스의 고립화 수준
    - 데이터베이스의 고립화 수준은 다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 정도이다.

---

Q. 데이터베이스 시스템에서 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합은 무엇인가?

> 프로시저(Procedure)
> 

- 절차형 SQL은 프로시저, 사용자 정의함수, 트리거가 있다.
    - 프로시저(Procedure)
        - 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
    - 사용자 정의함수(User-Defined Function)
        - 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL
    - 트리거(Trigger)
        - 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL

---

Q. SOOJEBI 테이블에 대한 DDL문을 실행한 후에 INSERT문을 삽입하는 순간 GRADE에 NULL이 발생했다. GRADE 컬럼에 값을 따로 넣지 않을 경우 기본 값이 1이 되도록 하는 쿼리를 작성하시오.

```sql
ALTER TABLE SOOJEBI MODIFY GRADE NUMBER(1) DEFAULT 1;
```

[DDL 문]

```sql
CREATE TABLE SOOJEBI (
	ID NUMBER(8),
	NAME VARCHAR(10),
	GRADE NUMBER(1)
);
```

[INSERT 문]

```sql
INSERT INTO SOOJEBI(ID, NAME) VALUES ('20210001', '홍길동');
```

- ALTER TABLE은 테이블을 수정하는 명령이다.
- ALTER TABLE에서 컬럼을 수정하기 위해서는 MODIFY라는 키워드를 쓰고 문법은 다음과 같다.
    
    ```sql
    ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건];
    ```
    
- 추가로 제약조건은 다음과 같다.
    - PRIMARY KEY
        - 테이블의 기본 키를 정의
        - 유일하게 테이블의 각 행을 식별
    - FOREIGN KEY
        - 외래 키를 정의
        - **참조 대상**을 **테이블(컬럼명)**로 명시
        - 열과 참조된 테이블의 열 사이의 외래 키 관계를 적용하고 설정
    - UNIQUE
        - 테이블 내에서 얻은 유일한 값을 갖도록 하는 제약조건
    - NOT NULL
        - 해당 컬럼은 NULL 값을 포함하지 않도록 하는 제약조건
    - CHECK
        - 개발자가 정의하는 제약조건
        - 참(TRUE)이어야 하는 조건을 지정
    - DEFAULT
        - 데이터를 INSERT할 때 해당 컬럼의 값을 넣지 않는 경우 기본값으로 설정해주는 제약조건

---

Q. 객체지향 모델링 시 속성 및 연산과의 정적인 관계를 표현하고, 접근 제어자를 사용하는 다이어그램은 무엇인가?

> 클래스(Class) 다이어그램
> 

- 클래스 다이어그램의 주요 구성요소는 다음과 같다.
    - 클래스(Class)
        - 공통의 속성, 연산(메서드), 관계, 의미를 공유하는 객체들의 집합
    - 속성(Attribute)
        - 클래스의 구조적 특성에 이름을 붙인 것으로 특성에 해당하는 인스턴스가 보유할 수 있는 값의 범위를 기술
    - 연산(Operation), 메서드
        - 이름, 타입, 매개변수들과 연관된 행위를 호출하는데 요구되는 제약사항들을 명시하는 클래스의 행위적 특징
        - 객체에 요청하여 행동에 영향을 줄 수 있는 서비스
    - 접근 제어자(Access Modifier)
        - 클래스에 접근할 수 있는 정도를 표현
            - `-`: 클래스 내부 접근만 허용(private)
            - `+`: 클래스 외부 접근을 허용(public)
            - `#`: 동일 패키지/파생 클래스에서 접근 가능(protected)
            - `~`: 동일 패키지 클래스에서 접근 가능(default)

---

Q. 다음은 자바 코드이다. 출력 결과를 쓰시오.

```java
public class Soojebi {
	public static void main(String[] args) {
		int[][] a = new int[10][8];
		int sum = 0;
		for(int i=5; i<6; i++) {
			for(int j=5; j<8; j++) {
				a[i][j] = i*j +15;
				sum += a[i][j];
			}
		}
		double sum = sum / a.length;
		Systme.out.print(num);
	}

}
```

---

Q. 접근통제 유형 중 역할기반 접근 통제(RBAC; Role Based Access Control)는 무엇인지 서술하시오.

> RBAC은 중앙 관리자가 사용자와 시스템 상호관계를 통제하여, 조직 내 맡은 역할(Role)에 기초하여 자원에 대한 접근을 제한하는 방법이다.
> 

- 서버 접근통제 유형은 다음과 같다.
    - 강제적 접근통제(MAC; Mandatory Access Control)
        - 시스템 정보의 허용등급을 기준으로 사용자가 갖는 접근 허가 권한에 근거하여 시스템에 대한 접근을 제한하는 방법
        - MAC에서 사용자들은 자원에 대한 권한을 관리자로부터 부여
        - 관리자만이 시스템 자원에 대한 권한을 할당할 수 있음
    - 임의적 접근통제(DAC; Discretionary Access Control)
        - 시스템에 대한 접근을 사용자/그룹의 신분 기반으로 제한하는 방법
        - DAC에서 사용자는 자원과 관련된 ACL(Access Control List)이 수정됨으로써 자원에 대한 권한을 부여
    - 역할기반 접근통제(RBAC; Role Based Access Control)
        - 중앙 관리자가 사용자와 시스템의 상호관계를 통제하여 조직 내 맡은 역할(Role)에 기초하여 자원에 대한 접근을 제한하는 방법
        - RBAC에서 자원에 대한 접근은 사용자에게 할당된 역할에 기반
        - 관리자는 사용자에게 특정한 권리와 권한이 정의된 역할을 할당

---

Q. 1985년 코블리치와 밀러가 RSA 암호 방식에 대한 대안으로 처음 제안된 암호화 알고리즘으로 유한체 위에서 정의된 타원곡선 군에서의 이산대수의 문제에 기초한 공개키 알고리즘은 무엇인가?

> ECC(ElGamal Curve Cryptography)
> 

- 공개키(비대칭 키) 암호화 알고리즘은 다음과 같다.
    - 디피-헬만(Diffie-Hellman)
        - 최초의 공개키 알고리즘으로 W.Diffie와 M.Hellman이 1976년에 고안한 알고리즘으로써 유한 필드 내에서 이산대수의 계산이 어려운 문제를 기본 원리로 하고있음
        - Diffie-Hellman은 공개키 암호 방식의 개념을 이용하여 두 사용자 간에 공통의 암호화키를 안전하게 공유할 방법을 제시하였으며, 많은 키 분배 방식에 관한 연구의 기본이 됨(최초의 비밀키 교환 프로토콜)
    - RSA(Rivest-Shamir-Adleman)
        - 1977년 3명의 MIT 수학 교수(Rivest, Shamir, Adleman)가 고안한 큰 인수의 곱을 소인수분해하는 수학적 알고리즘으 이용하는 공개키 암호화 알고리즘
        - 비밀키의 복호화가 어려운 RSA 안정성은 소인수분해 문제의 어려움에 근거를 두고 있음
    - ECC(Elliptic Curve Cryptography)
        - 1985년 코블리치와 밀러가 RSA 암호 방식에 대한 대안으로 처음 제안
        - 타원 곡선 암호(ECC)는 유한체 위에서 정의된 타원곡선 군에서의 이산대수의 문제에 기초한 공개키 암호화 알고리즘
        - PKI 기반의 RSA의 문제점인 속도와 안전성을 해결하기 위해 타원 기반 구조체의 안정성과 효율성을 기반으로 생성되었고, RSA보다 키의 비트 수를 적게 하면서 동일한 성능을 제공하는 것이 가장 큰 특징
    - ElGamal
        - T.ElGamal이 1984년 제안한 공개키 알고리즘
        - 이산대수의 계산이 어려운 문제를 기본 원리로 하고 있으며, RSA와 유사하게 전자서명과 데이터 암∙복호화에 함께 사용 가능

---

Q. 다음은 [식사]와 [후식] 테이블이다. [식사]과 [후식] 테이블을 조인하여 [결과] 테이블처럼 모든 경우의 요리가 나오도록 쿼리를 작성하시오.

```sql
SELECT A.종류 AS 메인, B.종류 AS 디저트
FROM 식사 A
CROSS JOIN 후식 B;
```

[식사]

| 종류 |
| --- |
| 스파게티 |
| 피자 |
| 탕수육 |

[후식]

| 종류 |
| --- |
| 커피 |
| 떡 |
| 식혜 |

[결과]

| 메인 | 디저트 |
| --- | --- |
| 스파게티 | 커피 |
| 스파게티 | 떡 |
| 스파게티 | 식혜 |
| 피자 | 커피 |
| 피자 | 떡 |
| 피자 | 식혜 |
| 탕수육 | 커피 |
| 탕수육 | 떡 |
| 탕수육 | 식혜 |

- 조인 조건이 없는 모든 데이터 조합을 추출하는 조인은 교차 조인이다.
- 교차 조인 문법은 다음과 같다.
    
    ```sql
    SELECT 컬럼1, 컬럼2, ...
    FROM 테이블1
    CROSS JOIN 테이블2
    ```
    

---

Q. 다음은 관계 데이터 모델의 구성요소이다. () 안에 들어갈 구성요소를 쓰시오.

> 카디널리티(Cardinality), 차수(Degree)
> 
- 릴레이션(Realation): 행(Row)과 열(Column)로 구성된 테이블
- 튜플(Tuple): 릴레이션의 행(Row)에 해당하는요소
- 속성(Attribute): 릴레이션의 열(Column)에 해당하는 요소
- ( ① ): 튜플(Tuple)의 수
- ( ② ): 속성(Attribute)의 수

- 관계 데이터 모델의 구성요소는 다음과 같다.
    
    
    | 구성요소 | 설명 |
    | --- | --- |
    | 릴레이션(Relation) | 행(Row)과 열(Column)로 구성된 테이블 |
    | 튜플(Tuple) | 릴레이션의 행(Row)에 해당하는 요소 |
    | 속성(Attribute) | 릴레이션의 열(Column)에 해당하는 요소 |
    | 카디널리티(Cardinality) | 튜플(Tuple)의 수 |
    | 차수(Degree) | 속성(Attribute)의 수 |

---

Q. 데이터 흐름도에 나타나 있는 처리 항목을 1~2페이지 정도의 소규모 분량으로 요약하여 작성하는 논리적 명세서를 무엇이라 하는가?

> 소단위 명세서(Mini-Spec)
> 

- 요구사항 분석에 사용되는 기법 중에서 데이터 흐름도, 자료 사전, 소단위 명세서의 개념은 연계해서 함께 알고 있어야 한다.
    
    
    | 구분 | 설명 |
    | --- | --- |
    | 소단위 명세서 | 데이터 흐름도에 나타나 있는 처리 항목을 1~2페이지 정도의 소규모 분량으로 요약하여 작성하는 논리적 명세서 |
    | 자료 사전 | 자료 요소, 자료 요소들의 집합, 자료의 흐름, 자료 저장소의 의미와 그들 간의 관계, 관계값, 범위, 단위들을 구체적으로 명시하는 사전 |
    | 요구사항 명세서 | 소프트웨어 개발 프로세스의 시작인 소프트웨어의 요구사항을 분석하고 정의하는 단계에서 작성되는 최종 산출물 |

---

Q. 다음은 페이징 기법의 문제점과 해결 방안에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> 스레싱(Thrashing), 워킹 세트(Working Set), 페이지 부재 빈도(PFF; Page-Fault Frequency)
> 

( ① )은/는 어떤 프로세스가 계속적으로 페이지 부재가 발생하여 프로세스의 실제 처리 시간보다 페이지 교체 시간이 더 많아지는 현상으로 전체 시스템의 성능 및 처리율을 저하시키는 원인이 된다. 이를 해결하기 위한 기법 중 ( ② )은/는 각 프로세스가 많이 참조하는 페이지들의 집합을 주기억장치 공간에 계속 상주하게 하여 빈번한 페이지 교체 현상을 줄이고자 하는 기법이고, ( ③ )은/는 페이지 부재율의 상한과 하한을 정해서 직접적으로 페이지 부재율을 예측하고 조절하는 기법이다.

- 페이징 기법의 문제점과 해결방안은 다음과 같다.
    
    
    | 해결 방안 | 설명 |
    | --- | --- |
    | 스레싱(Thrashing) | 어떤 프로세스가 계속적으로 페이지 부재가 발생하여 프로세스의 실제 처리 시간보다 페이지 교체 시간이 더 많아지는 현상 |
    | 워킹 세트(Working Set) | 각 프로세스가 많이 참조하는 페이지들의 집합을 주기억장치 공간에 계속 상주하게 하여 빈번한 페이지 교체 현상을 줄이고자 하는 기법 |
    | 페이지 부재 빈도(PFF; Page-Fault Frequency) | 페이지 부재율의 상한과 하한을 정해서 직접적으로 페이지 부재율을 예측하고 조절하는 기법 |

---

Q. 다음은 배치 프로그램의 유형이다. () 안에 들어갈 유형을 쓰시오.

> 이벤트 배치(Event Batch), 온디맨드 배치(On-Demand Batch)
> 

- ( ① ): 사전에 정의해 둔 조건 충족 시 자동으로 실행하는 프로그램
- ( ② ): 사용자의 명시적 요구가 있을 때마다 실행하는 프로그램

- 배치(일괄) 프로그램의 유형은 다음과 같다.
    
    
    | 유형 | 설명 |
    | --- | --- |
    | 이벤트 배치 | 사전에 정의해 둔 조건 충족 시 자동으로 실행 |
    | 온디맨드 배치 | 사용자의 명시적 요구가 있을 때마다 실행 |
    | 정기 배치 | 정해진 시점(주로 야간)에 정기적으로실행 |

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> 11235
> 

```python
def soojebi(num):
	if num == 0 or num == 1:
		return 1
	return soojebi(num-2) + soojebi(num-1)

for i in range(0, 5):
	print(soojebi(i), end='')
```

- 파이썬 피보나치 수열 예제이다.
- 피보나치 수열은 다음과 같이 정의된다.
    
    f(n) = 1  (n ≤ 2일 때)
    
    f(n) = f(n-2) + f(n-1)  (n > 2일 때)
    
- 피보나치 수열은 처음 두 항은 1이고 세 번째 항부터는 바로 앞의 두항의 합이 되는 수열이다.

- 피보나치 수열을 구하기 위해 soojebi 함수에서 재귀호출을 이용하여 구현한다.
- soojebi 함수는 파라미터로 num을 전달하여 num이 0 또는 1이면 1을 리턴한다.
- num이 0 또는 1이 아니면 자기 자신인 soojebi 함수를 다시 호출한다.
- 이때 파라미터는 (num-2) 값과 (num-1) 값을 전달한다.
- for 문에서는 0부터 4까지 1씩 증가하며 반복을 수행한다. print 함수에서는 soojebi 함수를 호출하여 개행은 하지 않는다. end=’’는 개행(줄바꿈)을 하지 않음을 의미한다.