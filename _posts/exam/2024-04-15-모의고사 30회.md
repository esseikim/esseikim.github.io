---
categories: [Certificate, "[정보처리기사] 모의고사(01~35회)"]
---

Q. 기업의 내부 환경과 외부 환경을 분석하여 기업의 강점, 약점, 기회, 위협 요인을 규정하고 이를 토대로 경영 전략을 수립하는 방법을 무엇이라고 하는가?

> SWOT 분석
> 

- SWOT 분석은 기업의 내부 환경과 외부 환경을 분석하여 Strength(강점), Weakness(약점), Opportunity(기회), Threat(위협) 요인을 규정하고 이를 토대로 경영 전략을 수립하는 방법이다.

---

Q. 개념 관점, 역할 기반 관점, 활동평가 관점, 활동구현 관점, 취약성 관점 등의 활동 중심, 역할 기반의 프로세스로 구성된 보안 프레임워크로 이미 운영 중인 시스템에 적용하기 쉬운 보안 개발방법론을 무엇이라고 하는가?

> OWASP CLASP
> 

- OWASP CLASP는 개념 관점, 역할 기반 관점, 활동평가 관점, 활동 구현 관점, 취약성 관점 등의 활동 중심, 역할 기반의 프로세스로 구성된 보안 프레임워크로 이미 운영 중인 시스템에 적용하기 쉬운 보안 개발방법론이다.
- 프로그램 설계나 코딩 오류를 찾아내어 개선하기 위해 개발팀에 취약점 목록을 제공한다.

---

Q. 다음은 통신 프로토콜에 대한 설명이다. () 안에 들어갈 용어를 쓰시오.

> ICMP(Internet Control Message Protocol)
> 

()은/는 네트워크 계층(3계층)에서 IP 패킷을 처리할 때 발생되는 문제를 알려주고, 수신지 도달 불가 메시지를 사용하여 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는 데 사용하는 프로토콜이다.

- 통신 프로토콜 중 NetBIOS, ICMP 프로토콜의 설명은 다음과 같다.
    
    
    | 프로토콜 | 설명 |
    | --- | --- |
    | NetBIOS(Network Basic Input/Ouput System) | 응용계층(7계층)의 애플리케이션 프로그램에 API를 제공하여 상호 통신할 수 있도록 해주는 프로토콜 |
    | ICMP(Internet Control Message Protocol) | 네트워크 계층(3계층)에서 IP 패킷을 처리할 때 발생되는 문제를 알려주고, 수신지 도달 불가 메시지를 사용하여 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는 데 사용하는 프로토콜 |

---

Q. 다음은 무선보안과 관련된 내용이다. () 안에 들어갈 올바른 용어를 쓰시오.

> WPA(Wi-Fi Protected Access)
> 

()은/는 Wi-Fi 네트워크의 보안 기술이다. WEP(Wired Equivalent Privacy, 유선 동등 프라이버시)의 약점에 대응하여 개발되었다. WEP의 인증 및 암호화 기능을 향상시켰다.

- 무선보안과 관련된 주요용어는 다음과 같다.
    - SSID(Service Set IDentifier)
        - 무선 랜을 통해 전송되는 패킷들의 각 헤더에 덧붙여지는 32bit 길이의 고유 식별자
        - SSID는 하나의 무선 랜을 다른 무선 랜으로부터 구분
    - WPA(Wi-Fi Protected Access)
        - Wi-Fi 얼라이언스에서 Wi-Fi의 송출 신호에 대한 보안을 위해 고안된 물리 계층에서의 패킷 암호화 방식
        - TKIP과 AES의 두 가지 표준 기술 중 하나를 사용하여 WEP보다 강력한 암호화를 제공
        
- WEP은 Wired Equivalent Privacy의 약자로 유선랜에 상당하는 Privacy를 제공하기 위한 알고리즘

---

Q. 다음 [정처기] 테이블의 쿼리를 실행한 결과는 다음과 같다. [결과]에 들어갈 값을 쓰시오.

> 0
> 

[정처기]

| 이름 | 필기 | 실기 |
| --- | --- | --- |
| 엑소 | 80 | NULL |
| BTS | NULL | 100 |
| 세븐틴 | NULL | NULL |

[쿼리]

```sql
SELECT COUNT(필기*실기) FROM 정처기;
```

[결과]

| COUNT(필기*실기) |
| --- |
|  |

- SELECT 필기*실기 FROM 정처기; 쿼리를 동작시키면 같은 레코드의 필기와 실기 값을 곱한다. (NULL은 연산할 경우 결괏값은 NULL이다.)
    
    
    | 필기*실기 |
    | --- |
    | NULL |
    | NULL |
    | NULL |
- **COUNT 함수를 사용하면 NULL 값을 제외한 튜플들의 숫자를 반환**하므로 0이 된다.
    
    
    | COUNT(필기*실기) |
    | --- |
    | 0 |

---

Q. 다음은 C언어 코드이다. 출력 결과를 쓰시오.

> 17
> 

```c
#include <stdio.h>
void main() {
	int a = 5;
	int s = 0;
	switch(a/2) {
		case 2: s++;
		case 3: a += s;
		default: a++;
	}
	printf("%d%d", s, a);
}
```

- 정수형 변수 a는 선언과 동시에 5로 초기화한다.
- 정수형 변수 s는 선언과 동시에 0으로 초기화한다.
- switch의 조건에는 a/2 값인 2가 되어 case 2로 이동한다.
- case 2에서는 s++이 되어 s 값이 1 증가하여 2이 된다. case 2에서는 break가 없으므로 case 3도 실행되어 s의 1과 a의 5가 더해진 6이 a에 대입된다.
- case 3에서도 break가 없으므로 default가 실행되며, a++가 실행되어 a 값이 1 증가하여 7이 된다.
- s와 a를 출력하므로 17이 화면에 출력된다.

---

Q. XML(Extensible Markup Language)의 개념을 서술하시오.

> XML은 HTML의 단점을 보완한 인터넷 언어로, SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어이다.
> 

- XML의 특징은 다음과 같다.
    - 송∙수신 시스템 간 데이터 연계의 편의성을 위해서 전송되는 데이터 구조를 동일한 형태로 정의
    - 인간과 기계가 모두 이해할 수 있는 텍스트 형태로 마크업 포맷을 정의하기 위한 메타언어
    - 사용자가 직접 문서의 태그를 정의할 수 있으며, 다른 사용자가 정의한 태그를 사용할 수 있음

---

Q. 서버 하드웨어 개발환경 중 웹 애플리케이션 서버(WAS)에 대해 간략히 서술하시오.

> 웹 애플리케이션 서버는 사용자 요청 스레드를 처리하고, 데이터베이스에 접속하여 SQL 쿼리 문에 대한 결괏값을 반환하는 역할을 수행하는 서버이다.
> 

- 서버 하드웨어 개발환경은 다음과 같다.
    - 웹 서버
        - HTTP를 이용한 요청/응답을 처리, 웹상의 정적 콘텐츠(CSS, Javascript, Image)를 처리
        - WEB-WAS-DB의 3계층 구조를 실무에서 활용 - 주로 제품으로 Apache 웹 서버, IIS 웹 서버, Google Web Server, Nginx 등 존재
    - 웹 애플리케이션 서버
        - 사용자 요청 스레드를 처리하고, 데이터베이스에 접속하여 SQL 쿼리 문에 대한 결괏값을 반환
        - 주요 제품으로 Tomcat, Weblogic, Jeus, Resin 등 존재
    - 데이터베이스 서버
        - 데이터의 수집, 저장을 위한 용도로 사용
        - 연계되는 주요 DBMS로 MySql, Oracle, MS-SQL, DB2 등 존재
    - 파일 서버
        - 파일 저장 하드웨어로 물리 저장장치를 활용한 서버
        - 대용량 HDD, SSD 등의 장치가 존재

---

Q. 소프트웨어 아키텍처(Software Architecture)의 개념을 약술하시오.

> 소프트웨어 아키텍처는 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체이다.
> 

- 소프트웨어 아키텍처 관련 개념은 다음과 같다.
    - 소프트웨어 아키텍처 프레임워크
        - 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준(IEEE-1471)
    - 소프트웨어 아키텍처 4+1 뷰
        - 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
        - 4+1에서 1은 유스케이스 뷰, 4는 논리 뷰, 프로세스 뷰, 구현 뷰, 배포 뷰로 구성
    - 소프트웨어 아키텍처 패턴
        - 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식
        - 계층화 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴 등이 존재
    - 소프트웨어 아키텍처 비용 평가 모델
        - 아키텍처 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델
        - SAAM, ATAM, CBAM, ADR, ARID
    

---

Q. **다음 [부서] 테이블에서 ‘DT부’와 ‘보안부’를 삭제하는 쿼리를 작성하시오.**

```sql
DELETE FROM 부서
WHERE 부서명 = 'DT부' OR 부서명 = '보안부';
```

```sql
SELECT FROM 부서
WHERE 부서명 IN ('DT부', '보안부');
```

[부서]

| 부서번호 | 부서명 | 전화번호 |
| --- | --- | --- |
| 1 | 마케팅부 | 111-2222 |
| 2 | 영업부 | 333-4444 |
| 3 | 전략부 | 555-6666 |
| 4 | 보안부 | 777-8888 |
| 5 | DT부 | 999-0000 |

- DELETE는 데이터 내용을 삭제할 때 사용하는 명령어이다.
- DELETE 명령어 문법은 다음과 같다.
    
    ```sql
    DELETE
    FROM 테이블명
    WHERE 조건;
    ```
    
    - 모든 레코드를 삭제할 때는 WHERE절 없이 DELETE만 사용
    - 레코드를 삭제해도 테이블 구조는 남아 있어서 디스크에서 테이블을 완전히 삭제하는 DROP 명령과는 다름

---

Q. 다음은 자바 코드이다. 밑줄에 들어갈 알맞은 키워드를 쓰시오.

> new
> 

```java
abstract class Animal {
	abstract void getAge();
}
class Dog extends Animal {
	void getAge();
		System.out.print("5");
}
public class Soojebi {
	public static void main(String[] args) {
		Dog d =      Dog();
		d.getAge();
	}
}
```

- 객체를 생성하기 위해서는 new 연산자를 이용해야 한다.
- 클래스 생성을 할 때 다음과 같은 형식으로 사용한다.
    
    ```java
    클래스며 객체명 = new 생성자메서드();
    ```
    

---

Q. 소프트웨어 생명주기 모델 중 ()은/는 구축대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점증 완성시키는 SDLC 모델로 사용자의 요구사항 일부분 혹은 제품 일부분을 반복적으로 개발하여 최종 시스템으로 완성하는 모델이다. () 안에 들어갈 속성을 쓰시오.

> 반복적 모델(Iteration Model)
> 

- 소프트웨어 생명주기 모델의 종류는 다음과 같다.
    - 폭포수 모델(Waterfall Model)
        - 소프트웨어 개발 시 각 단계를 확실히 마무리 지은 후에 다음 단계로 넘어가는 모델
        - 가장 오래된 모델
        - 선형 순차적 모형으로 고전적 생명주기 모형이라고도 함
        - 모형의 적용 경험과 성공 사례가 많음
        - 단계별 정의와 산출물이 명확
        - 요구사항의 변경이 어려움
        - 절차: 타당성 검토 → 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수
    - 프로토타이핑 모델(Prototyping Model)
        - 고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델
        - 프로토타입은 발주자나 개발자 모두에게 공동의 참조 모델을 제공
        - 프로토타입은 구현 단계의 구현 골격
        - 절차: 요구사항 분석 → 프로토타입 개발 → 프로토타입 평가 → 구현 → 테스트
    - 나선형 모델(Spiral Model)
        - 시스템 개발 시 위험을 최소화하기 위해 점진적으로 완벽한 시스템으로 개발해 나가는 모델
        - 절차: 계획 및 정의 → 위험 분석 → 개발 및 검증 → 고객 평가
    - 반복적 모델(Iteration Model)
        - 구축대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점증 완성시키는 SDLC 모델
        - 사용자의 요구사항 일부분 혹은 제품 일부분을 반복적으로 개발하여 최종 시스템으로 완성시키는 모델

---

Q. 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴은 무엇인가?

> 프로토타입(Prototype) 패턴
> 

- 디자인 패턴의 종류 중 생성 패턴은 다음과 같다.
    - Builder
        - 복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴
        - 생성과 표기를 분리해서 복잡한 객체를 생성
    - Prototype
        - 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하여 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴
        - 기존 객체를 복제함으로써 객체를 생성
    - Factory Method
        - 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴
        - 생성할 객체의 클래스를 국한하지 않고 객체를 생성
    - Abstract Factory
        - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴으로 이 패턴을 통해 생성된 클래스에서는 사용자에게 인터페이스(API)를 제공하고, 구체적인 구현은 Con-crete Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴
        - 동일한 주제의 다른 팩토리를 묶음
    - Singleton
        - 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴
        - 한 클래스에 한 객체만 존재하도록 제한

---

Q. 스푸핑(Spoofing)의 개념을 서술하시오.

> 스푸핑은 승인받은 사용자인 것처럼 시스템에 접근하거나 네트워크상에서 허가된 주소로 가장하여 접근 제어를 우회하는 공격 기법이다.
> 

- 스니핑, 스푸핑, 스누핑의 차이점은  다음과 같다.
    
    
    | 개념 | 설명 |
    | --- | --- |
    | 스니핑(Sniffing) | 공격 대상에게 직접 공격하지 않고 데이터만 몰래 들여다보는 수동적 공격 기법(도청) |
    | 스푸핑(Spoofing) | 승인받은 사용자인 것처럼 시스템에 접근하거나 네트워크상에서 허가된 주소로 가장하여 접근 제어를 우회하는 공격 기법 |
    | 스누핑(Snooping) | 스니핑과 유사한 단어로, 네트워크상의 정보를 염탐하여 불법적으로 얻는 행위 |

 

---

Q. **다음은 [급여] 테이블이다. 부서별로 부서 내의 직원간 연봉의 순위를 매기는 쿼리를 작성하시오. (단, 부서, 연봉 순으로 내림차순을 수행한다.)**

```sql
SELECT 부서, 이름, 연봉, RANK() OVER (PARTITION BY 부서, ORDER BY 연봉 DESC) AS 순위
FROM 급여
ORDER BY 부서 DESC, 연봉 DESC
```

[급여]

| 부서 | 이름 | 연봉 |
| --- | --- | --- |
| 인사 | 광해군 | 4000 |
| 인사 | 연산군 | 2000 |
| 개발 | 홍길동 | 3000 |
| 개발 | 장길산 | 2800 |
| 개발 | 임꺽정 | 2500 |
| 영업 | 선덕여왕 | 3000 |
| 영업 | 진성여왕 | 2800 |
| 영업 | 진덕여왕 | 2500 |

[결과]

| 부서 | 이름 | 연봉 | 순위 |
| --- | --- | --- | --- |
| 개발 | 홍길동 | 3000 | 1 |
| 개발 | 장길산 | 2800 | 2 |
| 개발 | 임꺽정 | 2500 | 3 |
| 영업 | 선덕여왕 | 3000 | 1 |
| 영업 | 진성여왕 | 2800 | 2 |
| 영업 | 진덕여왕 | 2500 | 3 |
| 인사 | 광해군 | 4000 | 1 |
| 인사 | 연산군 | 2000 | 2 |

- 집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, ROLLUP이나 CUBE와는 달리 컬럼 간 순서와 무관한 결과를 얻을 수 있는 그룹 함수이다.
- GROUPING SETS를 이용해 다양한 소계 집합을 만들 수 있다.
- ORDER BY를 사용하여 집계 대상 그룹과의 표시 순서를 조정하여 체계적으로 보여줄 수 있다.
- GROUPING SETS 함수 문법은 다음과 같다.
    
    ```sql
    SELECT 컬럼1, 컬럼2, ..., 그룹 함수
    FROM 테이블명
    [WHERE ...]
    GROUP BY [컬럼 ...]
    	      GROUPING SETS(컬럼명a, ...)
    [HAVING ...]
    [ORDER BY ...]			
    ```
    
    - 개별 집계를 구할 수 있으며, ROLLUP 계층 구조와 달리 평등한 관계라 순서에 상관없이 동일한 결과

---

Q. 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 Row를 결합하여 원하는 결과를 조합하는 방식으로 먼저 선행 테이블의 처리 범위를 하나씩 액세스하면서 추출된 값으로 연결할 테이블을 조인하는 방식의 물리적 조인 유형은 무엇인가?

> 중첩 반복 조인(Nested-Loop Join)
> 

- 선행 테이블의 처리 범위를 하나씩 액세스하면서 추출된 값으로 연결할 테이블을 조인하는 방식은 중첩 반복 조인이다.

![이미지](/assets/img/exam/30/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC_30%ED%9A%8C(1).png)

---

Q. 최근 IoT 발전과 스마트 의료, 인공지능 발전과 함께 새로운 형태의 네트워크 기술이 부각되고 있다. 체내 혹은 인체 주변 3m 이내에서 일어나는 저비용, 저전력, 고속통신이 가능한 신체 접촉 근거리 무선 네트워크인 ( ① )와/과 기존의 IP 주소 대신 Data의 이름을 활용하여 정보(콘텐츠)의 효율적인 검색 및 배포를 목적으로 하는 미래 인터넷 기술인 ( ② )이/가 대표적이라고 할 수 있다. () 안에 들어갈 용어를 쓰시오.

> WBAN(Wireless Body Area Network), NDN(Named Data Networking)
> 

- WBAN과 NDN 기술은 다음과 같다.
    - WBAN(Wireless Body Area Network)
        - 체내 혹은 인체 주변 3m 이내에서 일어나는 저비용, 저전력, 고속통신이 가능한 신체 접촉 근거리 무선 네트워크
        - 웨어러블(Wearable) 또는 몸에 심는(Implant) 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술
        - 체내 혹은 인체의 주변에서 일어나는 근거리 통신으로 센서, 통신, 구동체 등의 다양한 기술이 복합적으로 적용되고 있다. IEEE에서는 WBAN의 정의로 인체를 기준으로 하여 인체내부 및 인체로부터 3미터 이내의 무선통신으로 정의하고 있다. 이에 따라 WBAN은 현재 다양한 용도로 응용되고 있는데 크게 분류하면 의료용과 비의료용 무선기기로 구분할 수 있다.
    - NDN(Named Data Networking)
        - 기존의 IP 주소 대신 Data의 이름을 활용하여 정보(콘텐츠)의 효율적인 검색 및 배포를 목적으로 하는 미래 인터넷 기술

---

Q. 다음은 해시 암호화 알고리즘에 대한 설명이다. () 안에 들어갈 알고리즘을 쓰시오.

> MD5(Message-Digest Algorithm 5), HAS-160
> 

( ① )은/는 1991년 R.rivest가 MD4를 개선한 암호화 알고리즘으로 프로그램이나 파일의 무결성 검사에 사용하고, 각각의 512비트짜리 입력 메시지 블록에 대해 차례로 동작하여 128비트의 해시값을 생성하는 해시 알고리즘이다. 또한 ( ② )은/는 국내 표준 서명 알고리즘 KCDSA(Korean Certificate-based Digital Signature Algorithm)을 위하여 개발된 해시함수를 이용하고, MD5와 SHA1의 장점을 취하여 개발된 해시 알고리즘이다. 

- 해시 암호화 알고리즘에 대한 설명은 다음과 같다.
    - MD5(Message-Digest Algorithm 5)
        - 1991년 R.rivest가 MD4를 개선한 암호화 알고리즘으로 프로그래밍이나 파일의 무결성 검사에 사용
        - 각각의 512bit짜리 입력 메시지 블록에 대해 차례로 동작하여 128bit의 해시값을 생성하는 해시 알고리즘
    - SHA-1(Secure Hash Algorithm)
        - 1993년 NSA(National Security Agency, 국가 안보국)에서 미 정부 표준으로 지정되었고, DSA(Digital Signature Algorithm)에서 사용
        - 160bit의 해시값을 생성하는 해시 알고리즘
    - SHA-256/384/512(Secure Hash Algorithm)
        - SHA(Secure Hash Algorithm) 알고리즘의 한 종류로서 256bit의 해시값을 생성하는 해시함수
        - AES(Advanced Encryption Standard, 미 연방 표준 알고리즘)의 키 길이인 128, 192, 256 bit에 대응하도록 출력 길이를 늘인 해시 알고리즘
    - HAS-160
        - 국내표준서명 알고리즘 KCDSA(Korean Certificate-based Digital Signature Algorithm)를 위하여 개발된 해시함수
        - MD5와 SHA-1의 장점을 취하여 개발된 해시 알고리즘

---

Q. 전송 계층에서 신뢰성 있는 세그먼트 전송 보장을 위해, 송신 측과 수신 측 간 TCP Connection 수립 및 전달, 종료되도록 TCP Flags 기반 동작을 수행하는 접속 규약을 무엇이라고 하는가?

> TCP 핸드셰이킹(Handshaking)
> 

- TCP 핸드셰이킹의 종류는 다음과 같다.
    - TCP 3방향 핸드셰이킹(연결 설정)
        - TCP 3방향 핸드셰이킹은 전송 계층에서 송신 측과 수신 측 간 TCP 연결 설정, 수락, 확인 세 가지 절차를 거치는 연결 설정 규약
    - TCP 4방향 핸드셰이킹(연결 종료)
        - TCP 4방향 핸드셰이킹은 전송 계층에서 송신 측과 수신 측 간 서로 연결을 종료할 때 수행하는 접속 종료 규약

---

Q. 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

> **eo**
> 

```python
a = "hello soojebi"
print(a[1:5:3])
```

- 문자열인 “hello soojebi”에서 일부분을 추출하는 슬라이스 예제이다.
- 슬라이스 문법은 `[start:end:step]`이다.
    - start
        - 시작 인덱스로 **슬라이싱을 시작할 위치**
        - 시작 인덱스는 0부터 시작함
        
        ```python
        # 시작 인덱스는 1이므로 [2, 3] 을 출력함
        a = [1, 2, 3, 4, 5]
        a[1:3:1]
        ```
        
    - end
        - 종료 인덱스로 **슬라이싱을 끝낼 위치**
        - end는 포함하지 않음
        
        ```python
        # 종료 인덱스는 4이므로 3번째 위치까지인 [2, 3, 4]를 출력함
        a = [1, 2, 3, 4, 5]
        a[1:4:1]
        ```
        
    - step
        - 스텝으로 몇 칸씩 이동할지를 지정
        
        ```python
        # 2칸씩 이동하면서 [1, 3, 5]를 출력함
        a = [1, 2, 3, 4, 5]
        a[::2]
        ```
        
- start, end, step은 모두 양수, 음수를 가질 수 있다.
- 시작 인덱스는 0부터 시작하며 종료 인덱스는 종료 인덱스 전까지만 슬라이싱한다. 부분별로 잘라내는 경우 다음과 같이 추출된다. hello
    
    
    | 구분 | 값 |
    | --- | --- |
    | a[0:5:1] | hello |
    | a[1:5:1] | ello |
    | a[1:5:2] | el |
    | a[1:5:3] | eo |
    | a[1:5:4] | e |
